<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>&quot;&#x27;do&#x27; Unchained&quot; rendered supplement</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="alectryon.css">
        <link rel="stylesheet" href="pygments.css">
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme && theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar && sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><li class="part-title">Reference Implementation</li><li class="chapter-item expanded "><a href="Basic.lean.html"><strong aria-hidden="true">1.</strong> Basic do Notation</a></li><li class="chapter-item expanded "><a href="Mut.lean.html"><strong aria-hidden="true">2.</strong> Local Mutation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="LazyList.lean.html"><strong aria-hidden="true">2.1.</strong> Nondeterminism Monad</a></li></ol></li><li class="chapter-item expanded "><a href="Return.lean.html"><strong aria-hidden="true">3.</strong> Early Return</a></li><li class="chapter-item expanded "><a href="For.lean.html"><strong aria-hidden="true">4.</strong> Iteration</a></li><li class="chapter-item expanded affix "><li class="part-title">Formalization</li><li class="chapter-item expanded "><a href="Formal.lean.html"><strong aria-hidden="true">5.</strong> Formalization</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">&quot;&#x27;do&#x27; Unchained&quot; rendered supplement</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/Kha/do-supplement" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <div style="break-before: page; page-break-before: always;"></div><h1 id="basic-do-notation"><a class="header" href="#basic-do-notation">Basic <code>do</code> notation</a></h1>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kn">open</span></span><span class="alectryon-token"> Lean

</span><span class="alectryon-token"><span class="k">declare_syntax_cat</span></span><span class="alectryon-token"> stmt
</span><span class="alectryon-token"><span class="k">syntax</span></span><span class="alectryon-token"> <span class="s2">&quot;do&#39;&quot;</span> stmt : term

<span class="c1">-- Prevent `if ...` from being parsed as a term</span>
</span><span class="alectryon-token"><span class="k">syntax</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><span class="k">priority</span></span><span class="alectryon-token"> := </span><span class="alectryon-token"><span class="k">low</span></span><span class="alectryon-token">) term : stmt
</span><span class="alectryon-token"><span class="k">syntax</span></span><span class="alectryon-token"> <span class="s2">&quot;let&quot;</span> ident <span class="s2">&quot;←&quot;</span> stmt:<span class="mi">1</span> <span class="s2">&quot;;&quot;</span> stmt : stmt
</span><span class="alectryon-token"><span class="k">macro</span></span><span class="alectryon-token"> <span class="s2">&quot;{&quot;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>TSyntax `stmt</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token">:stmt <span class="s2">&quot;}&quot;</span> : stmt <span class="bp">=&gt;</span> <span class="bp">`</span>(<span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>TSyntax `stmt</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token">)</span><span class="alectryon-token">

<span class="c">/-</span><span class="cm"></span>
<span class="cm">  Remark: we annotate `macro`s and `macro_rules` with their corresponding</span>
<span class="cm">  translation/abbreviation id from the paper.</span>
<span class="cm">-/</span>

</span><span class="alectryon-token"><span class="k">syntax</span></span><span class="alectryon-token"> <span class="s2">&quot;d!&quot;</span> stmt : term  <span class="c1">-- corresponds to `D(s)`</span>

</span><span class="alectryon-token"><span class="k">macro_rules</span></span><span class="alectryon-token">
  <span class="bp">|</span> <span class="bp">`</span>(</span><span class="alectryon-token"><span class="k">do</span><span class="bp">&#39;</span></span><span class="alectryon-token"> <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>TSyntax `stmt</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token">) <span class="bp">=&gt;</span> <span class="bp">`</span>(</span><span class="alectryon-token">d<span class="bp">!</span></span><span class="alectryon-token"> <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>TSyntax `stmt</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token">)</span><span class="alectryon-token">  <span class="c1">-- (1)</span>

<span class="c1">-- helper function; see usage below</span>
</span><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>expandStmt</var><b>: </b><span>TSyntax `stmt → MacroM (TSyntax `stmt)</span></span></div></blockquote></div></small></div><span class="nv">expandStmt</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>TSyntax `stmt</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>TSyntax</var><b>: </b><span>SyntaxNodeKinds → Type</span></span></div></blockquote></div></small></div>TSyntax</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>`stmt</var><b>: </b><span>Name</span></span></div></blockquote></div></small></div><span class="bp">`</span>stmt</span><span class="alectryon-token">) : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>MacroM</var><b>: </b><span>Type → Type</span></span></div></blockquote></div></small></div>MacroM</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>TSyntax</var><b>: </b><span>SyntaxNodeKinds → Type</span></span></div></blockquote></div></small></div>TSyntax</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>`stmt</var><b>: </b><span>Name</span></span></div></blockquote></div></small></div><span class="bp">`</span>stmt</span><span class="alectryon-token">) := </span><span class="alectryon-token"><span class="k">do</span></span><span class="alectryon-token">
  </span><span class="alectryon-token"><span class="k">let</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s'</var><b>: </b><span>Syntax</span></span></div></blockquote></div></small></div><span class="nv">s&#39;</span></span><span class="alectryon-token"> <span class="bp">←</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>expandMacros</var><b>: </b><span>Syntax → (optParam (SyntaxNodeKind → Bool) fun k =&gt; k != `Lean.Parser.Term.byTactic) → MacroM Syntax</span></span></div></blockquote></div></small></div>expandMacros</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>TSyntax `stmt</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token">
  </span><span class="alectryon-token"><span class="k">if</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>TSyntax `stmt</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token"> <span class="bp">==</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s'</var><b>: </b><span>Syntax</span></span></div></blockquote></div></small></div><span class="nv">s&#39;</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">then</span></span><span class="alectryon-token">
    </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Macro.throwUnsupported</var><b>: </b><span>{α : Type} → MacroM α</span></span></div></blockquote></div></small></div>Macro.throwUnsupported</span><span class="alectryon-token">
  </span><span class="alectryon-token"><span class="k">else</span></span><span class="alectryon-token">
    <span class="c1">-- There is no static guarantee that `expandMacros` stays in the `stmt` category,</span>
    <span class="c1">-- but it is true for all our macros</span>
    </span><span class="alectryon-token"><span class="k">return</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>TSyntax.mk</var><b>: </b><span>{ks : SyntaxNodeKinds} → Syntax → TSyntax ks</span></span></div></blockquote></div></small></div>TSyntax.mk</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s'</var><b>: </b><span>Syntax</span></span></div></blockquote></div></small></div><span class="nv">s&#39;</span></span><span class="alectryon-token">

</span><span class="alectryon-token"><span class="k">macro_rules</span></span><span class="alectryon-token">
  <span class="bp">|</span> <span class="bp">`</span>(</span><span class="alectryon-token">d<span class="bp">!</span></span><span class="alectryon-token"> <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>TSyntax `term</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token">:term) <span class="bp">=&gt;</span> <span class="bp">`</span>(<span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>TSyntax `term</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token">)                                       <span class="c1">-- (D1)</span>
  <span class="bp">|</span> <span class="bp">`</span>(</span><span class="alectryon-token">d<span class="bp">!</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">let</span></span><span class="alectryon-token"> <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>TSyntax `ident</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> <span class="bp">←</span> <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>TSyntax `stmt</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token"><span class="bp">;</span> <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s'</var><b>: </b><span>TSyntax `stmt</span></span></div></blockquote></div></small></div><span class="nv">s&#39;</span></span><span class="alectryon-token">) <span class="bp">=&gt;</span> <span class="bp">`</span>((</span><span class="alectryon-token">d<span class="bp">!</span></span><span class="alectryon-token"> <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>TSyntax `stmt</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token">) <span class="bp">&gt;&gt;=</span> </span><span class="alectryon-token"><span class="k">fun</span></span><span class="alectryon-token"> <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>TSyntax `ident</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> (</span><span class="alectryon-token">d<span class="bp">!</span></span><span class="alectryon-token"> <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s'</var><b>: </b><span>TSyntax `stmt</span></span></div></blockquote></div></small></div><span class="nv">s&#39;</span></span><span class="alectryon-token">))  <span class="c1">-- (D2)</span>
  <span class="bp">|</span> <span class="bp">`</span>(</span><span class="alectryon-token">d<span class="bp">!</span></span><span class="alectryon-token"> <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>TSyntax `stmt</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token">) <span class="bp">=&gt;</span> </span><span class="alectryon-token"><span class="k">do</span></span><span class="alectryon-token">
    <span class="c1">-- fallback rule: try to expand abbreviation</span>
    </span><span class="alectryon-token"><span class="k">let</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s'</var><b>: </b><span>TSyntax `stmt</span></span></div></blockquote></div></small></div><span class="nv">s&#39;</span></span><span class="alectryon-token"> <span class="bp">←</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>expandStmt</var><b>: </b><span>TSyntax `stmt → MacroM (TSyntax `stmt)</span></span></div></blockquote></div></small></div><span class="k">expandStmt</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>TSyntax `stmt</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token">
    <span class="bp">`</span>(</span><span class="alectryon-token">d<span class="bp">!</span></span><span class="alectryon-token"> <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s'</var><b>: </b><span>TSyntax `stmt</span></span></div></blockquote></div></small></div><span class="nv">s&#39;</span></span><span class="alectryon-token">)</span><span class="alectryon-token">

</span><span class="alectryon-token"><span class="k">macro</span></span><span class="alectryon-token"> <span class="s2">&quot;let&quot;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>TSyntax `ident</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token">:ident <span class="s2">&quot;:=&quot;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>TSyntax `term</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token">:term <span class="s2">&quot;;&quot;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>TSyntax `stmt</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token">:stmt : stmt <span class="bp">=&gt;</span> <span class="bp">`</span>(</span><span class="alectryon-token"><span class="k">let</span></span><span class="alectryon-token"> <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>TSyntax `ident</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> <span class="bp">←</span> pure <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>TSyntax `term</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token"><span class="bp">;</span> <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>TSyntax `stmt</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token">)</span><span class="alectryon-token">  <span class="c1">-- (A1)</span>
<span class="c1">-- priority `0` prevents `;` from being used in trailing contexts without braces (see e.g. `:1` above)</span>
</span><span class="alectryon-token"><span class="k">macro</span></span><span class="alectryon-token">:<span class="mi">0</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s₁</var><b>: </b><span>TSyntax `stmt</span></span></div></blockquote></div></small></div><span class="nv">s₁</span></span><span class="alectryon-token">:stmt <span class="s2">&quot;;&quot;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s₂</var><b>: </b><span>TSyntax `stmt</span></span></div></blockquote></div></small></div><span class="nv">s₂</span></span><span class="alectryon-token">:stmt : stmt <span class="bp">=&gt;</span> <span class="bp">`</span>(</span><span class="alectryon-token"><span class="k">let</span></span><span class="alectryon-token"> x <span class="bp">←</span> <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s₁</var><b>: </b><span>TSyntax `stmt</span></span></div></blockquote></div></small></div><span class="nv">s₁</span></span><span class="alectryon-token"><span class="bp">;</span> <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s₂</var><b>: </b><span>TSyntax `stmt</span></span></div></blockquote></div></small></div><span class="nv">s₂</span></span><span class="alectryon-token">)</span><span class="alectryon-token">                     <span class="c1">-- (A2)</span></span></span></pre><div style="break-before: page; page-break-before: always;"></div><pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kn">import</span> Do.Basic
<span class="kn">import</span> Do.LazyList</span></span></pre>
<h1 id="local-mutation"><a class="header" href="#local-mutation">Local Mutation</a></h1>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kn">open</span></span><span class="alectryon-token"> Lean</span></span></pre>
<p>Disable the automatic monadic lifting feature described in the paper.
We want to make it clear that we do not depend on it.</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">set_option</span></span><span class="alectryon-token"> autoLift </span><span class="alectryon-token"><span class="k">false</span></span><span class="alectryon-token">

</span><span class="alectryon-token"><span class="k">syntax</span></span><span class="alectryon-token"> <span class="s2">&quot;let&quot;</span> <span class="s2">&quot;mut&quot;</span> ident <span class="s2">&quot;:=&quot;</span> term <span class="s2">&quot;;&quot;</span> stmt : stmt
</span><span class="alectryon-token"><span class="k">syntax</span></span><span class="alectryon-token"> ident <span class="s2">&quot;:=&quot;</span> term : stmt
</span><span class="alectryon-token"><span class="k">syntax</span></span><span class="alectryon-token"> <span class="s2">&quot;if&quot;</span> term <span class="s2">&quot;then&quot;</span> stmt <span class="s2">&quot;else&quot;</span> stmt:<span class="mi">1</span> : stmt

</span><span class="alectryon-token"><span class="k">declare_syntax_cat</span></span><span class="alectryon-token"> expander
<span class="c1">-- generic syntax for traversal-like functions S_y/R/B/L</span>
</span><span class="alectryon-token"><span class="k">syntax</span></span><span class="alectryon-token"> <span class="s2">&quot;expand!&quot;</span> expander <span class="s2">&quot;in&quot;</span> stmt:<span class="mi">1</span> : stmt
</span><span class="alectryon-token"><span class="k">syntax</span></span><span class="alectryon-token"> <span class="s2">&quot;mut&quot;</span> ident : expander  <span class="c1">-- corresponds to `S_y`</span>

<span class="c1">-- generic traversal rules</span>
</span><span class="alectryon-token"><span class="k">macro_rules</span></span><span class="alectryon-token">
  <span class="bp">|</span> <span class="bp">`</span>(stmt<span class="bp">|</span> </span><span class="alectryon-token">expand<span class="bp">!</span></span><span class="alectryon-token"> <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>exp</var><b>: </b><span>TSyntax `expander</span></span></div></blockquote></div></small></div><span class="nv">exp</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">in</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">let</span></span><span class="alectryon-token"> <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>TSyntax `ident</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> <span class="bp">←</span> <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>TSyntax `stmt</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token"><span class="bp">;</span> <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s'</var><b>: </b><span>TSyntax `stmt</span></span></div></blockquote></div></small></div><span class="nv">s&#39;</span></span><span class="alectryon-token">) <span class="bp">=&gt;</span> <span class="bp">`</span>(stmt<span class="bp">|</span> </span><span class="alectryon-token"><span class="k">let</span></span><span class="alectryon-token"> <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>TSyntax `ident</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> <span class="bp">←</span> </span><span class="alectryon-token">expand<span class="bp">!</span></span><span class="alectryon-token"> <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>exp</var><b>: </b><span>TSyntax `expander</span></span></div></blockquote></div></small></div><span class="nv">exp</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">in</span></span><span class="alectryon-token"> <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>TSyntax `stmt</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token"><span class="bp">;</span> </span><span class="alectryon-token">expand<span class="bp">!</span></span><span class="alectryon-token"> <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>exp</var><b>: </b><span>TSyntax `expander</span></span></div></blockquote></div></small></div><span class="nv">exp</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">in</span></span><span class="alectryon-token"> <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s'</var><b>: </b><span>TSyntax `stmt</span></span></div></blockquote></div></small></div><span class="nv">s&#39;</span></span><span class="alectryon-token">)                <span class="c1">-- subsumes (R3, B4, L4)</span>
  <span class="bp">|</span> <span class="bp">`</span>(stmt<span class="bp">|</span> </span><span class="alectryon-token">expand<span class="bp">!</span></span><span class="alectryon-token"> <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>exp</var><b>: </b><span>TSyntax `expander</span></span></div></blockquote></div></small></div><span class="nv">exp</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">in</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">let</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">mut</span></span><span class="alectryon-token"> <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>TSyntax `ident</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> := <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>TSyntax `term</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token"><span class="bp">;</span> <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s'</var><b>: </b><span>TSyntax `stmt</span></span></div></blockquote></div></small></div><span class="nv">s&#39;</span></span><span class="alectryon-token">) <span class="bp">=&gt;</span> <span class="bp">`</span>(stmt<span class="bp">|</span> </span><span class="alectryon-token"><span class="k">let</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">mut</span></span><span class="alectryon-token"> <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>TSyntax `ident</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> := <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>TSyntax `term</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token"><span class="bp">;</span> </span><span class="alectryon-token">expand<span class="bp">!</span></span><span class="alectryon-token"> <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>exp</var><b>: </b><span>TSyntax `expander</span></span></div></blockquote></div></small></div><span class="nv">exp</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">in</span></span><span class="alectryon-token"> <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s'</var><b>: </b><span>TSyntax `stmt</span></span></div></blockquote></div></small></div><span class="nv">s&#39;</span></span><span class="alectryon-token">)                      <span class="c1">-- subsumes (R4, B5, L5)</span>
  <span class="bp">|</span> <span class="bp">`</span>(stmt<span class="bp">|</span> </span><span class="alectryon-token">expand<span class="bp">!</span></span><span class="alectryon-token"> <span class="bp">$</span>_ </span><span class="alectryon-token"><span class="k">in</span></span><span class="alectryon-token"> <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>TSyntax `ident</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token">:ident := <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>TSyntax `term</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token">) <span class="bp">=&gt;</span> <span class="bp">`</span>(stmt<span class="bp">|</span> <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>TSyntax `ident</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token">:ident := <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>TSyntax `term</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token">)                                                      <span class="c1">-- subsumes (R5, B6, L6)</span>
  <span class="bp">|</span> <span class="bp">`</span>(stmt<span class="bp">|</span> </span><span class="alectryon-token">expand<span class="bp">!</span></span><span class="alectryon-token"> <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>exp</var><b>: </b><span>TSyntax `expander</span></span></div></blockquote></div></small></div><span class="nv">exp</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">in</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">if</span></span><span class="alectryon-token"> <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>TSyntax `term</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">then</span></span><span class="alectryon-token"> <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s₁</var><b>: </b><span>TSyntax `stmt</span></span></div></blockquote></div></small></div><span class="nv">s₁</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">else</span></span><span class="alectryon-token"> <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s₂</var><b>: </b><span>TSyntax `stmt</span></span></div></blockquote></div></small></div><span class="nv">s₂</span></span><span class="alectryon-token">) <span class="bp">=&gt;</span> <span class="bp">`</span>(stmt<span class="bp">|</span> </span><span class="alectryon-token"><span class="k">if</span></span><span class="alectryon-token"> <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>TSyntax `term</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">then</span></span><span class="alectryon-token"> </span><span class="alectryon-token">expand<span class="bp">!</span></span><span class="alectryon-token"> <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>exp</var><b>: </b><span>TSyntax `expander</span></span></div></blockquote></div></small></div><span class="nv">exp</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">in</span></span><span class="alectryon-token"> <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s₁</var><b>: </b><span>TSyntax `stmt</span></span></div></blockquote></div></small></div><span class="nv">s₁</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">else</span></span><span class="alectryon-token"> </span><span class="alectryon-token">expand<span class="bp">!</span></span><span class="alectryon-token"> <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>exp</var><b>: </b><span>TSyntax `expander</span></span></div></blockquote></div></small></div><span class="nv">exp</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">in</span></span><span class="alectryon-token"> <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s₂</var><b>: </b><span>TSyntax `stmt</span></span></div></blockquote></div></small></div><span class="nv">s₂</span></span><span class="alectryon-token">)  <span class="c1">-- subsumes (S6, R6, B7, L7)</span>
  <span class="bp">|</span> <span class="bp">`</span>(stmt<span class="bp">|</span> </span><span class="alectryon-token">expand<span class="bp">!</span></span><span class="alectryon-token"> <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>exp</var><b>: </b><span>TSyntax `expander</span></span></div></blockquote></div></small></div><span class="nv">exp</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">in</span></span><span class="alectryon-token"> <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>TSyntax `stmt</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token">) <span class="bp">=&gt;</span> </span><span class="alectryon-token"><span class="k">do</span></span><span class="alectryon-token">
    </span><span class="alectryon-token"><span class="k">let</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s'</var><b>: </b><span>TSyntax `stmt</span></span></div></blockquote></div></small></div><span class="nv">s&#39;</span></span><span class="alectryon-token"> <span class="bp">←</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>expandStmt</var><b>: </b><span>TSyntax `stmt → MacroM (TSyntax `stmt)</span></span></div></blockquote></div></small></div><span class="k">expandStmt</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>TSyntax `stmt</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token">
    <span class="bp">`</span>(stmt<span class="bp">|</span> </span><span class="alectryon-token">expand<span class="bp">!</span></span><span class="alectryon-token"> <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>exp</var><b>: </b><span>TSyntax `expander</span></span></div></blockquote></div></small></div><span class="nv">exp</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">in</span></span><span class="alectryon-token"> <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s'</var><b>: </b><span>TSyntax `stmt</span></span></div></blockquote></div></small></div><span class="nv">s&#39;</span></span><span class="alectryon-token">)</span><span class="alectryon-token">


</span><span class="alectryon-token"><span class="k">macro_rules</span></span><span class="alectryon-token">
  <span class="bp">|</span> <span class="bp">`</span>(</span><span class="alectryon-token">d<span class="bp">!</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">let</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">mut</span></span><span class="alectryon-token"> <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>TSyntax `ident</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> := <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>TSyntax `term</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token"><span class="bp">;</span> <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>TSyntax `stmt</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token">) <span class="bp">=&gt;</span> <span class="bp">`</span>(</span><span class="alectryon-token"><span class="k">let</span></span><span class="alectryon-token"> <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>TSyntax `ident</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> := <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>TSyntax `term</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token"><span class="bp">;</span> StateT.run&#39; (</span><span class="alectryon-token">d<span class="bp">!</span></span><span class="alectryon-token"> </span><span class="alectryon-token">expand<span class="bp">!</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">mut</span></span><span class="alectryon-token"> <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>TSyntax `ident</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">in</span></span><span class="alectryon-token"> <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>TSyntax `stmt</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token">) <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>TSyntax `ident</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token">) <span class="c1">-- (D3)</span>
  <span class="bp">|</span> <span class="bp">`</span>(</span><span class="alectryon-token">d<span class="bp">!</span></span><span class="alectryon-token"> <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>TSyntax `ident</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token">:ident := <span class="bp">$</span>_:term) <span class="bp">=&gt;</span>
      <span class="c1">-- `s!&quot;...&quot;` is an interpolated string. For more information, see https://leanprover.github.io/lean4/doc/stringinterp.html.</span>
      </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>throw</var><b>: </b><span>{ε : Type} → {m : Type → Type} → [self : MonadExcept ε m] → {α : Type} → ε → m α</span></span></div></blockquote></div></small></div><span class="k">throw</span></span><span class="alectryon-token"> <span class="bp">&lt;|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Macro.Exception.error</var><b>: </b><span>Syntax → String → Macro.Exception</span></span></div></blockquote></div></small></div><span class="k">Macro.Exception.error</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>TSyntax `ident</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> </span><span class="alectryon-token">s<span class="bp">!</span></span><span class="alectryon-token"><span class="s2">&quot;variable &#39;{</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>TSyntax `ident</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"><span class="k">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>getId</var><b>: </b><span>Ident → Name</span></span></div></blockquote></div></small></div><span class="k">getId</span></span><span class="alectryon-token">}<span class="bp">&#39;</span> is not reassignable <span class="k">in</span> this scope<span class="s2">&quot;</span>
<span class="s2">  | `(</span></span><span class="alectryon-token">d<span class="bp">!</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">if</span></span><span class="alectryon-token"> <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>TSyntax `term</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">then</span></span><span class="alectryon-token"> <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s₁</var><b>: </b><span>TSyntax `stmt</span></span></div></blockquote></div></small></div><span class="nv">s₁</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">else</span></span><span class="alectryon-token"> <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s₂</var><b>: </b><span>TSyntax `stmt</span></span></div></blockquote></div></small></div><span class="nv">s₂</span></span><span class="alectryon-token">) <span class="bp">=&gt;</span> <span class="bp">`</span>(</span><span class="alectryon-token"><span class="k">if</span></span><span class="alectryon-token"> <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>TSyntax `term</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">then</span></span><span class="alectryon-token"> </span><span class="alectryon-token">d<span class="bp">!</span></span><span class="alectryon-token"> <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s₁</var><b>: </b><span>TSyntax `stmt</span></span></div></blockquote></div></small></div><span class="nv">s₁</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">else</span></span><span class="alectryon-token"> </span><span class="alectryon-token">d<span class="bp">!</span></span><span class="alectryon-token"> <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s₂</var><b>: </b><span>TSyntax `stmt</span></span></div></blockquote></div></small></div><span class="nv">s₂</span></span><span class="alectryon-token">)</span><span class="alectryon-token">                       <span class="c1">-- (D4)</span>

</span><span class="alectryon-token"><span class="k">macro_rules</span></span><span class="alectryon-token">
  <span class="bp">|</span> <span class="bp">`</span>(stmt<span class="bp">|</span> </span><span class="alectryon-token">expand<span class="bp">!</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">mut</span></span><span class="alectryon-token"> <span class="bp">$</span>_ </span><span class="alectryon-token"><span class="k">in</span></span><span class="alectryon-token"> <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>TSyntax `term</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token">:term) <span class="bp">=&gt;</span> <span class="bp">`</span>(stmt<span class="bp">|</span> StateT.lift <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>TSyntax `term</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token">)  <span class="c1">-- (S1)</span>
  <span class="bp">|</span> <span class="bp">`</span>(stmt<span class="bp">|</span> </span><span class="alectryon-token">expand<span class="bp">!</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">mut</span></span><span class="alectryon-token"> <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>y</var><b>: </b><span>TSyntax `ident</span></span></div></blockquote></div></small></div><span class="nv">y</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">in</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">let</span></span><span class="alectryon-token"> <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>TSyntax `ident</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> <span class="bp">←</span> <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>TSyntax `stmt</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token"><span class="bp">;</span> <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s'</var><b>: </b><span>TSyntax `stmt</span></span></div></blockquote></div></small></div><span class="nv">s&#39;</span></span><span class="alectryon-token">) <span class="bp">=&gt;</span>                <span class="c1">-- (S2)</span>
    </span><span class="alectryon-token"><span class="k">if</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>TSyntax `ident</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> <span class="bp">==</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>y</var><b>: </b><span>TSyntax `ident</span></span></div></blockquote></div></small></div><span class="nv">y</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">then</span></span><span class="alectryon-token">
      </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>throw</var><b>: </b><span>{ε : Type} → {m : Type → Type} → [self : MonadExcept ε m] → {α : Type} → ε → m α</span></span></div></blockquote></div></small></div><span class="k">throw</span></span><span class="alectryon-token"> <span class="bp">&lt;|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Macro.Exception.error</var><b>: </b><span>Syntax → String → Macro.Exception</span></span></div></blockquote></div></small></div><span class="k">Macro.Exception.error</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>TSyntax `ident</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> </span><span class="alectryon-token">s<span class="bp">!</span></span><span class="alectryon-token"><span class="s2">&quot;cannot shadow &#39;mut&#39; variable &#39;{</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>TSyntax `ident</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"><span class="k">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>getId</var><b>: </b><span>Ident → Name</span></span></div></blockquote></div></small></div><span class="k">getId</span></span><span class="alectryon-token">}<span class="bp">&#39;</span><span class="s2">&quot;</span>
    </span><span class="alectryon-token"><span class="k">else</span></span><span class="alectryon-token">
      <span class="bp">`</span>(stmt<span class="bp">|</span> </span><span class="alectryon-token"><span class="k">let</span></span><span class="alectryon-token"> <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>TSyntax `ident</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> <span class="bp">←</span> </span><span class="alectryon-token">expand<span class="bp">!</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">mut</span></span><span class="alectryon-token"> <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>y</var><b>: </b><span>TSyntax `ident</span></span></div></blockquote></div></small></div><span class="nv">y</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">in</span></span><span class="alectryon-token"> <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>TSyntax `stmt</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token"><span class="bp">;</span> </span><span class="alectryon-token"><span class="k">let</span></span><span class="alectryon-token"> <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>y</var><b>: </b><span>TSyntax `ident</span></span></div></blockquote></div></small></div><span class="nv">y</span></span><span class="alectryon-token"> <span class="bp">←</span> get<span class="bp">;</span> </span><span class="alectryon-token">expand<span class="bp">!</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">mut</span></span><span class="alectryon-token"> <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>y</var><b>: </b><span>TSyntax `ident</span></span></div></blockquote></div></small></div><span class="nv">y</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">in</span></span><span class="alectryon-token"> <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s'</var><b>: </b><span>TSyntax `stmt</span></span></div></blockquote></div></small></div><span class="nv">s&#39;</span></span><span class="alectryon-token">)
  <span class="bp">|</span> <span class="bp">`</span>(stmt<span class="bp">|</span> </span><span class="alectryon-token">expand<span class="bp">!</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">mut</span></span><span class="alectryon-token"> <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>y</var><b>: </b><span>TSyntax `ident</span></span></div></blockquote></div></small></div><span class="nv">y</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">in</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">let</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">mut</span></span><span class="alectryon-token"> <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>TSyntax `ident</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> := <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>TSyntax `term</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token"><span class="bp">;</span> <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s'</var><b>: </b><span>TSyntax `stmt</span></span></div></blockquote></div></small></div><span class="nv">s&#39;</span></span><span class="alectryon-token">) <span class="bp">=&gt;</span>           <span class="c1">-- (S3)</span>
    </span><span class="alectryon-token"><span class="k">if</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>TSyntax `ident</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> <span class="bp">==</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>y</var><b>: </b><span>TSyntax `ident</span></span></div></blockquote></div></small></div><span class="nv">y</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">then</span></span><span class="alectryon-token">
      </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>throw</var><b>: </b><span>{ε : Type} → {m : Type → Type} → [self : MonadExcept ε m] → {α : Type} → ε → m α</span></span></div></blockquote></div></small></div><span class="k">throw</span></span><span class="alectryon-token"> <span class="bp">&lt;|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Macro.Exception.error</var><b>: </b><span>Syntax → String → Macro.Exception</span></span></div></blockquote></div></small></div><span class="k">Macro.Exception.error</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>TSyntax `ident</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> </span><span class="alectryon-token">s<span class="bp">!</span></span><span class="alectryon-token"><span class="s2">&quot;cannot shadow &#39;mut&#39; variable &#39;{</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>TSyntax `ident</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"><span class="k">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>getId</var><b>: </b><span>Ident → Name</span></span></div></blockquote></div></small></div><span class="k">getId</span></span><span class="alectryon-token">}<span class="bp">&#39;</span><span class="s2">&quot;</span>
    </span><span class="alectryon-token"><span class="k">else</span></span><span class="alectryon-token">
      <span class="bp">`</span>(stmt<span class="bp">|</span> </span><span class="alectryon-token"><span class="k">let</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">mut</span></span><span class="alectryon-token"> <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>TSyntax `ident</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> := <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>TSyntax `term</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token"><span class="bp">;</span> </span><span class="alectryon-token">expand<span class="bp">!</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">mut</span></span><span class="alectryon-token"> <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>y</var><b>: </b><span>TSyntax `ident</span></span></div></blockquote></div></small></div><span class="nv">y</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">in</span></span><span class="alectryon-token"> <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s'</var><b>: </b><span>TSyntax `stmt</span></span></div></blockquote></div></small></div><span class="nv">s&#39;</span></span><span class="alectryon-token">)
  <span class="bp">|</span> <span class="bp">`</span>(stmt<span class="bp">|</span> </span><span class="alectryon-token">expand<span class="bp">!</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">mut</span></span><span class="alectryon-token"> <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>y</var><b>: </b><span>TSyntax `ident</span></span></div></blockquote></div></small></div><span class="nv">y</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">in</span></span><span class="alectryon-token"> <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>TSyntax `ident</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token">:ident := <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>TSyntax `term</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token">) <span class="bp">=&gt;</span>
    </span><span class="alectryon-token"><span class="k">if</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>TSyntax `ident</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> <span class="bp">==</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>y</var><b>: </b><span>TSyntax `ident</span></span></div></blockquote></div></small></div><span class="nv">y</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">then</span></span><span class="alectryon-token">
      <span class="bp">`</span>(stmt<span class="bp">|</span> set <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>TSyntax `term</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token">)                                             <span class="c1">-- (S5)</span>
    </span><span class="alectryon-token"><span class="k">else</span></span><span class="alectryon-token">
      <span class="bp">`</span>(stmt<span class="bp">|</span> <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>TSyntax `ident</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token">:ident := <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>TSyntax `term</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token">)</span><span class="alectryon-token">                                     <span class="c1">-- (S4)</span>

</span><span class="alectryon-token"><span class="k">macro</span></span><span class="alectryon-token">:<span class="mi">0</span> <span class="s2">&quot;let&quot;</span> <span class="s2">&quot;mut&quot;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>TSyntax `ident</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token">:ident <span class="s2">&quot;←&quot;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>TSyntax `stmt</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token">:stmt:<span class="mi">1</span> <span class="s2">&quot;;&quot;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s'</var><b>: </b><span>TSyntax `stmt</span></span></div></blockquote></div></small></div><span class="nv">s&#39;</span></span><span class="alectryon-token">:stmt : stmt <span class="bp">=&gt;</span> <span class="bp">`</span>(</span><span class="alectryon-token"><span class="k">let</span></span><span class="alectryon-token"> y <span class="bp">←</span> <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>TSyntax `stmt</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token"><span class="bp">;</span> </span><span class="alectryon-token"><span class="k">let</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">mut</span></span><span class="alectryon-token"> <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>TSyntax `ident</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> := y<span class="bp">;</span> <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s'</var><b>: </b><span>TSyntax `stmt</span></span></div></blockquote></div></small></div><span class="nv">s&#39;</span></span><span class="alectryon-token">)</span><span class="alectryon-token"> <span class="c1">-- (A3)</span>
</span><span class="alectryon-token"><span class="k">macro</span></span><span class="alectryon-token">:<span class="mi">0</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>TSyntax `ident</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token">:ident <span class="s2">&quot;←&quot;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>TSyntax `stmt</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token">:stmt:<span class="mi">1</span> : stmt <span class="bp">=&gt;</span> <span class="bp">`</span>(</span><span class="alectryon-token"><span class="k">let</span></span><span class="alectryon-token"> y <span class="bp">←</span> <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>TSyntax `stmt</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token"><span class="bp">;</span> <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>TSyntax `ident</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token">:ident := y)</span><span class="alectryon-token">                                <span class="c1">-- (A4)</span>
<span class="c1">-- a variant of (A4) since we technically cannot make the above macro a `stmt`</span>
</span><span class="alectryon-token"><span class="k">macro</span></span><span class="alectryon-token">:<span class="mi">0</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>TSyntax `ident</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token">:ident <span class="s2">&quot;←&quot;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>TSyntax `stmt</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token">:stmt:<span class="mi">1</span> <span class="s2">&quot;;&quot;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s'</var><b>: </b><span>TSyntax `stmt</span></span></div></blockquote></div></small></div><span class="nv">s&#39;</span></span><span class="alectryon-token">:stmt : stmt <span class="bp">=&gt;</span> <span class="bp">`</span>(</span><span class="alectryon-token"><span class="k">let</span></span><span class="alectryon-token"> y <span class="bp">←</span> <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>TSyntax `stmt</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token"><span class="bp">;</span> <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>TSyntax `ident</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token">:ident := y<span class="bp">;</span> <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s'</var><b>: </b><span>TSyntax `stmt</span></span></div></blockquote></div></small></div><span class="nv">s&#39;</span></span><span class="alectryon-token">)</span><span class="alectryon-token">
</span><span class="alectryon-token"><span class="k">macro</span></span><span class="alectryon-token"> <span class="s2">&quot;if&quot;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>TSyntax `term</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token">:term <span class="s2">&quot;then&quot;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s₁</var><b>: </b><span>TSyntax `stmt</span></span></div></blockquote></div></small></div><span class="nv">s₁</span></span><span class="alectryon-token">:stmt:<span class="mi">1</span> : stmt <span class="bp">=&gt;</span> <span class="bp">`</span>(</span><span class="alectryon-token"><span class="k">if</span></span><span class="alectryon-token"> <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>TSyntax `term</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">then</span></span><span class="alectryon-token"> <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s₁</var><b>: </b><span>TSyntax `stmt</span></span></div></blockquote></div></small></div><span class="nv">s₁</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">else</span></span><span class="alectryon-token"> pure ())</span><span class="alectryon-token">                        <span class="c1">-- (A5)</span>
</span><span class="alectryon-token"><span class="k">macro</span></span><span class="alectryon-token"> <span class="s2">&quot;unless&quot;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>TSyntax `term</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token">:term <span class="s2">&quot;do&#39;&quot;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s₂</var><b>: </b><span>TSyntax `stmt</span></span></div></blockquote></div></small></div><span class="nv">s₂</span></span><span class="alectryon-token">:stmt:<span class="mi">1</span> : stmt <span class="bp">=&gt;</span> <span class="bp">`</span>(</span><span class="alectryon-token"><span class="k">if</span></span><span class="alectryon-token"> <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>TSyntax `term</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">then</span></span><span class="alectryon-token"> pure () </span><span class="alectryon-token"><span class="k">else</span></span><span class="alectryon-token"> <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s₂</var><b>: </b><span>TSyntax `stmt</span></span></div></blockquote></div></small></div><span class="nv">s₂</span></span><span class="alectryon-token">)</span><span class="alectryon-token">                     <span class="c1">-- (A6)</span>

<span class="c">/-</span><span class="cm"></span>
<span class="cm">The `variable` command instructs Lean to insert the declared variables as bound variables</span>
<span class="cm">in definitions that refer to them.</span>
<span class="cm">-/</span>

</span><span class="alectryon-token"><span class="kd">variable</span></span><span class="alectryon-token"> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Monad</var><b>: </b><span>(Type → Type u_1) → Type (max 1 u_1)</span></span></div></blockquote></div></small></div>Monad</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>Type u_1 → Type u_2</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token">]
</span><span class="alectryon-token"><span class="kd">variable</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ma</var><b>: </b><span>m α</span></span></div></blockquote></div></small></div><span class="nv">ma</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ma'</var><b>: </b><span>m α</span></span></div></blockquote></div></small></div><span class="nv">ma&#39;</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>Type u_1 → Type u_2</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type ?u.10009</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token">)

<span class="c">/-</span><span class="cm"></span>
<span class="cm">  Mark `map_eq_pure_bind` as a simplification lemma.</span>
<span class="cm">  It is a theorem for</span>
<span class="cm">  `f &lt;$&gt; x = x &gt;&gt;= pure (f a)`</span>
<span class="cm">-/</span>
</span><span class="alectryon-token"><span class="kn">attribute</span></span><span class="alectryon-token"> [</span><span class="alectryon-token"><span class="kn">local</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">simp</span></span><span class="alectryon-token">] </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>map_eq_pure_bind</var><b>: </b><span>∀ {m : Type u_1 → Type u_2} {α β : Type u_1} [inst : Monad m] [inst_1 : LawfulMonad m] (f : α → β) (x : m α),
  f &lt;$&gt; x = do
    let a ← x
    pure (f a)</span></span></div></blockquote></div></small></div>map_eq_pure_bind</span><span class="alectryon-token">

<span class="c">/-</span><span class="cm"></span>
<span class="cm">  Remark: an `example` in Lean is like a &quot;nameless&quot; definition, and it does not update the environment.</span>
<span class="cm">  It is useful for writing tests.</span>
<span class="cm">-/</span>

<span class="c">/-</span><span class="cm"></span>
<span class="cm">  The instance `[LawfulMonad m]` contains the monadic laws.</span>
<span class="cm">  For more information, see https://github.com/leanprover/lean4/blob/v4.0.0-m4/src/Init/Control/Lawful.lean</span>
<span class="cm">-/</span>

</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>example</var><b>: </b><span>∀ {m : Type u_1 → Type u_2} {α : Type u_1} [inst : Monad m] (ma : m α) [inst_1 : LawfulMonad m],
  (do
      let y ← ma
      let x : α := y
      StateT.run' (StateT.lift (pure x)) x) =
    ma</span></span></div></blockquote></div></small></div><span class="kd">example</span></span><span class="alectryon-token"> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>LawfulMonad</var><b>: </b><span>(m : Type u_1 → Type u_2) → [inst : Monad m] → Prop</span></span></div></blockquote></div></small></div>LawfulMonad</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>Type u_1 → Type u_2</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token">] :
    (</span><span class="alectryon-token"><span class="k">do</span><span class="bp">&#39;</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">let</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">mut</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> <span class="bp">←</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ma</var><b>: </b><span>m α</span></span></div></blockquote></div></small></div><span class="nv">ma</span></span><span class="alectryon-token"><span class="bp">;</span>
         </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>pure</var><b>: </b><span>{f : Type u_1 → Type u_2} → [self : Pure f] → {α : Type u_1} → α → f α</span></span></div></blockquote></div></small></div>pure</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>Type u_1 → Type u_2</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type u_1</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token">)
    <span class="bp">=</span>
    </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ma</var><b>: </b><span>m α</span></span></div></blockquote></div></small></div><span class="nv">ma</span></span><span class="alectryon-token">
:= </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Mut-lean-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="Mut-lean-chk0"><span class="alectryon-token"><span class="kd">by</span></span><span class="alectryon-token"></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">?</span>u.10102 <span class="bp">→</span> <span class="kt">Type</span> <span class="bp">?</span>u.10058</span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">?</span>u.10102</span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>ma, ma'</var><span class="hyp-type"><b>: </b><span>m α</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="k">do</span>
    <span class="k">let</span> y <span class="bp">←</span> ma
    <span class="k">let</span> x : α := y
    StateT.run&#39; (StateT.lift (pure x)) x) <span class="bp">=</span>
  ma</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Mut-lean-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="Mut-lean-chk1"><span class="alectryon-token"><span class="k">simp</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">

</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>example</var><b>: </b><span>∀ {m : Type u_1 → Type u_2} {α : Type u_1} [inst : Monad m] (ma ma' : m α) [inst_1 : LawfulMonad m],
  (do
      let y ← ma
      let x : α := y
      StateT.run'
          (do
            let y ← StateT.lift ma'
            let _ ← get
            set y
            let x ← get
            StateT.lift (pure x))
          x) =
    do
    let _ ← ma
    ma'</span></span></div></blockquote></div></small></div><span class="kd">example</span></span><span class="alectryon-token"> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>LawfulMonad</var><b>: </b><span>(m : Type u_1 → Type u_2) → [inst : Monad m] → Prop</span></span></div></blockquote></div></small></div>LawfulMonad</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>Type u_1 → Type u_2</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token">] :
    (</span><span class="alectryon-token"><span class="k">do</span><span class="bp">&#39;</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">let</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">mut</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> <span class="bp">←</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ma</var><b>: </b><span>m α</span></span></div></blockquote></div></small></div><span class="nv">ma</span></span><span class="alectryon-token"><span class="bp">;</span>
         x <span class="bp">←</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ma'</var><b>: </b><span>m α</span></span></div></blockquote></div></small></div><span class="nv">ma&#39;</span></span><span class="alectryon-token"><span class="bp">;</span>
         </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>pure</var><b>: </b><span>{f : Type u_1 → Type u_2} → [self : Pure f] → {α : Type u_1} → α → f α</span></span></div></blockquote></div></small></div>pure</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token">)
    <span class="bp">=</span>
    (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ma</var><b>: </b><span>m α</span></span></div></blockquote></div></small></div><span class="nv">ma</span></span><span class="alectryon-token"> <span class="bp">&gt;&gt;=</span> </span><span class="alectryon-token"><span class="k">fun</span></span><span class="alectryon-token"> _ <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ma'</var><b>: </b><span>m α</span></span></div></blockquote></div></small></div><span class="nv">ma&#39;</span></span><span class="alectryon-token">)
:= </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Mut-lean-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="Mut-lean-chk2"><span class="alectryon-token"><span class="kd">by</span></span><span class="alectryon-token"></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">?</span>u.10970 <span class="bp">→</span> <span class="kt">Type</span> <span class="bp">?</span>u.10750</span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">?</span>u.10970</span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>ma, ma'</var><span class="hyp-type"><b>: </b><span>m α</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="k">do</span>
    <span class="k">let</span> y <span class="bp">←</span> ma
    <span class="k">let</span> x : α := y
    StateT.run&#39;
        (<span class="k">do</span>
          <span class="k">let</span> y <span class="bp">←</span> StateT.lift ma&#39;
          <span class="k">let</span> _ <span class="bp">←</span> get
          set y
          <span class="k">let</span> x <span class="bp">←</span> get
          StateT.lift (pure x))
        x) <span class="bp">=</span>
  <span class="k">do</span>
  <span class="k">let</span> _ <span class="bp">←</span> ma
  ma&#39;</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Mut-lean-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="Mut-lean-chk3"><span class="alectryon-token"><span class="k">simp</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">

<span class="c">/-</span><span class="cm"> The command `#check_failure &lt;term&gt;` succeeds only if `&lt;term&gt;` fails to be elaborated. -/</span>

</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Mut-lean-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="Mut-lean-chk4"><span class="alectryon-token"><span class="bp">#</span>check_failure</span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">do</span><span class="bp">&#39;</span></span><span class="alectryon-token">
  </span><span class="alectryon-token"><span class="k">let</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">mut</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> <span class="bp">←</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ma</var><b>: </b><span>m α</span></span></div></blockquote></div></small></div><span class="nv">ma</span></span><span class="alectryon-token"><span class="bp">;</span>
  </span><span class="alectryon-token"><span class="k">let</span></span><span class="alectryon-token"></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="k">do</span>
  <span class="k">let</span> y <span class="bp">←</span> ma
  <span class="k">let</span> x : α := y
  sorryAx (m <span class="bp">?</span>m.13198) true : m <span class="bp">?</span>m.13198</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Mut-lean-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="Mut-lean-chk5"><span class="alectryon-token">x</span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="k">do</span>
  <span class="k">let</span> y <span class="bp">←</span> ma
  <span class="k">let</span> x : α := y
  sorryAx (m <span class="bp">?</span>m.13198) true : m <span class="bp">?</span>m.13198</blockquote><blockquote class="alectryon-message">Warning: cannot shadow <span class="bp">&#39;</span>mut&#39; <span class="kd">variable</span> <span class="sc">&#39;x&#39;</span></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Mut-lean-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="Mut-lean-chk6"><span class="alectryon-token"><span class="bp">←</span> ma&#39;<span class="bp">;</span>  <span class="c1">-- cannot shadow &#39;mut&#39; variable &#39;x&#39;</span>
  pure x</span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="k">do</span>
  <span class="k">let</span> y <span class="bp">←</span> ma
  <span class="k">let</span> x : α := y
  sorryAx (m <span class="bp">?</span>m.13198) true : m <span class="bp">?</span>m.13198</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">

</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Mut-lean-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="Mut-lean-chk7"><span class="alectryon-token"><span class="bp">#</span>check_failure</span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">do</span><span class="bp">&#39;</span></span><span class="alectryon-token"></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="k">do</span>
  <span class="k">let</span> _ <span class="bp">←</span> ma
  sorryAx (m <span class="bp">?</span>m.13260) true : m <span class="bp">?</span>m.13260</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Mut-lean-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="Mut-lean-chk8"><span class="alectryon-token">x</span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="k">do</span>
  <span class="k">let</span> _ <span class="bp">←</span> ma
  sorryAx (m <span class="bp">?</span>m.13260) true : m <span class="bp">?</span>m.13260</blockquote><blockquote class="alectryon-message">Warning: <span class="kd">variable</span> <span class="sc">&#39;x&#39;</span> is not reassignable <span class="k">in</span> this scope</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Mut-lean-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="Mut-lean-chk9"><span class="alectryon-token"><span class="bp">←</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ma</var><b>: </b><span>m α</span></span></div></blockquote></div></small></div><span class="nv">ma</span></span><span class="alectryon-token"><span class="bp">;</span>  <span class="c1">-- variable &#39;x&#39; is not reassignable in this scope</span>
  pure ()</span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="k">do</span>
  <span class="k">let</span> _ <span class="bp">←</span> ma
  sorryAx (m <span class="bp">?</span>m.13260) true : m <span class="bp">?</span>m.13260</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">

</span><span class="alectryon-token"><span class="kd">variable</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Bool</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Bool</span><span class="alectryon-token">)

<span class="c1">-- The following equivalence is true even if `m` does not satisfy the monadic laws.</span>
</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>example</var><b>: </b><span>∀ {m : Type → Type u_1} {α : Type} [inst : Monad m] (ma : m α) (b : Bool),
  (if b = true then discard ma else pure ()) = if b = true then discard ma else pure ()</span></span></div></blockquote></div></small></div><span class="kd">example</span></span><span class="alectryon-token"> :
    (</span><span class="alectryon-token"><span class="k">do</span><span class="bp">&#39;</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">if</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">then</span></span><span class="alectryon-token"> {
           </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>discard</var><b>: </b><span>{f : Type → Type u_1} → {α : Type} → [inst : Functor f] → f α → f PUnit</span></span></div></blockquote></div></small></div>discard</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ma</var><b>: </b><span>m α</span></span></div></blockquote></div></small></div><span class="nv">ma</span></span><span class="alectryon-token">
         })
    <span class="bp">=</span>
    (</span><span class="alectryon-token"><span class="k">if</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">then</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>discard</var><b>: </b><span>{f : Type → Type u_1} → {α : Type} → [inst : Functor f] → f α → f PUnit</span></span></div></blockquote></div></small></div>discard</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ma</var><b>: </b><span>m α</span></span></div></blockquote></div></small></div><span class="nv">ma</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">else</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>pure</var><b>: </b><span>{f : Type → Type u_1} → [self : Pure f] → {α : Type} → α → f α</span></span></div></blockquote></div></small></div>pure</span><span class="alectryon-token"> ())
:= </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>rfl</var><b>: </b><span>∀ {α : Type u_1} {a : α}, a = a</span></span></div></blockquote></div></small></div>rfl</span><span class="alectryon-token">

</span><span class="alectryon-token"><span class="kd">theorem</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>simple</var><b>: </b><span>∀ [inst : LawfulMonad m],
  (do
      let y ← ma
      let x : α := y
      StateT.run'
          (do
            if b = true then do
                let y ← StateT.lift ma'
                let _ ← get
                set y
              else StateT.lift (pure ())
            let x ← get
            StateT.lift (pure x))
          x) =
    do
    let x ← ma
    if b = true then ma' else pure x</span></span></div></blockquote></div></small></div><span class="nv">simple</span></span><span class="alectryon-token"> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>LawfulMonad</var><b>: </b><span>(m : Type → Type u_1) → [inst : Monad m] → Prop</span></span></div></blockquote></div></small></div>LawfulMonad</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>Type → Type u_1</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token">] :
    (</span><span class="alectryon-token"><span class="k">do</span><span class="bp">&#39;</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">let</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">mut</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> <span class="bp">←</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ma</var><b>: </b><span>m α</span></span></div></blockquote></div></small></div><span class="nv">ma</span></span><span class="alectryon-token"><span class="bp">;</span>
         </span><span class="alectryon-token"><span class="k">if</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">then</span></span><span class="alectryon-token"> {
           x <span class="bp">←</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ma'</var><b>: </b><span>m α</span></span></div></blockquote></div></small></div><span class="nv">ma&#39;</span></span><span class="alectryon-token">
         }<span class="bp">;</span>
         </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>pure</var><b>: </b><span>{f : Type → Type u_1} → [self : Pure f] → {α : Type} → α → f α</span></span></div></blockquote></div></small></div>pure</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token">)
    <span class="bp">=</span>
    </span><span class="alectryon-token">(</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ma</var><b>: </b><span>m α</span></span></div></blockquote></div></small></div><span class="nv">ma</span></span><span class="alectryon-token"> <span class="bp">&gt;&gt;=</span> </span><span class="alectryon-token"><span class="k">fun</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><span class="k">if</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">then</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ma'</var><b>: </b><span>m α</span></span></div></blockquote></div></small></div><span class="nv">ma&#39;</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">else</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>pure</var><b>: </b><span>{f : Type → Type u_1} → [self : Pure f] → {α : Type} → α → f α</span></span></div></blockquote></div></small></div><span class="k">pure</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token">)</span><span class="alectryon-token">
:= </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Mut-lean-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="Mut-lean-chka"><span class="alectryon-token"><span class="kd">by</span></span><span class="alectryon-token"></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>ma, ma'</var><span class="hyp-type"><b>: </b><span>m α</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="k">do</span>
    <span class="k">let</span> y <span class="bp">←</span> ma
    <span class="k">let</span> x : α := y
    StateT.run&#39;
        (<span class="k">do</span>
          <span class="k">if</span> b <span class="bp">=</span> true <span class="k">then</span> <span class="k">do</span>
              <span class="k">let</span> y <span class="bp">←</span> StateT.lift ma&#39;
              <span class="k">let</span> _ <span class="bp">←</span> get
              set y
            <span class="k">else</span> StateT.lift (pure ())
          <span class="k">let</span> x <span class="bp">←</span> get
          StateT.lift (pure x))
        x) <span class="bp">=</span>
  <span class="k">do</span>
  <span class="k">let</span> x <span class="bp">←</span> ma
  <span class="k">if</span> b <span class="bp">=</span> true <span class="k">then</span> ma&#39; <span class="k">else</span> pure x</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Mut-lean-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="Mut-lean-chkb"><span class="alectryon-token"><span class="k">cases</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div><span class="nv">b</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>ma, ma'</var><span class="hyp-type"><b>: </b><span>m α</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">false</span></span><div class="goal-conclusion">(<span class="k">do</span>
    <span class="k">let</span> y <span class="bp">←</span> ma
    <span class="k">let</span> x : α := y
    StateT.run&#39;
        (<span class="k">do</span>
          <span class="k">if</span> false <span class="bp">=</span> true <span class="k">then</span> <span class="k">do</span>
              <span class="k">let</span> y <span class="bp">←</span> StateT.lift ma&#39;
              <span class="k">let</span> _ <span class="bp">←</span> get
              set y
            <span class="k">else</span> StateT.lift (pure ())
          <span class="k">let</span> x <span class="bp">←</span> get
          StateT.lift (pure x))
        x) <span class="bp">=</span>
  <span class="k">do</span>
  <span class="k">let</span> x <span class="bp">←</span> ma
  <span class="k">if</span> false <span class="bp">=</span> true <span class="k">then</span> ma&#39; <span class="k">else</span> pure x</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Mut-lean-chkc" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>ma, ma'</var><span class="hyp-type"><b>: </b><span>m α</span></span></span><br></div><label class="goal-separator" for="Mut-lean-chkc"><hr><span class="goal-name">true</span></label><div class="goal-conclusion">(<span class="k">do</span>
    <span class="k">let</span> y <span class="bp">←</span> ma
    <span class="k">let</span> x : α := y
    StateT.run&#39;
        (<span class="k">do</span>
          <span class="k">if</span> true <span class="bp">=</span> true <span class="k">then</span> <span class="k">do</span>
              <span class="k">let</span> y <span class="bp">←</span> StateT.lift ma&#39;
              <span class="k">let</span> _ <span class="bp">←</span> get
              set y
            <span class="k">else</span> StateT.lift (pure ())
          <span class="k">let</span> x <span class="bp">←</span> get
          StateT.lift (pure x))
        x) <span class="bp">=</span>
  <span class="k">do</span>
  <span class="k">let</span> x <span class="bp">←</span> ma
  <span class="k">if</span> true <span class="bp">=</span> true <span class="k">then</span> ma&#39; <span class="k">else</span> pure x</div></blockquote></div></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Mut-lean-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="Mut-lean-chkd"><span class="alectryon-token"><span class="k">&lt;;&gt;</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>ma, ma'</var><span class="hyp-type"><b>: </b><span>m α</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">false</span></span><div class="goal-conclusion">(<span class="k">do</span>
    <span class="k">let</span> y <span class="bp">←</span> ma
    <span class="k">let</span> x : α := y
    StateT.run&#39;
        (<span class="k">do</span>
          <span class="k">if</span> false <span class="bp">=</span> true <span class="k">then</span> <span class="k">do</span>
              <span class="k">let</span> y <span class="bp">←</span> StateT.lift ma&#39;
              <span class="k">let</span> _ <span class="bp">←</span> get
              set y
            <span class="k">else</span> StateT.lift (pure ())
          <span class="k">let</span> x <span class="bp">←</span> get
          StateT.lift (pure x))
        x) <span class="bp">=</span>
  <span class="k">do</span>
  <span class="k">let</span> x <span class="bp">←</span> ma
  <span class="k">if</span> false <span class="bp">=</span> true <span class="k">then</span> ma&#39; <span class="k">else</span> pure x</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Mut-lean-chke" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>ma, ma'</var><span class="hyp-type"><b>: </b><span>m α</span></span></span><br></div><label class="goal-separator" for="Mut-lean-chke"><hr><span class="goal-name">true</span></label><div class="goal-conclusion">(<span class="k">do</span>
    <span class="k">let</span> y <span class="bp">←</span> ma
    <span class="k">let</span> x : α := y
    StateT.run&#39;
        (<span class="k">do</span>
          <span class="k">if</span> true <span class="bp">=</span> true <span class="k">then</span> <span class="k">do</span>
              <span class="k">let</span> y <span class="bp">←</span> StateT.lift ma&#39;
              <span class="k">let</span> _ <span class="bp">←</span> get
              set y
            <span class="k">else</span> StateT.lift (pure ())
          <span class="k">let</span> x <span class="bp">←</span> get
          StateT.lift (pure x))
        x) <span class="bp">=</span>
  <span class="k">do</span>
  <span class="k">let</span> x <span class="bp">←</span> ma
  <span class="k">if</span> true <span class="bp">=</span> true <span class="k">then</span> ma&#39; <span class="k">else</span> pure x</div></blockquote></div></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Mut-lean-chkf" style="display: none" type="checkbox"><label class="alectryon-input" for="Mut-lean-chkf"><span class="alectryon-token"><span class="k">simp</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">

</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>example</var><b>: </b><span>∀ {m : Type u_1 → Type u_2} {α : Type u_1} [inst : Monad m] (ma ma' : m α) (b : Bool) [inst_1 : LawfulMonad m]
  (f : α → α → α),
  (do
      let y ← ma
      let x : α := y
      StateT.run'
          (do
            let y ←
              if b = true then do
                  let y ← StateT.lift ma
                  let _ ← get
                  set y
                  let _ ← get
                  StateT.lift ma'
                else StateT.lift ma'
            let x ← get
            StateT.lift (pure (f x y)))
          x) =
    do
    let x ← ma
    if b = true then do
        let x ← ma
        let y ← ma'
        pure (f x y)
      else do
        let y ← ma'
        pure (f x y)</span></span></div></blockquote></div></small></div><span class="kd">example</span></span><span class="alectryon-token"> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>LawfulMonad</var><b>: </b><span>(m : Type u_1 → Type u_2) → [inst : Monad m] → Prop</span></span></div></blockquote></div></small></div>LawfulMonad</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>Type u_1 → Type u_2</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token">] (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>α → α → α</span></span></div></blockquote></div></small></div><span class="nv">f</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type u_1</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type u_1</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type u_1</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token">) :
    (</span><span class="alectryon-token"><span class="k">do</span><span class="bp">&#39;</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">let</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">mut</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> <span class="bp">←</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ma</var><b>: </b><span>m α</span></span></div></blockquote></div></small></div><span class="nv">ma</span></span><span class="alectryon-token"><span class="bp">;</span>
         </span><span class="alectryon-token"><span class="k">let</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>y</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">y</span></span><span class="alectryon-token"> <span class="bp">←</span>
           </span><span class="alectryon-token"><span class="k">if</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">then</span></span><span class="alectryon-token"> {
             x <span class="bp">←</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ma</var><b>: </b><span>m α</span></span></div></blockquote></div></small></div><span class="nv">ma</span></span><span class="alectryon-token"><span class="bp">;</span>
             </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ma'</var><b>: </b><span>m α</span></span></div></blockquote></div></small></div><span class="nv">ma&#39;</span></span><span class="alectryon-token">
           } </span><span class="alectryon-token"><span class="k">else</span></span><span class="alectryon-token"> {
             </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ma'</var><b>: </b><span>m α</span></span></div></blockquote></div></small></div><span class="nv">ma&#39;</span></span><span class="alectryon-token">
           }<span class="bp">;</span>
         </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>pure</var><b>: </b><span>{f : Type u_1 → Type u_2} → [self : Pure f] → {α : Type u_1} → α → f α</span></span></div></blockquote></div></small></div>pure</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>α → α → α</span></span></div></blockquote></div></small></div><span class="nv">f</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>y</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">y</span></span><span class="alectryon-token">))
    <span class="bp">=</span>
    </span><span class="alectryon-token">(</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ma</var><b>: </b><span>m α</span></span></div></blockquote></div></small></div><span class="nv">ma</span></span><span class="alectryon-token"> <span class="bp">&gt;&gt;=</span> </span><span class="alectryon-token"><span class="k">fun</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><span class="k">if</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">then</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ma</var><b>: </b><span>m α</span></span></div></blockquote></div></small></div><span class="nv">ma</span></span><span class="alectryon-token"> <span class="bp">&gt;&gt;=</span> </span><span class="alectryon-token"><span class="k">fun</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ma'</var><b>: </b><span>m α</span></span></div></blockquote></div></small></div><span class="nv">ma&#39;</span></span><span class="alectryon-token"> <span class="bp">&gt;&gt;=</span> </span><span class="alectryon-token"><span class="k">fun</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>y</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">y</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>pure</var><b>: </b><span>{f : Type u_1 → Type u_2} → [self : Pure f] → {α : Type u_1} → α → f α</span></span></div></blockquote></div></small></div><span class="k">pure</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>α → α → α</span></span></div></blockquote></div></small></div><span class="nv">f</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>y</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">y</span></span><span class="alectryon-token">) </span><span class="alectryon-token"><span class="k">else</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ma'</var><b>: </b><span>m α</span></span></div></blockquote></div></small></div><span class="nv">ma&#39;</span></span><span class="alectryon-token"> <span class="bp">&gt;&gt;=</span> </span><span class="alectryon-token"><span class="k">fun</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>y</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">y</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>pure</var><b>: </b><span>{f : Type u_1 → Type u_2} → [self : Pure f] → {α : Type u_1} → α → f α</span></span></div></blockquote></div></small></div><span class="k">pure</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>α → α → α</span></span></div></blockquote></div></small></div><span class="nv">f</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>y</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">y</span></span><span class="alectryon-token">))</span><span class="alectryon-token">
:= </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Mut-lean-chk10" style="display: none" type="checkbox"><label class="alectryon-input" for="Mut-lean-chk10"><span class="alectryon-token"><span class="kd">by</span></span><span class="alectryon-token"></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">?</span>u.17614 <span class="bp">→</span> <span class="kt">Type</span> <span class="bp">?</span>u.17083</span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">?</span>u.17614</span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>ma, ma'</var><span class="hyp-type"><b>: </b><span>m α</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> α <span class="bp">→</span> α</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="k">do</span>
    <span class="k">let</span> y <span class="bp">←</span> ma
    <span class="k">let</span> x : α := y
    StateT.run&#39;
        (<span class="k">do</span>
          <span class="k">let</span> y <span class="bp">←</span>
            <span class="k">if</span> b <span class="bp">=</span> true <span class="k">then</span> <span class="k">do</span>
                <span class="k">let</span> y <span class="bp">←</span> StateT.lift ma
                <span class="k">let</span> _ <span class="bp">←</span> get
                set y
                <span class="k">let</span> _ <span class="bp">←</span> get
                StateT.lift ma&#39;
              <span class="k">else</span> StateT.lift ma&#39;
          <span class="k">let</span> x <span class="bp">←</span> get
          StateT.lift (pure (f x y)))
        x) <span class="bp">=</span>
  <span class="k">do</span>
  <span class="k">let</span> x <span class="bp">←</span> ma
  <span class="k">if</span> b <span class="bp">=</span> true <span class="k">then</span> <span class="k">do</span>
      <span class="k">let</span> x <span class="bp">←</span> ma
      <span class="k">let</span> y <span class="bp">←</span> ma&#39;
      pure (f x y)
    <span class="k">else</span> <span class="k">do</span>
      <span class="k">let</span> y <span class="bp">←</span> ma&#39;
      pure (f x y)</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Mut-lean-chk11" style="display: none" type="checkbox"><label class="alectryon-input" for="Mut-lean-chk11"><span class="alectryon-token"><span class="k">cases</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div><span class="nv">b</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">?</span>u.17614 <span class="bp">→</span> <span class="kt">Type</span> <span class="bp">?</span>u.17083</span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">?</span>u.17614</span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>ma, ma'</var><span class="hyp-type"><b>: </b><span>m α</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> α <span class="bp">→</span> α</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">false</span></span><div class="goal-conclusion">(<span class="k">do</span>
    <span class="k">let</span> y <span class="bp">←</span> ma
    <span class="k">let</span> x : α := y
    StateT.run&#39;
        (<span class="k">do</span>
          <span class="k">let</span> y <span class="bp">←</span>
            <span class="k">if</span> false <span class="bp">=</span> true <span class="k">then</span> <span class="k">do</span>
                <span class="k">let</span> y <span class="bp">←</span> StateT.lift ma
                <span class="k">let</span> _ <span class="bp">←</span> get
                set y
                <span class="k">let</span> _ <span class="bp">←</span> get
                StateT.lift ma&#39;
              <span class="k">else</span> StateT.lift ma&#39;
          <span class="k">let</span> x <span class="bp">←</span> get
          StateT.lift (pure (f x y)))
        x) <span class="bp">=</span>
  <span class="k">do</span>
  <span class="k">let</span> x <span class="bp">←</span> ma
  <span class="k">if</span> false <span class="bp">=</span> true <span class="k">then</span> <span class="k">do</span>
      <span class="k">let</span> x <span class="bp">←</span> ma
      <span class="k">let</span> y <span class="bp">←</span> ma&#39;
      pure (f x y)
    <span class="k">else</span> <span class="k">do</span>
      <span class="k">let</span> y <span class="bp">←</span> ma&#39;
      pure (f x y)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Mut-lean-chk12" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">?</span>u.17614 <span class="bp">→</span> <span class="kt">Type</span> <span class="bp">?</span>u.17083</span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">?</span>u.17614</span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>ma, ma'</var><span class="hyp-type"><b>: </b><span>m α</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> α <span class="bp">→</span> α</span></span></span><br></div><label class="goal-separator" for="Mut-lean-chk12"><hr><span class="goal-name">true</span></label><div class="goal-conclusion">(<span class="k">do</span>
    <span class="k">let</span> y <span class="bp">←</span> ma
    <span class="k">let</span> x : α := y
    StateT.run&#39;
        (<span class="k">do</span>
          <span class="k">let</span> y <span class="bp">←</span>
            <span class="k">if</span> true <span class="bp">=</span> true <span class="k">then</span> <span class="k">do</span>
                <span class="k">let</span> y <span class="bp">←</span> StateT.lift ma
                <span class="k">let</span> _ <span class="bp">←</span> get
                set y
                <span class="k">let</span> _ <span class="bp">←</span> get
                StateT.lift ma&#39;
              <span class="k">else</span> StateT.lift ma&#39;
          <span class="k">let</span> x <span class="bp">←</span> get
          StateT.lift (pure (f x y)))
        x) <span class="bp">=</span>
  <span class="k">do</span>
  <span class="k">let</span> x <span class="bp">←</span> ma
  <span class="k">if</span> true <span class="bp">=</span> true <span class="k">then</span> <span class="k">do</span>
      <span class="k">let</span> x <span class="bp">←</span> ma
      <span class="k">let</span> y <span class="bp">←</span> ma&#39;
      pure (f x y)
    <span class="k">else</span> <span class="k">do</span>
      <span class="k">let</span> y <span class="bp">←</span> ma&#39;
      pure (f x y)</div></blockquote></div></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Mut-lean-chk13" style="display: none" type="checkbox"><label class="alectryon-input" for="Mut-lean-chk13"><span class="alectryon-token"><span class="k">&lt;;&gt;</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">?</span>u.17614 <span class="bp">→</span> <span class="kt">Type</span> <span class="bp">?</span>u.17083</span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">?</span>u.17614</span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>ma, ma'</var><span class="hyp-type"><b>: </b><span>m α</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> α <span class="bp">→</span> α</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">false</span></span><div class="goal-conclusion">(<span class="k">do</span>
    <span class="k">let</span> y <span class="bp">←</span> ma
    <span class="k">let</span> x : α := y
    StateT.run&#39;
        (<span class="k">do</span>
          <span class="k">let</span> y <span class="bp">←</span>
            <span class="k">if</span> false <span class="bp">=</span> true <span class="k">then</span> <span class="k">do</span>
                <span class="k">let</span> y <span class="bp">←</span> StateT.lift ma
                <span class="k">let</span> _ <span class="bp">←</span> get
                set y
                <span class="k">let</span> _ <span class="bp">←</span> get
                StateT.lift ma&#39;
              <span class="k">else</span> StateT.lift ma&#39;
          <span class="k">let</span> x <span class="bp">←</span> get
          StateT.lift (pure (f x y)))
        x) <span class="bp">=</span>
  <span class="k">do</span>
  <span class="k">let</span> x <span class="bp">←</span> ma
  <span class="k">if</span> false <span class="bp">=</span> true <span class="k">then</span> <span class="k">do</span>
      <span class="k">let</span> x <span class="bp">←</span> ma
      <span class="k">let</span> y <span class="bp">←</span> ma&#39;
      pure (f x y)
    <span class="k">else</span> <span class="k">do</span>
      <span class="k">let</span> y <span class="bp">←</span> ma&#39;
      pure (f x y)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Mut-lean-chk14" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">?</span>u.17614 <span class="bp">→</span> <span class="kt">Type</span> <span class="bp">?</span>u.17083</span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">?</span>u.17614</span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>ma, ma'</var><span class="hyp-type"><b>: </b><span>m α</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> α <span class="bp">→</span> α</span></span></span><br></div><label class="goal-separator" for="Mut-lean-chk14"><hr><span class="goal-name">true</span></label><div class="goal-conclusion">(<span class="k">do</span>
    <span class="k">let</span> y <span class="bp">←</span> ma
    <span class="k">let</span> x : α := y
    StateT.run&#39;
        (<span class="k">do</span>
          <span class="k">let</span> y <span class="bp">←</span>
            <span class="k">if</span> true <span class="bp">=</span> true <span class="k">then</span> <span class="k">do</span>
                <span class="k">let</span> y <span class="bp">←</span> StateT.lift ma
                <span class="k">let</span> _ <span class="bp">←</span> get
                set y
                <span class="k">let</span> _ <span class="bp">←</span> get
                StateT.lift ma&#39;
              <span class="k">else</span> StateT.lift ma&#39;
          <span class="k">let</span> x <span class="bp">←</span> get
          StateT.lift (pure (f x y)))
        x) <span class="bp">=</span>
  <span class="k">do</span>
  <span class="k">let</span> x <span class="bp">←</span> ma
  <span class="k">if</span> true <span class="bp">=</span> true <span class="k">then</span> <span class="k">do</span>
      <span class="k">let</span> x <span class="bp">←</span> ma
      <span class="k">let</span> y <span class="bp">←</span> ma&#39;
      pure (f x y)
    <span class="k">else</span> <span class="k">do</span>
      <span class="k">let</span> y <span class="bp">←</span> ma&#39;
      pure (f x y)</div></blockquote></div></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Mut-lean-chk15" style="display: none" type="checkbox"><label class="alectryon-input" for="Mut-lean-chk15"><span class="alectryon-token"><span class="k">simp</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">

<span class="c">/-</span><span class="cm"></span>
<span class="cm">Nondeterminism example from Section 2.</span>
<span class="cm">-/</span>
</span><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>choose</var><b>: </b><span>{α : Type u_1} → List α → LazyList α</span></span></div></blockquote></div></small></div><span class="nv">choose</span></span><span class="alectryon-token"> := <span class="bp">@</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>List.toLazy</var><b>: </b><span>{α : Type u_1} → List α → LazyList α</span></span></div></blockquote></div></small></div>List.toLazy</span><span class="alectryon-token">

</span><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ex</var><b>: </b><span>LazyList Nat</span></span></div></blockquote></div></small></div><span class="nv">ex</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>LazyList</var><b>: </b><span>Type → Type</span></span></div></blockquote></div></small></div>LazyList</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Nat</span><span class="alectryon-token"> := </span><span class="alectryon-token"><span class="k">do</span><span class="bp">&#39;</span></span><span class="alectryon-token">
  </span><span class="alectryon-token"><span class="k">let</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">mut</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>0</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">0</span></span><span class="alectryon-token"><span class="bp">;</span>
  </span><span class="alectryon-token"><span class="k">let</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>y</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">y</span></span><span class="alectryon-token"> <span class="bp">←</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>choose</var><b>: </b><span>{α : Type} → List α → LazyList α</span></span></div></blockquote></div></small></div><span class="k">choose</span></span><span class="alectryon-token"> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>0</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">0</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>1</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">1</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>2</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">2</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>3</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">3</span></span><span class="alectryon-token">]<span class="bp">;</span>
  x := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> <span class="bp">+</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>1</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">1</span></span><span class="alectryon-token"><span class="bp">;</span>
  </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>guard</var><b>: </b><span>{f : Type → Type} → [inst : Alternative f] → (p : Prop) → [inst : Decidable p] → f Unit</span></span></div></blockquote></div></small></div><span class="k">guard</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> <span class="bp">&lt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>3</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">3</span></span><span class="alectryon-token">)<span class="bp">;</span>
  </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>pure</var><b>: </b><span>{f : Type → Type} → [self : Pure f] → {α : Type} → α → f α</span></span></div></blockquote></div></small></div><span class="k">pure</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> <span class="bp">+</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>y</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">y</span></span><span class="alectryon-token">)</span><span class="alectryon-token">

<span class="c1">-- Generate all solutions</span>
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Mut-lean-chk16" style="display: none" type="checkbox"><label class="alectryon-input" for="Mut-lean-chk16"><span class="alectryon-token"><span class="k">#eval</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">[<span class="mi">1</span>, <span class="mi">2</span>, <span class="mi">3</span>, <span class="mi">4</span>]
</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ex</var><b>: </b><span>LazyList Nat</span></span></div></blockquote></div></small></div>ex</span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>toList</var><b>: </b><span>{α : Type} → LazyList α → List α</span></span></div></blockquote></div></small></div>toList</span><span class="alectryon-token"></span></span></pre><div style="break-before: page; page-break-before: always;"></div><h1 id="lazylist-nondeterminism-monad"><a class="header" href="#lazylist-nondeterminism-monad"><code>LazyList</code> Nondeterminism Monad</a></h1>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">inductive</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>LazyList</var><b>: </b><span>Type u → Type u</span></span></div></blockquote></div></small></div><span class="nv">LazyList</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type u</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Type u</var><b>: </b><span>Type (u + 1)</span></span></div></blockquote></div></small></div><span class="kt">Type</span> u</span><span class="alectryon-token">) </span><span class="alectryon-token"><span class="k">where</span></span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>nil</var><b>: </b><span>{α : Type u} → LazyList α</span></span></div></blockquote></div></small></div>nil</span><span class="alectryon-token">                               : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>LazyList</var><b>: </b><span>Type u → Type u</span></span></div></blockquote></div></small></div><span class="nv">LazyList</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type u</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>cons</var><b>: </b><span>{α : Type u} → α → LazyList α → LazyList α</span></span></div></blockquote></div></small></div>cons</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>hd</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">hd</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type u</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token">) (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>tl</var><b>: </b><span>LazyList α</span></span></div></blockquote></div></small></div><span class="nv">tl</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>LazyList</var><b>: </b><span>Type u → Type u</span></span></div></blockquote></div></small></div><span class="nv">LazyList</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type u</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token">)   : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>LazyList</var><b>: </b><span>Type u → Type u</span></span></div></blockquote></div></small></div><span class="nv">LazyList</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type u</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>delayed</var><b>: </b><span>{α : Type u} → Thunk (LazyList α) → LazyList α</span></span></div></blockquote></div></small></div>delayed</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>t</var><b>: </b><span>Thunk (LazyList α)</span></span></div></blockquote></div></small></div><span class="nv">t</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Thunk</var><b>: </b><span>Type u → Type u</span></span></div></blockquote></div></small></div>Thunk</span><span class="alectryon-token"> <span class="bp">$</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>LazyList</var><b>: </b><span>Type u → Type u</span></span></div></blockquote></div></small></div><span class="nv">LazyList</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type u</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token">)  : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>LazyList</var><b>: </b><span>Type u → Type u</span></span></div></blockquote></div></small></div><span class="nv">LazyList</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type u</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token">

</span><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>List.toLazy</var><b>: </b><span>{α : Type u} → List α → LazyList α</span></span></div></blockquote></div></small></div><span class="nv">List.toLazy</span></span><span class="alectryon-token"> {</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type u</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Type u</var><b>: </b><span>Type (u + 1)</span></span></div></blockquote></div></small></div><span class="kt">Type</span> u</span><span class="alectryon-token">} : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>List</var><b>: </b><span>Type u → Type u</span></span></div></blockquote></div></small></div>List</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type u</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>LazyList</var><b>: </b><span>Type u → Type u</span></span></div></blockquote></div></small></div>LazyList</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type u</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token">
  <span class="bp">|</span> []     <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>LazyList.nil</var><b>: </b><span>{α : Type u} → LazyList α</span></span></div></blockquote></div></small></div>LazyList.nil</span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>h</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">h</span></span><span class="alectryon-token">::</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>t</var><b>: </b><span>List α</span></span></div></blockquote></div></small></div><span class="nv">t</span></span><span class="alectryon-token">   <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>LazyList.cons</var><b>: </b><span>{α : Type u} → α → LazyList α → LazyList α</span></span></div></blockquote></div></small></div>LazyList.cons</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>h</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">h</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>toLazy</var><b>: </b><span>{α : Type u} → List α → LazyList α</span></span></div></blockquote></div></small></div><span class="nv">toLazy</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>t</var><b>: </b><span>List α</span></span></div></blockquote></div></small></div><span class="nv">t</span></span><span class="alectryon-token">)

</span><span class="alectryon-token"><span class="kn">namespace</span></span><span class="alectryon-token"> LazyList
</span><span class="alectryon-token"><span class="kd">variable</span></span><span class="alectryon-token"> {</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type u</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Type u</var><b>: </b><span>Type (u + 1)</span></span></div></blockquote></div></small></div><span class="kt">Type</span> u</span><span class="alectryon-token">} {</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>β</var><b>: </b><span>Type v</span></span></div></blockquote></div></small></div><span class="nv">β</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Type v</var><b>: </b><span>Type (v + 1)</span></span></div></blockquote></div></small></div><span class="kt">Type</span> v</span><span class="alectryon-token">} {</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>δ</var><b>: </b><span>Type w</span></span></div></blockquote></div></small></div><span class="nv">δ</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Type w</var><b>: </b><span>Type (w + 1)</span></span></div></blockquote></div></small></div><span class="kt">Type</span> w</span><span class="alectryon-token">}

</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>instance</var><b>: </b><span>{α : Type u} → Inhabited (LazyList α)</span></span></div></blockquote></div></small></div><span class="kd">instance</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Inhabited</var><b>: </b><span>Type u → Type u</span></span></div></blockquote></div></small></div>Inhabited</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>LazyList</var><b>: </b><span>Type u → Type u</span></span></div></blockquote></div></small></div>LazyList</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type u</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token">) :=
  ⟨</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>nil</var><b>: </b><span>{α : Type u} → LazyList α</span></span></div></blockquote></div></small></div>nil</span><span class="alectryon-token">⟩

<span class="kd">@[inline]</span> </span><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>pure</var><b>: </b><span>α → LazyList α</span></span></div></blockquote></div></small></div><span class="nv">pure</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type u</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>LazyList</var><b>: </b><span>Type u → Type u</span></span></div></blockquote></div></small></div>LazyList</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type u</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>cons</var><b>: </b><span>{α : Type u} → α → LazyList α → LazyList α</span></span></div></blockquote></div></small></div>cons</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>nil</var><b>: </b><span>{α : Type u} → LazyList α</span></span></div></blockquote></div></small></div>nil</span><span class="alectryon-token">

</span><span class="alectryon-token"><span class="k">partial</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>isEmpty</var><b>: </b><span>LazyList α → Bool</span></span></div></blockquote></div></small></div><span class="nv">isEmpty</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>LazyList</var><b>: </b><span>Type u → Type u</span></span></div></blockquote></div></small></div>LazyList</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type u</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Bool</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Bool</span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>nil</var><b>: </b><span>{α : Type ?u.1027} → LazyList α</span></span></div></blockquote></div></small></div>nil</span><span class="alectryon-token">          <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>true</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div>true</span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>cons</var><b>: </b><span>{α : Type ?u.1036} → α → LazyList α → LazyList α</span></span></div></blockquote></div></small></div>cons</span><span class="alectryon-token"> _ _     <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>false</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div>false</span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>delayed</var><b>: </b><span>{α : Type ?u.1058} → Thunk (LazyList α) → LazyList α</span></span></div></blockquote></div></small></div>delayed</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>as</var><b>: </b><span>Thunk (LazyList α)</span></span></div></blockquote></div></small></div><span class="nv">as</span></span><span class="alectryon-token">   <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>isEmpty</var><b>: </b><span>LazyList α → Bool</span></span></div></blockquote></div></small></div><span class="nv">isEmpty</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>as</var><b>: </b><span>Thunk (LazyList α)</span></span></div></blockquote></div></small></div><span class="nv">as</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>get</var><b>: </b><span>{α : Type u} → Thunk α → α</span></span></div></blockquote></div></small></div>get</span><span class="alectryon-token">

</span><span class="alectryon-token"><span class="k">partial</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>toList</var><b>: </b><span>LazyList α → List α</span></span></div></blockquote></div></small></div><span class="nv">toList</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>LazyList</var><b>: </b><span>Type u → Type u</span></span></div></blockquote></div></small></div>LazyList</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type u</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>List</var><b>: </b><span>Type u → Type u</span></span></div></blockquote></div></small></div>List</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type u</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>nil</var><b>: </b><span>{α : Type ?u.1187} → LazyList α</span></span></div></blockquote></div></small></div>nil</span><span class="alectryon-token">          <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>[]</var><b>: </b><span>List α</span></span></div></blockquote></div></small></div>[]</span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>cons</var><b>: </b><span>{α : Type ?u.1199} → α → LazyList α → LazyList α</span></span></div></blockquote></div></small></div>cons</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>as</var><b>: </b><span>LazyList α</span></span></div></blockquote></div></small></div><span class="nv">as</span></span><span class="alectryon-token">    <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"> :: </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>toList</var><b>: </b><span>LazyList α → List α</span></span></div></blockquote></div></small></div><span class="nv">toList</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>as</var><b>: </b><span>LazyList α</span></span></div></blockquote></div></small></div><span class="nv">as</span></span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>delayed</var><b>: </b><span>{α : Type ?u.1221} → Thunk (LazyList α) → LazyList α</span></span></div></blockquote></div></small></div>delayed</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>as</var><b>: </b><span>Thunk (LazyList α)</span></span></div></blockquote></div></small></div><span class="nv">as</span></span><span class="alectryon-token">   <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>toList</var><b>: </b><span>LazyList α → List α</span></span></div></blockquote></div></small></div><span class="nv">toList</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>as</var><b>: </b><span>Thunk (LazyList α)</span></span></div></blockquote></div></small></div><span class="nv">as</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>get</var><b>: </b><span>{α : Type u} → Thunk α → α</span></span></div></blockquote></div></small></div>get</span><span class="alectryon-token">

</span><span class="alectryon-token"><span class="k">partial</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>head</var><b>: </b><span>{α : Type u} → [inst : Inhabited α] → LazyList α → α</span></span></div></blockquote></div></small></div><span class="nv">head</span></span><span class="alectryon-token"> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Inhabited</var><b>: </b><span>Type u → Type u</span></span></div></blockquote></div></small></div>Inhabited</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type u</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token">] : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>LazyList</var><b>: </b><span>Type u → Type u</span></span></div></blockquote></div></small></div>LazyList</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type u</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type u</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>nil</var><b>: </b><span>{α : Type ?u.1357} → LazyList α</span></span></div></blockquote></div></small></div>nil</span><span class="alectryon-token">          <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>default</var><b>: </b><span>{α : Type u} → [self : Inhabited α] → α</span></span></div></blockquote></div></small></div>default</span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>cons</var><b>: </b><span>{α : Type ?u.1373} → α → LazyList α → LazyList α</span></span></div></blockquote></div></small></div>cons</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="LazyList-lean-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="LazyList-lean-chk0"><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>as</var><b>: </b><span>LazyList α</span></span></div></blockquote></div></small></div><span class="nv">as</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Warning: unused <span class="kd">variable</span> <span class="bp">`</span>as<span class="bp">`</span></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">    <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>delayed</var><b>: </b><span>{α : Type ?u.1393} → Thunk (LazyList α) → LazyList α</span></span></div></blockquote></div></small></div>delayed</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>as</var><b>: </b><span>Thunk (LazyList α)</span></span></div></blockquote></div></small></div><span class="nv">as</span></span><span class="alectryon-token">   <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>head</var><b>: </b><span>[inst : Inhabited α] → LazyList α → α</span></span></div></blockquote></div></small></div><span class="nv">head</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>as</var><b>: </b><span>Thunk (LazyList α)</span></span></div></blockquote></div></small></div><span class="nv">as</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>get</var><b>: </b><span>{α : Type u} → Thunk α → α</span></span></div></blockquote></div></small></div>get</span><span class="alectryon-token">

</span><span class="alectryon-token"><span class="k">partial</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>tail</var><b>: </b><span>{α : Type u} → LazyList α → LazyList α</span></span></div></blockquote></div></small></div><span class="nv">tail</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>LazyList</var><b>: </b><span>Type u → Type u</span></span></div></blockquote></div></small></div>LazyList</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type u</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>LazyList</var><b>: </b><span>Type u → Type u</span></span></div></blockquote></div></small></div>LazyList</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type u</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>nil</var><b>: </b><span>{α : Type ?u.1530} → LazyList α</span></span></div></blockquote></div></small></div>nil</span><span class="alectryon-token">          <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>nil</var><b>: </b><span>{α : Type u} → LazyList α</span></span></div></blockquote></div></small></div>nil</span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>cons</var><b>: </b><span>{α : Type ?u.1541} → α → LazyList α → LazyList α</span></span></div></blockquote></div></small></div>cons</span><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="LazyList-lean-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="LazyList-lean-chk1"><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">a</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Warning: unused <span class="kd">variable</span> <span class="bp">`</span>a<span class="bp">`</span></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>as</var><b>: </b><span>LazyList α</span></span></div></blockquote></div></small></div><span class="nv">as</span></span><span class="alectryon-token">    <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>as</var><b>: </b><span>LazyList α</span></span></div></blockquote></div></small></div><span class="nv">as</span></span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>delayed</var><b>: </b><span>{α : Type ?u.1561} → Thunk (LazyList α) → LazyList α</span></span></div></blockquote></div></small></div>delayed</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>as</var><b>: </b><span>Thunk (LazyList α)</span></span></div></blockquote></div></small></div><span class="nv">as</span></span><span class="alectryon-token">   <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>tail</var><b>: </b><span>LazyList α → LazyList α</span></span></div></blockquote></div></small></div><span class="nv">tail</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>as</var><b>: </b><span>Thunk (LazyList α)</span></span></div></blockquote></div></small></div><span class="nv">as</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>get</var><b>: </b><span>{α : Type u} → Thunk α → α</span></span></div></blockquote></div></small></div>get</span><span class="alectryon-token">

</span><span class="alectryon-token"><span class="k">partial</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>append</var><b>: </b><span>{α : Type u} → LazyList α → (Unit → LazyList α) → LazyList α</span></span></div></blockquote></div></small></div><span class="nv">append</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>LazyList</var><b>: </b><span>Type u → Type u</span></span></div></blockquote></div></small></div>LazyList</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type u</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token"> <span class="bp">→</span> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Unit</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Unit</span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>LazyList</var><b>: </b><span>Type u → Type u</span></span></div></blockquote></div></small></div>LazyList</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type u</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token">) <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>LazyList</var><b>: </b><span>Type u → Type u</span></span></div></blockquote></div></small></div>LazyList</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type u</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>nil</var><b>: </b><span>{α : Type ?u.1704} → LazyList α</span></span></div></blockquote></div></small></div>nil</span><span class="alectryon-token">,          </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>bs</var><b>: </b><span>Unit → LazyList α</span></span></div></blockquote></div></small></div><span class="nv">bs</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>bs</var><b>: </b><span>Unit → LazyList α</span></span></div></blockquote></div></small></div><span class="nv">bs</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>()</var><b>: </b><span>Unit</span></span></div></blockquote></div></small></div>()</span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>cons</var><b>: </b><span>{α : Type ?u.1723} → α → LazyList α → LazyList α</span></span></div></blockquote></div></small></div>cons</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>as</var><b>: </b><span>LazyList α</span></span></div></blockquote></div></small></div><span class="nv">as</span></span><span class="alectryon-token">,    </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>bs</var><b>: </b><span>Unit → LazyList α</span></span></div></blockquote></div></small></div><span class="nv">bs</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>delayed</var><b>: </b><span>{α : Type u} → Thunk (LazyList α) → LazyList α</span></span></div></blockquote></div></small></div>delayed</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>cons</var><b>: </b><span>{α : Type u} → α → LazyList α → LazyList α</span></span></div></blockquote></div></small></div>cons</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>append</var><b>: </b><span>LazyList α → (Unit → LazyList α) → LazyList α</span></span></div></blockquote></div></small></div><span class="nv">append</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>as</var><b>: </b><span>LazyList α</span></span></div></blockquote></div></small></div><span class="nv">as</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>bs</var><b>: </b><span>Unit → LazyList α</span></span></div></blockquote></div></small></div><span class="nv">bs</span></span><span class="alectryon-token">))
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>delayed</var><b>: </b><span>{α : Type ?u.1783} → Thunk (LazyList α) → LazyList α</span></span></div></blockquote></div></small></div>delayed</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>as</var><b>: </b><span>Thunk (LazyList α)</span></span></div></blockquote></div></small></div><span class="nv">as</span></span><span class="alectryon-token">,   </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>bs</var><b>: </b><span>Unit → LazyList α</span></span></div></blockquote></div></small></div><span class="nv">bs</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>delayed</var><b>: </b><span>{α : Type u} → Thunk (LazyList α) → LazyList α</span></span></div></blockquote></div></small></div>delayed</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>append</var><b>: </b><span>LazyList α → (Unit → LazyList α) → LazyList α</span></span></div></blockquote></div></small></div><span class="nv">append</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>as</var><b>: </b><span>Thunk (LazyList α)</span></span></div></blockquote></div></small></div><span class="nv">as</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>get</var><b>: </b><span>{α : Type u} → Thunk α → α</span></span></div></blockquote></div></small></div>get</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>bs</var><b>: </b><span>Unit → LazyList α</span></span></div></blockquote></div></small></div><span class="nv">bs</span></span><span class="alectryon-token">)

</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>instance</var><b>: </b><span>{α : Type u} → Append (LazyList α)</span></span></div></blockquote></div></small></div><span class="kd">instance</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Append</var><b>: </b><span>Type u → Type u</span></span></div></blockquote></div></small></div>Append</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>LazyList</var><b>: </b><span>Type u → Type u</span></span></div></blockquote></div></small></div>LazyList</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type u</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token">) </span><span class="alectryon-token"><span class="k">where</span></span><span class="alectryon-token">
  append </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>LazyList α</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>LazyList α</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token"> := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>LazyList.append</var><b>: </b><span>{α : Type u} → LazyList α → (Unit → LazyList α) → LazyList α</span></span></div></blockquote></div></small></div>LazyList.append</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>LazyList α</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><span class="k">fun</span></span><span class="alectryon-token"> _ <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>LazyList α</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token">)

</span><span class="alectryon-token"><span class="k">partial</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>interleave</var><b>: </b><span>LazyList α → LazyList α → LazyList α</span></span></div></blockquote></div></small></div><span class="nv">interleave</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>LazyList</var><b>: </b><span>Type u → Type u</span></span></div></blockquote></div></small></div>LazyList</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type u</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>LazyList</var><b>: </b><span>Type u → Type u</span></span></div></blockquote></div></small></div>LazyList</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type u</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>LazyList</var><b>: </b><span>Type u → Type u</span></span></div></blockquote></div></small></div>LazyList</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type u</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>nil</var><b>: </b><span>{α : Type ?u.2013} → LazyList α</span></span></div></blockquote></div></small></div>nil</span><span class="alectryon-token">,          </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>bs</var><b>: </b><span>LazyList α</span></span></div></blockquote></div></small></div><span class="nv">bs</span></span><span class="alectryon-token">  <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>bs</var><b>: </b><span>LazyList α</span></span></div></blockquote></div></small></div><span class="nv">bs</span></span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>cons</var><b>: </b><span>{α : Type ?u.2031} → α → LazyList α → LazyList α</span></span></div></blockquote></div></small></div>cons</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>as</var><b>: </b><span>LazyList α</span></span></div></blockquote></div></small></div><span class="nv">as</span></span><span class="alectryon-token">,    </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>bs</var><b>: </b><span>LazyList α</span></span></div></blockquote></div></small></div><span class="nv">bs</span></span><span class="alectryon-token">  <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>delayed</var><b>: </b><span>{α : Type u} → Thunk (LazyList α) → LazyList α</span></span></div></blockquote></div></small></div>delayed</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>cons</var><b>: </b><span>{α : Type u} → α → LazyList α → LazyList α</span></span></div></blockquote></div></small></div>cons</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>interleave</var><b>: </b><span>LazyList α → LazyList α → LazyList α</span></span></div></blockquote></div></small></div><span class="nv">interleave</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>bs</var><b>: </b><span>LazyList α</span></span></div></blockquote></div></small></div><span class="nv">bs</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>as</var><b>: </b><span>LazyList α</span></span></div></blockquote></div></small></div><span class="nv">as</span></span><span class="alectryon-token">))
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>delayed</var><b>: </b><span>{α : Type ?u.2089} → Thunk (LazyList α) → LazyList α</span></span></div></blockquote></div></small></div>delayed</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>as</var><b>: </b><span>Thunk (LazyList α)</span></span></div></blockquote></div></small></div><span class="nv">as</span></span><span class="alectryon-token">,   </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>bs</var><b>: </b><span>LazyList α</span></span></div></blockquote></div></small></div><span class="nv">bs</span></span><span class="alectryon-token">  <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>delayed</var><b>: </b><span>{α : Type u} → Thunk (LazyList α) → LazyList α</span></span></div></blockquote></div></small></div>delayed</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>interleave</var><b>: </b><span>LazyList α → LazyList α → LazyList α</span></span></div></blockquote></div></small></div><span class="nv">interleave</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>as</var><b>: </b><span>Thunk (LazyList α)</span></span></div></blockquote></div></small></div><span class="nv">as</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>get</var><b>: </b><span>{α : Type u} → Thunk α → α</span></span></div></blockquote></div></small></div>get</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>bs</var><b>: </b><span>LazyList α</span></span></div></blockquote></div></small></div><span class="nv">bs</span></span><span class="alectryon-token">)

</span><span class="alectryon-token"><span class="k">partial</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>map</var><b>: </b><span>(α → β) → LazyList α → LazyList β</span></span></div></blockquote></div></small></div><span class="nv">map</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>α → β</span></span></div></blockquote></div></small></div><span class="nv">f</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type u</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>β</var><b>: </b><span>Type v</span></span></div></blockquote></div></small></div><span class="nv">β</span></span><span class="alectryon-token">) : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>LazyList</var><b>: </b><span>Type u → Type u</span></span></div></blockquote></div></small></div>LazyList</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type u</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>LazyList</var><b>: </b><span>Type v → Type v</span></span></div></blockquote></div></small></div>LazyList</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>β</var><b>: </b><span>Type v</span></span></div></blockquote></div></small></div><span class="nv">β</span></span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>nil</var><b>: </b><span>{α : Type ?u.2270} → LazyList α</span></span></div></blockquote></div></small></div>nil</span><span class="alectryon-token">          <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>nil</var><b>: </b><span>{α : Type v} → LazyList α</span></span></div></blockquote></div></small></div>nil</span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>cons</var><b>: </b><span>{α : Type ?u.2282} → α → LazyList α → LazyList α</span></span></div></blockquote></div></small></div>cons</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>as</var><b>: </b><span>LazyList α</span></span></div></blockquote></div></small></div><span class="nv">as</span></span><span class="alectryon-token">    <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>delayed</var><b>: </b><span>{α : Type v} → Thunk (LazyList α) → LazyList α</span></span></div></blockquote></div></small></div>delayed</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>cons</var><b>: </b><span>{α : Type v} → α → LazyList α → LazyList α</span></span></div></blockquote></div></small></div>cons</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>α → β</span></span></div></blockquote></div></small></div><span class="nv">f</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token">) (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>map</var><b>: </b><span>(α → β) → LazyList α → LazyList β</span></span></div></blockquote></div></small></div><span class="nv">map</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>α → β</span></span></div></blockquote></div></small></div><span class="nv">f</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>as</var><b>: </b><span>LazyList α</span></span></div></blockquote></div></small></div><span class="nv">as</span></span><span class="alectryon-token">))
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>delayed</var><b>: </b><span>{α : Type ?u.2332} → Thunk (LazyList α) → LazyList α</span></span></div></blockquote></div></small></div>delayed</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>as</var><b>: </b><span>Thunk (LazyList α)</span></span></div></blockquote></div></small></div><span class="nv">as</span></span><span class="alectryon-token">   <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>delayed</var><b>: </b><span>{α : Type v} → Thunk (LazyList α) → LazyList α</span></span></div></blockquote></div></small></div>delayed</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>map</var><b>: </b><span>(α → β) → LazyList α → LazyList β</span></span></div></blockquote></div></small></div><span class="nv">map</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>α → β</span></span></div></blockquote></div></small></div><span class="nv">f</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>as</var><b>: </b><span>Thunk (LazyList α)</span></span></div></blockquote></div></small></div><span class="nv">as</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>get</var><b>: </b><span>{α : Type u} → Thunk α → α</span></span></div></blockquote></div></small></div>get</span><span class="alectryon-token">)

</span><span class="alectryon-token"><span class="k">partial</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>map₂</var><b>: </b><span>(α → β → δ) → LazyList α → LazyList β → LazyList δ</span></span></div></blockquote></div></small></div><span class="nv">map₂</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>α → β → δ</span></span></div></blockquote></div></small></div><span class="nv">f</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type u</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>β</var><b>: </b><span>Type v</span></span></div></blockquote></div></small></div><span class="nv">β</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>δ</var><b>: </b><span>Type w</span></span></div></blockquote></div></small></div><span class="nv">δ</span></span><span class="alectryon-token">) : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>LazyList</var><b>: </b><span>Type u → Type u</span></span></div></blockquote></div></small></div>LazyList</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type u</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>LazyList</var><b>: </b><span>Type v → Type v</span></span></div></blockquote></div></small></div>LazyList</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>β</var><b>: </b><span>Type v</span></span></div></blockquote></div></small></div><span class="nv">β</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>LazyList</var><b>: </b><span>Type w → Type w</span></span></div></blockquote></div></small></div>LazyList</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>δ</var><b>: </b><span>Type w</span></span></div></blockquote></div></small></div><span class="nv">δ</span></span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>nil</var><b>: </b><span>{α : Type ?u.2498} → LazyList α</span></span></div></blockquote></div></small></div>nil</span><span class="alectryon-token">,          _            <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>nil</var><b>: </b><span>{α : Type w} → LazyList α</span></span></div></blockquote></div></small></div>nil</span><span class="alectryon-token">
  <span class="bp">|</span> _,            </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>nil</var><b>: </b><span>{α : Type ?u.2518} → LazyList α</span></span></div></blockquote></div></small></div>nil</span><span class="alectryon-token">          <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>nil</var><b>: </b><span>{α : Type w} → LazyList α</span></span></div></blockquote></div></small></div>nil</span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>cons</var><b>: </b><span>{α : Type ?u.2536} → α → LazyList α → LazyList α</span></span></div></blockquote></div></small></div>cons</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>as</var><b>: </b><span>LazyList α</span></span></div></blockquote></div></small></div><span class="nv">as</span></span><span class="alectryon-token">,    </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>cons</var><b>: </b><span>{α : Type ?u.2540} → α → LazyList α → LazyList α</span></span></div></blockquote></div></small></div>cons</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>β</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>bs</var><b>: </b><span>LazyList β</span></span></div></blockquote></div></small></div><span class="nv">bs</span></span><span class="alectryon-token">    <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>delayed</var><b>: </b><span>{α : Type w} → Thunk (LazyList α) → LazyList α</span></span></div></blockquote></div></small></div>delayed</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>cons</var><b>: </b><span>{α : Type w} → α → LazyList α → LazyList α</span></span></div></blockquote></div></small></div>cons</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>α → β → δ</span></span></div></blockquote></div></small></div><span class="nv">f</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>β</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token">) (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>map₂</var><b>: </b><span>(α → β → δ) → LazyList α → LazyList β → LazyList δ</span></span></div></blockquote></div></small></div><span class="nv">map₂</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>α → β → δ</span></span></div></blockquote></div></small></div><span class="nv">f</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>as</var><b>: </b><span>LazyList α</span></span></div></blockquote></div></small></div><span class="nv">as</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>bs</var><b>: </b><span>LazyList β</span></span></div></blockquote></div></small></div><span class="nv">bs</span></span><span class="alectryon-token">))
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>delayed</var><b>: </b><span>{α : Type ?u.2607} → Thunk (LazyList α) → LazyList α</span></span></div></blockquote></div></small></div>delayed</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>as</var><b>: </b><span>Thunk (LazyList α)</span></span></div></blockquote></div></small></div><span class="nv">as</span></span><span class="alectryon-token">,   </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>bs</var><b>: </b><span>LazyList β</span></span></div></blockquote></div></small></div><span class="nv">bs</span></span><span class="alectryon-token">           <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>delayed</var><b>: </b><span>{α : Type w} → Thunk (LazyList α) → LazyList α</span></span></div></blockquote></div></small></div>delayed</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>map₂</var><b>: </b><span>(α → β → δ) → LazyList α → LazyList β → LazyList δ</span></span></div></blockquote></div></small></div><span class="nv">map₂</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>α → β → δ</span></span></div></blockquote></div></small></div><span class="nv">f</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>as</var><b>: </b><span>Thunk (LazyList α)</span></span></div></blockquote></div></small></div><span class="nv">as</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>get</var><b>: </b><span>{α : Type u} → Thunk α → α</span></span></div></blockquote></div></small></div>get</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>bs</var><b>: </b><span>LazyList β</span></span></div></blockquote></div></small></div><span class="nv">bs</span></span><span class="alectryon-token">)
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>as</var><b>: </b><span>LazyList α</span></span></div></blockquote></div></small></div><span class="nv">as</span></span><span class="alectryon-token">,           </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>delayed</var><b>: </b><span>{α : Type ?u.2644} → Thunk (LazyList α) → LazyList α</span></span></div></blockquote></div></small></div>delayed</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>bs</var><b>: </b><span>Thunk (LazyList β)</span></span></div></blockquote></div></small></div><span class="nv">bs</span></span><span class="alectryon-token">   <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>delayed</var><b>: </b><span>{α : Type w} → Thunk (LazyList α) → LazyList α</span></span></div></blockquote></div></small></div>delayed</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>map₂</var><b>: </b><span>(α → β → δ) → LazyList α → LazyList β → LazyList δ</span></span></div></blockquote></div></small></div><span class="nv">map₂</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>α → β → δ</span></span></div></blockquote></div></small></div><span class="nv">f</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>as</var><b>: </b><span>LazyList α</span></span></div></blockquote></div></small></div><span class="nv">as</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>bs</var><b>: </b><span>Thunk (LazyList β)</span></span></div></blockquote></div></small></div><span class="nv">bs</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>get</var><b>: </b><span>{α : Type v} → Thunk α → α</span></span></div></blockquote></div></small></div>get</span><span class="alectryon-token">)

<span class="kd">@[inline]</span> </span><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>zip</var><b>: </b><span>LazyList α → LazyList β → LazyList (α × β)</span></span></div></blockquote></div></small></div><span class="nv">zip</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>LazyList</var><b>: </b><span>Type u → Type u</span></span></div></blockquote></div></small></div>LazyList</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type u</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>LazyList</var><b>: </b><span>Type v → Type v</span></span></div></blockquote></div></small></div>LazyList</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>β</var><b>: </b><span>Type v</span></span></div></blockquote></div></small></div><span class="nv">β</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>LazyList</var><b>: </b><span>Type (max v u) → Type (max v u)</span></span></div></blockquote></div></small></div>LazyList</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type u</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token"> <span class="bp">×</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>β</var><b>: </b><span>Type v</span></span></div></blockquote></div></small></div><span class="nv">β</span></span><span class="alectryon-token">) :=
  </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>map₂</var><b>: </b><span>{α : Type u} → {β : Type v} → {δ : Type (max u v)} → (α → β → δ) → LazyList α → LazyList β → LazyList δ</span></span></div></blockquote></div></small></div>map₂</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Prod.mk</var><b>: </b><span>{α : Type u} → {β : Type v} → α → β → α × β</span></span></div></blockquote></div></small></div>Prod.mk</span><span class="alectryon-token">

</span><span class="alectryon-token"><span class="k">partial</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>join</var><b>: </b><span>LazyList (LazyList α) → LazyList α</span></span></div></blockquote></div></small></div><span class="nv">join</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>LazyList</var><b>: </b><span>Type u → Type u</span></span></div></blockquote></div></small></div>LazyList</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>LazyList</var><b>: </b><span>Type u → Type u</span></span></div></blockquote></div></small></div>LazyList</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type u</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token">) <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>LazyList</var><b>: </b><span>Type u → Type u</span></span></div></blockquote></div></small></div>LazyList</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type u</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>nil</var><b>: </b><span>{α : Type ?u.3036} → LazyList α</span></span></div></blockquote></div></small></div>nil</span><span class="alectryon-token">          <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>nil</var><b>: </b><span>{α : Type u} → LazyList α</span></span></div></blockquote></div></small></div>nil</span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>cons</var><b>: </b><span>{α : Type ?u.3047} → α → LazyList α → LazyList α</span></span></div></blockquote></div></small></div>cons</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>LazyList α</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>as</var><b>: </b><span>LazyList (LazyList α)</span></span></div></blockquote></div></small></div><span class="nv">as</span></span><span class="alectryon-token">    <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>delayed</var><b>: </b><span>{α : Type u} → Thunk (LazyList α) → LazyList α</span></span></div></blockquote></div></small></div>delayed</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>append</var><b>: </b><span>{α : Type u} → LazyList α → (Unit → LazyList α) → LazyList α</span></span></div></blockquote></div></small></div>append</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>LazyList α</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">fun</span></span><span class="alectryon-token"> _ <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>join</var><b>: </b><span>LazyList (LazyList α) → LazyList α</span></span></div></blockquote></div></small></div><span class="nv">join</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>as</var><b>: </b><span>LazyList (LazyList α)</span></span></div></blockquote></div></small></div><span class="nv">as</span></span><span class="alectryon-token">)
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>delayed</var><b>: </b><span>{α : Type ?u.3102} → Thunk (LazyList α) → LazyList α</span></span></div></blockquote></div></small></div>delayed</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>as</var><b>: </b><span>Thunk (LazyList (LazyList α))</span></span></div></blockquote></div></small></div><span class="nv">as</span></span><span class="alectryon-token">   <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>delayed</var><b>: </b><span>{α : Type u} → Thunk (LazyList α) → LazyList α</span></span></div></blockquote></div></small></div>delayed</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>join</var><b>: </b><span>LazyList (LazyList α) → LazyList α</span></span></div></blockquote></div></small></div><span class="nv">join</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>as</var><b>: </b><span>Thunk (LazyList (LazyList α))</span></span></div></blockquote></div></small></div><span class="nv">as</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>get</var><b>: </b><span>{α : Type u} → Thunk α → α</span></span></div></blockquote></div></small></div>get</span><span class="alectryon-token">)

<span class="kd">@[inline]</span> </span><span class="alectryon-token"><span class="k">partial</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>bind</var><b>: </b><span>{α : Type u} → {β : Type v} → LazyList α → (α → LazyList β) → LazyList β</span></span></div></blockquote></div></small></div><span class="nv">bind</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>LazyList α</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>LazyList</var><b>: </b><span>Type u → Type u</span></span></div></blockquote></div></small></div>LazyList</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type u</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token">) (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>α → LazyList β</span></span></div></blockquote></div></small></div><span class="nv">f</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type u</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>LazyList</var><b>: </b><span>Type v → Type v</span></span></div></blockquote></div></small></div>LazyList</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>β</var><b>: </b><span>Type v</span></span></div></blockquote></div></small></div><span class="nv">β</span></span><span class="alectryon-token">) : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>LazyList</var><b>: </b><span>Type v → Type v</span></span></div></blockquote></div></small></div>LazyList</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>β</var><b>: </b><span>Type v</span></span></div></blockquote></div></small></div><span class="nv">β</span></span><span class="alectryon-token"> :=
  </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>join</var><b>: </b><span>{α : Type v} → LazyList (LazyList α) → LazyList α</span></span></div></blockquote></div></small></div>join</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>LazyList α</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>map</var><b>: </b><span>{α : Type u} → {β : Type v} → (α → β) → LazyList α → LazyList β</span></span></div></blockquote></div></small></div>map</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>α → LazyList β</span></span></div></blockquote></div></small></div><span class="nv">f</span></span><span class="alectryon-token">)

</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>instance</var><b>: </b><span>Monad LazyList</span></span></div></blockquote></div></small></div><span class="kd">instance</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Monad</var><b>: </b><span>(Type u_1 → Type u_1) → Type (u_1 + 1)</span></span></div></blockquote></div></small></div>Monad</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>LazyList</var><b>: </b><span>Type u_1 → Type u_1</span></span></div></blockquote></div></small></div>LazyList</span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">where</span></span><span class="alectryon-token">
  pure := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>LazyList.pure</var><b>: </b><span>{α : Type u_1} → α → LazyList α</span></span></div></blockquote></div></small></div>LazyList.pure</span><span class="alectryon-token">
  bind := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>LazyList.bind</var><b>: </b><span>{α β : Type u_1} → LazyList α → (α → LazyList β) → LazyList β</span></span></div></blockquote></div></small></div>LazyList.bind</span><span class="alectryon-token">
  map  := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>LazyList.map</var><b>: </b><span>{α β : Type u_1} → (α → β) → LazyList α → LazyList β</span></span></div></blockquote></div></small></div>LazyList.map</span><span class="alectryon-token">

</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>instance</var><b>: </b><span>Alternative LazyList</span></span></div></blockquote></div></small></div><span class="kd">instance</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Alternative</var><b>: </b><span>(Type u_1 → Type u_1) → Type (u_1 + 1)</span></span></div></blockquote></div></small></div>Alternative</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>LazyList</var><b>: </b><span>Type u_1 → Type u_1</span></span></div></blockquote></div></small></div>LazyList</span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">where</span></span><span class="alectryon-token">
  failure := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>nil</var><b>: </b><span>{α : Type u_1} → LazyList α</span></span></div></blockquote></div></small></div>nil</span><span class="alectryon-token">
  orElse  := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>LazyList.append</var><b>: </b><span>{α : Type u_1} → LazyList α → (Unit → LazyList α) → LazyList α</span></span></div></blockquote></div></small></div>LazyList.append</span><span class="alectryon-token">

</span><span class="alectryon-token"><span class="k">partial</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>approx</var><b>: </b><span>Nat → LazyList α → List α</span></span></div></blockquote></div></small></div><span class="nv">approx</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Nat</span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>LazyList</var><b>: </b><span>Type u → Type u</span></span></div></blockquote></div></small></div>LazyList</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type u</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>List</var><b>: </b><span>Type u → Type u</span></span></div></blockquote></div></small></div>List</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type u</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>0</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">0</span></span><span class="alectryon-token">,     </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="LazyList-lean-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="LazyList-lean-chk2"><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>as</var><b>: </b><span>LazyList α</span></span></div></blockquote></div></small></div><span class="nv">as</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Warning: unused <span class="kd">variable</span> <span class="bp">`</span>as<span class="bp">`</span></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">           <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>[]</var><b>: </b><span>List α</span></span></div></blockquote></div></small></div>[]</span><span class="alectryon-token">
  <span class="bp">|</span> _,     </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>nil</var><b>: </b><span>{α : Type ?u.3731} → LazyList α</span></span></div></blockquote></div></small></div>nil</span><span class="alectryon-token">          <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>[]</var><b>: </b><span>List α</span></span></div></blockquote></div></small></div>[]</span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>i</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">i</span></span><span class="alectryon-token"><span class="bp">+</span><span class="mi">1</span>,   </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>cons</var><b>: </b><span>{α : Type ?u.3749} → α → LazyList α → LazyList α</span></span></div></blockquote></div></small></div>cons</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>as</var><b>: </b><span>LazyList α</span></span></div></blockquote></div></small></div><span class="nv">as</span></span><span class="alectryon-token">    <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"> :: </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>approx</var><b>: </b><span>Nat → LazyList α → List α</span></span></div></blockquote></div></small></div><span class="nv">approx</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>i</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">i</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>as</var><b>: </b><span>LazyList α</span></span></div></blockquote></div></small></div><span class="nv">as</span></span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>i</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">i</span></span><span class="alectryon-token"><span class="bp">+</span><span class="mi">1</span>,   </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>delayed</var><b>: </b><span>{α : Type ?u.3839} → Thunk (LazyList α) → LazyList α</span></span></div></blockquote></div></small></div>delayed</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>as</var><b>: </b><span>Thunk (LazyList α)</span></span></div></blockquote></div></small></div><span class="nv">as</span></span><span class="alectryon-token">   <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>approx</var><b>: </b><span>Nat → LazyList α → List α</span></span></div></blockquote></div></small></div><span class="nv">approx</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>i</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">i</span></span><span class="alectryon-token"><span class="bp">+</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>1</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">1</span></span><span class="alectryon-token">) </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>as</var><b>: </b><span>Thunk (LazyList α)</span></span></div></blockquote></div></small></div><span class="nv">as</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>get</var><b>: </b><span>{α : Type u} → Thunk α → α</span></span></div></blockquote></div></small></div>get</span><span class="alectryon-token">

</span><span class="alectryon-token"><span class="k">partial</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>iterate</var><b>: </b><span>(α → α) → α → LazyList α</span></span></div></blockquote></div></small></div><span class="nv">iterate</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>α → α</span></span></div></blockquote></div></small></div><span class="nv">f</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type u</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type u</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token">) : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type u</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>LazyList</var><b>: </b><span>Type u → Type u</span></span></div></blockquote></div></small></div>LazyList</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type u</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>cons</var><b>: </b><span>{α : Type u} → α → LazyList α → LazyList α</span></span></div></blockquote></div></small></div>cons</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>delayed</var><b>: </b><span>{α : Type u} → Thunk (LazyList α) → LazyList α</span></span></div></blockquote></div></small></div>delayed</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>iterate</var><b>: </b><span>(α → α) → α → LazyList α</span></span></div></blockquote></div></small></div><span class="nv">iterate</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>α → α</span></span></div></blockquote></div></small></div><span class="nv">f</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>α → α</span></span></div></blockquote></div></small></div><span class="nv">f</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token">)))

</span><span class="alectryon-token"><span class="k">partial</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>iterate₂</var><b>: </b><span>(α → α → α) → α → α → LazyList α</span></span></div></blockquote></div></small></div><span class="nv">iterate₂</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>α → α → α</span></span></div></blockquote></div></small></div><span class="nv">f</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type u</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type u</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type u</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token">) : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type u</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type u</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>LazyList</var><b>: </b><span>Type u → Type u</span></span></div></blockquote></div></small></div>LazyList</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type u</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>y</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">y</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>cons</var><b>: </b><span>{α : Type u} → α → LazyList α → LazyList α</span></span></div></blockquote></div></small></div>cons</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>delayed</var><b>: </b><span>{α : Type u} → Thunk (LazyList α) → LazyList α</span></span></div></blockquote></div></small></div>delayed</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>iterate₂</var><b>: </b><span>(α → α → α) → α → α → LazyList α</span></span></div></blockquote></div></small></div><span class="nv">iterate₂</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>α → α → α</span></span></div></blockquote></div></small></div><span class="nv">f</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>y</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">y</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>α → α → α</span></span></div></blockquote></div></small></div><span class="nv">f</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>y</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">y</span></span><span class="alectryon-token">)))

</span><span class="alectryon-token"><span class="k">partial</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>filter</var><b>: </b><span>(α → Bool) → LazyList α → LazyList α</span></span></div></blockquote></div></small></div><span class="nv">filter</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>p</var><b>: </b><span>α → Bool</span></span></div></blockquote></div></small></div><span class="nv">p</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type u</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Bool</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Bool</span><span class="alectryon-token">) : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>LazyList</var><b>: </b><span>Type u → Type u</span></span></div></blockquote></div></small></div>LazyList</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type u</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>LazyList</var><b>: </b><span>Type u → Type u</span></span></div></blockquote></div></small></div>LazyList</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type u</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>nil</var><b>: </b><span>{α : Type ?u.4392} → LazyList α</span></span></div></blockquote></div></small></div>nil</span><span class="alectryon-token">          <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>nil</var><b>: </b><span>{α : Type u} → LazyList α</span></span></div></blockquote></div></small></div>nil</span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>cons</var><b>: </b><span>{α : Type ?u.4403} → α → LazyList α → LazyList α</span></span></div></blockquote></div></small></div>cons</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>as</var><b>: </b><span>LazyList α</span></span></div></blockquote></div></small></div><span class="nv">as</span></span><span class="alectryon-token">    <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>delayed</var><b>: </b><span>{α : Type u} → Thunk (LazyList α) → LazyList α</span></span></div></blockquote></div></small></div>delayed</span><span class="alectryon-token"> (</span><span class="alectryon-token"><span class="k">if</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>p</var><b>: </b><span>α → Bool</span></span></div></blockquote></div></small></div><span class="nv">p</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">then</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>cons</var><b>: </b><span>{α : Type u} → α → LazyList α → LazyList α</span></span></div></blockquote></div></small></div>cons</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>filter</var><b>: </b><span>(α → Bool) → LazyList α → LazyList α</span></span></div></blockquote></div></small></div><span class="nv">filter</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>p</var><b>: </b><span>α → Bool</span></span></div></blockquote></div></small></div><span class="nv">p</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>as</var><b>: </b><span>LazyList α</span></span></div></blockquote></div></small></div><span class="nv">as</span></span><span class="alectryon-token">) </span><span class="alectryon-token"><span class="k">else</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>filter</var><b>: </b><span>(α → Bool) → LazyList α → LazyList α</span></span></div></blockquote></div></small></div><span class="nv">filter</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>p</var><b>: </b><span>α → Bool</span></span></div></blockquote></div></small></div><span class="nv">p</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>as</var><b>: </b><span>LazyList α</span></span></div></blockquote></div></small></div><span class="nv">as</span></span><span class="alectryon-token">)
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>delayed</var><b>: </b><span>{α : Type ?u.4545} → Thunk (LazyList α) → LazyList α</span></span></div></blockquote></div></small></div>delayed</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>as</var><b>: </b><span>Thunk (LazyList α)</span></span></div></blockquote></div></small></div><span class="nv">as</span></span><span class="alectryon-token">   <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>delayed</var><b>: </b><span>{α : Type u} → Thunk (LazyList α) → LazyList α</span></span></div></blockquote></div></small></div>delayed</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>filter</var><b>: </b><span>(α → Bool) → LazyList α → LazyList α</span></span></div></blockquote></div></small></div><span class="nv">filter</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>p</var><b>: </b><span>α → Bool</span></span></div></blockquote></div></small></div><span class="nv">p</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>as</var><b>: </b><span>Thunk (LazyList α)</span></span></div></blockquote></div></small></div><span class="nv">as</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>get</var><b>: </b><span>{α : Type u} → Thunk α → α</span></span></div></blockquote></div></small></div>get</span><span class="alectryon-token">)

</span><span class="alectryon-token"><span class="kd">end</span></span><span class="alectryon-token"> LazyList</span></span></pre><div style="break-before: page; page-break-before: always;"></div><pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kn">import</span> Do.Mut</span></span></pre>
<h1 id="early-return"><a class="header" href="#early-return">Early Return</a></h1>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kn">open</span></span><span class="alectryon-token"> Lean

<span class="c">/-</span><span class="cm"> Disable the automatic monadic lifting feature described in the paper.</span>
<span class="cm">   We want to make it clear that we do not depend on it. -/</span>
</span><span class="alectryon-token"><span class="kd">set_option</span></span><span class="alectryon-token"> autoLift </span><span class="alectryon-token"><span class="k">false</span></span><span class="alectryon-token">

</span><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>runCatch</var><b>: </b><span>{m : Type u_1 → Type u_2} → {α : Type u_1} → [inst : Monad m] → ExceptT α m α → m α</span></span></div></blockquote></div></small></div><span class="nv">runCatch</span></span><span class="alectryon-token"> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Monad</var><b>: </b><span>(Type ?u.9 → Type ?u.8) → Type (max (?u.9 + 1) ?u.8)</span></span></div></blockquote></div></small></div>Monad</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>Type u_1 → Type u_2</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token">] (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>ExceptT α m α</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ExceptT</var><b>: </b><span>Type u_1 → (Type u_1 → Type u_2) → Type u_1 → Type u_2</span></span></div></blockquote></div></small></div>ExceptT</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type u_1</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>Type u_1 → Type u_2</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type u_1</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token">) : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>Type u_1 → Type u_2</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type u_1</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token"> :=
  </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ExceptT.run</var><b>: </b><span>{ε : Type u_1} → {m : Type u_1 → Type u_2} → {α : Type u_1} → ExceptT ε m α → m (Except ε α)</span></span></div></blockquote></div></small></div>ExceptT.run</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>ExceptT α m α</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> <span class="bp">&gt;&gt;=</span> </span><span class="alectryon-token"><span class="k">fun</span></span><span class="alectryon-token">
    <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Except.ok</var><b>: </b><span>{ε : Type ?u.57} → {α : Type ?u.56} → α → Except ε α</span></span></div></blockquote></div></small></div>Except.ok</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>pure</var><b>: </b><span>{f : Type u_1 → Type u_2} → [self : Pure f] → {α : Type u_1} → α → f α</span></span></div></blockquote></div></small></div>pure</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token">
    <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Except.error</var><b>: </b><span>{ε : Type ?u.115} → {α : Type ?u.114} → ε → Except ε α</span></span></div></blockquote></div></small></div>Except.error</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>pure</var><b>: </b><span>{f : Type u_1 → Type u_2} → [self : Pure f] → {α : Type u_1} → α → f α</span></span></div></blockquote></div></small></div>pure</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token">

<span class="sd">/-- Count syntax nodes satisfying `p`. -/</span>
</span><span class="alectryon-token"><span class="k">partial</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Lean.Syntax.count</var><b>: </b><span>Syntax → (Syntax → Bool) → Nat</span></span></div></blockquote></div></small></div><span class="nv">Lean.Syntax.count</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>stx</var><b>: </b><span>Syntax</span></span></div></blockquote></div></small></div><span class="nv">stx</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Syntax</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Syntax</span><span class="alectryon-token">) (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>p</var><b>: </b><span>Syntax → Bool</span></span></div></blockquote></div></small></div><span class="nv">p</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Syntax</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Syntax</span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Bool</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Bool</span><span class="alectryon-token">) : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Nat</span><span class="alectryon-token"> :=
  </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>stx</var><b>: </b><span>Syntax</span></span></div></blockquote></div></small></div><span class="nv">stx</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>getArgs</var><b>: </b><span>Syntax → Array Syntax</span></span></div></blockquote></div></small></div>getArgs</span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>foldl</var><b>: </b><span>{α β : Type} → (β → α → β) → β → (as : Array α) → optParam Nat 0 → optParam Nat (Array.size as) → β</span></span></div></blockquote></div></small></div>foldl</span><span class="alectryon-token"> (</span><span class="alectryon-token"><span class="k">fun</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>n</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">n</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>arg</var><b>: </b><span>Syntax</span></span></div></blockquote></div></small></div><span class="nv">arg</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>n</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">n</span></span><span class="alectryon-token"> <span class="bp">+</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>arg</var><b>: </b><span>Syntax</span></span></div></blockquote></div></small></div><span class="nv">arg</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>count</var><b>: </b><span>Syntax → (Syntax → Bool) → Nat</span></span></div></blockquote></div></small></div><span class="nv">count</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>p</var><b>: </b><span>Syntax → Bool</span></span></div></blockquote></div></small></div><span class="nv">p</span></span><span class="alectryon-token">) (</span><span class="alectryon-token"><span class="k">if</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>p</var><b>: </b><span>Syntax → Bool</span></span></div></blockquote></div></small></div><span class="nv">p</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>stx</var><b>: </b><span>Syntax</span></span></div></blockquote></div></small></div><span class="nv">stx</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">then</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>1</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">1</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">else</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>0</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">0</span></span><span class="alectryon-token">)

</span><span class="alectryon-token"><span class="k">syntax</span></span><span class="alectryon-token"> <span class="s2">&quot;return&quot;</span> term : stmt

</span><span class="alectryon-token"><span class="k">syntax</span></span><span class="alectryon-token"> <span class="s2">&quot;return&quot;</span> : expander

</span><span class="alectryon-token"><span class="k">macro_rules</span></span><span class="alectryon-token">
  <span class="bp">|</span> <span class="bp">`</span>(</span><span class="alectryon-token"><span class="k">do</span><span class="bp">&#39;</span></span><span class="alectryon-token"> <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>TSyntax `stmt</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token">) <span class="bp">=&gt;</span> </span><span class="alectryon-token"><span class="k">do</span></span><span class="alectryon-token">  <span class="c1">-- (1&#39;)</span>
    <span class="c1">-- optimization: fall back to original rule (1) if now `return` statement was expanded</span>
    </span><span class="alectryon-token"><span class="k">let</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s'</var><b>: </b><span>TSyntax `stmt</span></span></div></blockquote></div></small></div><span class="nv">s&#39;</span></span><span class="alectryon-token"> <span class="bp">←</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>expandStmt</var><b>: </b><span>TSyntax `stmt → MacroM (TSyntax `stmt)</span></span></div></blockquote></div></small></div><span class="k">expandStmt</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>(← `(stmt| expand! return in $s))</var><b>: </b><span>TSyntax `stmt</span></span></div></blockquote></div></small></div>(<span class="bp">←</span> <span class="bp">`</span>(stmt<span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>(← `(stmt| expand! return in $s))</var><b>: </b><span>TSyntax `stmt</span></span></div></blockquote></div></small></div>expand<span class="bp">!</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>(← `(stmt| expand! return in $s))</var><b>: </b><span>TSyntax `stmt</span></span></div></blockquote></div></small></div> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>(← `(stmt| expand! return in $s))</var><b>: </b><span>TSyntax `stmt</span></span></div></blockquote></div></small></div><span class="k">return</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>(← `(stmt| expand! return in $s))</var><b>: </b><span>TSyntax `stmt</span></span></div></blockquote></div></small></div> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>(← `(stmt| expand! return in $s))</var><b>: </b><span>TSyntax `stmt</span></span></div></blockquote></div></small></div><span class="k">in</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>(← `(stmt| expand! return in $s))</var><b>: </b><span>TSyntax `stmt</span></span></div></blockquote></div></small></div> <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>TSyntax `stmt</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>(← `(stmt| expand! return in $s))</var><b>: </b><span>TSyntax `stmt</span></span></div></blockquote></div></small></div>))</span><span class="alectryon-token">
    </span><span class="alectryon-token"><span class="k">if</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s'</var><b>: </b><span>TSyntax `stmt</span></span></div></blockquote></div></small></div><span class="nv">s&#39;</span></span><span class="alectryon-token"><span class="k">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>raw</var><b>: </b><span>{ks : SyntaxNodeKinds} → TSyntax ks → Syntax</span></span></div></blockquote></div></small></div><span class="k">raw</span></span><span class="alectryon-token"><span class="k">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>count</var><b>: </b><span>Syntax → (Syntax → Bool) → Nat</span></span></div></blockquote></div></small></div><span class="k">count</span></span><span class="alectryon-token"> (<span class="bp">·</span> </span><span class="alectryon-token"><span class="k">matches</span></span><span class="alectryon-token"> <span class="bp">`</span>(stmt<span class="bp">|</span> </span><span class="alectryon-token"><span class="k">return</span></span><span class="alectryon-token"> <span class="bp">$</span>_)) <span class="bp">==</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>TSyntax `stmt</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token"><span class="k">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>raw</var><b>: </b><span>{ks : SyntaxNodeKinds} → TSyntax ks → Syntax</span></span></div></blockquote></div></small></div><span class="k">raw</span></span><span class="alectryon-token"><span class="k">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>count</var><b>: </b><span>Syntax → (Syntax → Bool) → Nat</span></span></div></blockquote></div></small></div><span class="k">count</span></span><span class="alectryon-token"> (<span class="bp">·</span> </span><span class="alectryon-token"><span class="k">matches</span></span><span class="alectryon-token"> <span class="bp">`</span>(stmt<span class="bp">|</span> </span><span class="alectryon-token"><span class="k">return</span></span><span class="alectryon-token"> <span class="bp">$</span>_)) </span><span class="alectryon-token"><span class="k">then</span></span><span class="alectryon-token">
      <span class="bp">`</span>(</span><span class="alectryon-token">d<span class="bp">!</span></span><span class="alectryon-token"> <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>TSyntax `stmt</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token">)
    </span><span class="alectryon-token"><span class="k">else</span></span><span class="alectryon-token">
      <span class="bp">`</span>(ExceptCpsT.runCatch (</span><span class="alectryon-token">d<span class="bp">!</span></span><span class="alectryon-token"> <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s'</var><b>: </b><span>TSyntax `stmt</span></span></div></blockquote></div></small></div><span class="nv">s&#39;</span></span><span class="alectryon-token">))</span><span class="alectryon-token">

</span><span class="alectryon-token"><span class="k">macro_rules</span></span><span class="alectryon-token">
  <span class="bp">|</span> <span class="bp">`</span>(stmt<span class="bp">|</span> </span><span class="alectryon-token">expand<span class="bp">!</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">return</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">in</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">return</span></span><span class="alectryon-token"> <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>TSyntax `term</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token">) <span class="bp">=&gt;</span> <span class="bp">`</span>(stmt<span class="bp">|</span> throw <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>TSyntax `term</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token">)          <span class="c1">-- (R1)</span>
  <span class="bp">|</span> <span class="bp">`</span>(stmt<span class="bp">|</span> </span><span class="alectryon-token">expand<span class="bp">!</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">return</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">in</span></span><span class="alectryon-token"> <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>TSyntax `term</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token">:term) <span class="bp">=&gt;</span> <span class="bp">`</span>(stmt<span class="bp">|</span> ExceptCpsT.lift <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>TSyntax `term</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token">)</span><span class="alectryon-token">  <span class="c1">-- (R2)</span>

</span><span class="alectryon-token"><span class="kd">variable</span></span><span class="alectryon-token"> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Monad</var><b>: </b><span>(Type ?u.3135 → Type ?u.3134) → Type (max (?u.3135 + 1) ?u.3134)</span></span></div></blockquote></div></small></div>Monad</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>Type ?u.2574 → Type ?u.2573</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token">]
</span><span class="alectryon-token"><span class="kd">variable</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ma</var><b>: </b><span>m α</span></span></div></blockquote></div></small></div><span class="nv">ma</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ma'</var><b>: </b><span>m α</span></span></div></blockquote></div></small></div><span class="nv">ma&#39;</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>Type ?u.2585 → Type ?u.2584</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type ?u.2585</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token">)
</span><span class="alectryon-token"><span class="kd">variable</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Bool</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Bool</span><span class="alectryon-token">)

</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>example</var><b>: </b><span>∀ {m : Type u_1 → Type u_2} {α : Type u_1} [inst : Monad m] (ma : m α) [inst_1 : LawfulMonad m],
  (ExceptCpsT.runCatch do
      let x ← ExceptCpsT.lift ma
      throw x) =
    ma</span></span></div></blockquote></div></small></div><span class="kd">example</span></span><span class="alectryon-token"> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>LawfulMonad</var><b>: </b><span>(m : Type u_1 → Type u_2) → [inst : Monad m] → Prop</span></span></div></blockquote></div></small></div>LawfulMonad</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>Type u_1 → Type u_2</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token">] :
    (</span><span class="alectryon-token"><span class="k">do</span><span class="bp">&#39;</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">let</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> <span class="bp">←</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ma</var><b>: </b><span>m α</span></span></div></blockquote></div></small></div><span class="nv">ma</span></span><span class="alectryon-token"><span class="bp">;</span>
         </span><span class="alectryon-token"><span class="k">return</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token">)
    <span class="bp">=</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ma</var><b>: </b><span>m α</span></span></div></blockquote></div></small></div><span class="nv">ma</span></span><span class="alectryon-token">
:= </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Return-lean-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="Return-lean-chk0"><span class="alectryon-token"><span class="kd">by</span></span><span class="alectryon-token"></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">?</span>u.2639 <span class="bp">→</span> <span class="kt">Type</span> <span class="bp">?</span>u.2638</span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">?</span>u.2639</span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>ma, ma'</var><span class="hyp-type"><b>: </b><span>m α</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(ExceptCpsT.runCatch <span class="k">do</span>
    <span class="k">let</span> x <span class="bp">←</span> ExceptCpsT.lift ma
    throw x) <span class="bp">=</span>
  ma</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Return-lean-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="Return-lean-chk1"><span class="alectryon-token"><span class="k">simp</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">

</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>example</var><b>: </b><span>Id.run
    (ExceptCpsT.runCatch do
      let x ← ExceptCpsT.lift (pure 1)
      throw x) =
  1</span></span></div></blockquote></div></small></div><span class="kd">example</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Id.run</var><b>: </b><span>{α : Type} → Id α → α</span></span></div></blockquote></div></small></div><span class="k">Id.run</span></span><span class="alectryon-token">
    (</span><span class="alectryon-token"><span class="k">do</span><span class="bp">&#39;</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">let</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>1</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">1</span></span><span class="alectryon-token"><span class="bp">;</span> </span><span class="alectryon-token"><span class="k">return</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token">)</span><span class="alectryon-token">
    <span class="bp">=</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>1</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">1</span></span><span class="alectryon-token">
:= </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>rfl</var><b>: </b><span>∀ {α : Type} {a : α}, a = a</span></span></div></blockquote></div></small></div>rfl</span><span class="alectryon-token">

</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>example</var><b>: </b><span>∀ {m : Type → Type u_1} {α : Type} [inst : Monad m] (ma ma' : m α) (b : Bool) [inst_1 : LawfulMonad m],
  (ExceptCpsT.runCatch do
      if b = true then do
          let x ← ExceptCpsT.lift ma
          throw x
        else ExceptCpsT.lift (pure ())
      ExceptCpsT.lift ma') =
    if b = true then ma else ma'</span></span></div></blockquote></div></small></div><span class="kd">example</span></span><span class="alectryon-token"> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>LawfulMonad</var><b>: </b><span>(m : Type → Type u_1) → [inst : Monad m] → Prop</span></span></div></blockquote></div></small></div>LawfulMonad</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>Type → Type u_1</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token">] :
     (</span><span class="alectryon-token"><span class="k">do</span><span class="bp">&#39;</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">if</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">then</span></span><span class="alectryon-token"> {
            </span><span class="alectryon-token"><span class="k">let</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> <span class="bp">←</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ma</var><b>: </b><span>m α</span></span></div></blockquote></div></small></div><span class="nv">ma</span></span><span class="alectryon-token"><span class="bp">;</span>
            </span><span class="alectryon-token"><span class="k">return</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token">
          }<span class="bp">;</span>
          </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ma'</var><b>: </b><span>m α</span></span></div></blockquote></div></small></div><span class="nv">ma&#39;</span></span><span class="alectryon-token">)
     <span class="bp">=</span>
     (</span><span class="alectryon-token"><span class="k">if</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">then</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ma</var><b>: </b><span>m α</span></span></div></blockquote></div></small></div><span class="nv">ma</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">else</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ma'</var><b>: </b><span>m α</span></span></div></blockquote></div></small></div><span class="nv">ma&#39;</span></span><span class="alectryon-token">)
:= </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Return-lean-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="Return-lean-chk2"><span class="alectryon-token"><span class="kd">by</span></span><span class="alectryon-token"></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="bp">?</span>u.3364</span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>ma, ma'</var><span class="hyp-type"><b>: </b><span>m α</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(ExceptCpsT.runCatch <span class="k">do</span>
    <span class="k">if</span> b <span class="bp">=</span> true <span class="k">then</span> <span class="k">do</span>
        <span class="k">let</span> x <span class="bp">←</span> ExceptCpsT.lift ma
        throw x
      <span class="k">else</span> ExceptCpsT.lift (pure ())
    ExceptCpsT.lift ma&#39;) <span class="bp">=</span>
  <span class="k">if</span> b <span class="bp">=</span> true <span class="k">then</span> ma <span class="k">else</span> ma&#39;</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Return-lean-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="Return-lean-chk3"><span class="alectryon-token"><span class="k">cases</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div><span class="nv">b</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="bp">?</span>u.3364</span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>ma, ma'</var><span class="hyp-type"><b>: </b><span>m α</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">false</span></span><div class="goal-conclusion">(ExceptCpsT.runCatch <span class="k">do</span>
    <span class="k">if</span> false <span class="bp">=</span> true <span class="k">then</span> <span class="k">do</span>
        <span class="k">let</span> x <span class="bp">←</span> ExceptCpsT.lift ma
        throw x
      <span class="k">else</span> ExceptCpsT.lift (pure ())
    ExceptCpsT.lift ma&#39;) <span class="bp">=</span>
  <span class="k">if</span> false <span class="bp">=</span> true <span class="k">then</span> ma <span class="k">else</span> ma&#39;</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Return-lean-chk4" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="bp">?</span>u.3364</span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>ma, ma'</var><span class="hyp-type"><b>: </b><span>m α</span></span></span><br></div><label class="goal-separator" for="Return-lean-chk4"><hr><span class="goal-name">true</span></label><div class="goal-conclusion">(ExceptCpsT.runCatch <span class="k">do</span>
    <span class="k">if</span> true <span class="bp">=</span> true <span class="k">then</span> <span class="k">do</span>
        <span class="k">let</span> x <span class="bp">←</span> ExceptCpsT.lift ma
        throw x
      <span class="k">else</span> ExceptCpsT.lift (pure ())
    ExceptCpsT.lift ma&#39;) <span class="bp">=</span>
  <span class="k">if</span> true <span class="bp">=</span> true <span class="k">then</span> ma <span class="k">else</span> ma&#39;</div></blockquote></div></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Return-lean-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="Return-lean-chk5"><span class="alectryon-token"><span class="k">&lt;;&gt;</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="bp">?</span>u.3364</span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>ma, ma'</var><span class="hyp-type"><b>: </b><span>m α</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">false</span></span><div class="goal-conclusion">(ExceptCpsT.runCatch <span class="k">do</span>
    <span class="k">if</span> false <span class="bp">=</span> true <span class="k">then</span> <span class="k">do</span>
        <span class="k">let</span> x <span class="bp">←</span> ExceptCpsT.lift ma
        throw x
      <span class="k">else</span> ExceptCpsT.lift (pure ())
    ExceptCpsT.lift ma&#39;) <span class="bp">=</span>
  <span class="k">if</span> false <span class="bp">=</span> true <span class="k">then</span> ma <span class="k">else</span> ma&#39;</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Return-lean-chk6" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="bp">?</span>u.3364</span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>ma, ma'</var><span class="hyp-type"><b>: </b><span>m α</span></span></span><br></div><label class="goal-separator" for="Return-lean-chk6"><hr><span class="goal-name">true</span></label><div class="goal-conclusion">(ExceptCpsT.runCatch <span class="k">do</span>
    <span class="k">if</span> true <span class="bp">=</span> true <span class="k">then</span> <span class="k">do</span>
        <span class="k">let</span> x <span class="bp">←</span> ExceptCpsT.lift ma
        throw x
      <span class="k">else</span> ExceptCpsT.lift (pure ())
    ExceptCpsT.lift ma&#39;) <span class="bp">=</span>
  <span class="k">if</span> true <span class="bp">=</span> true <span class="k">then</span> ma <span class="k">else</span> ma&#39;</div></blockquote></div></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Return-lean-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="Return-lean-chk7"><span class="alectryon-token"><span class="k">simp</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">

</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>example</var><b>: </b><span>∀ {m : Type u_1 → Type u_2} {α : Type u_1} [inst : Monad m] (ma ma' : m α) (b : Bool) [inst_1 : LawfulMonad m],
  (ExceptCpsT.runCatch do
      let y ←
        if b = true then do
            let x ← ExceptCpsT.lift ma
            throw x
          else ExceptCpsT.lift ma'
      ExceptCpsT.lift (pure y)) =
    if b = true then ma else ma'</span></span></div></blockquote></div></small></div><span class="kd">example</span></span><span class="alectryon-token"> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>LawfulMonad</var><b>: </b><span>(m : Type u_1 → Type u_2) → [inst : Monad m] → Prop</span></span></div></blockquote></div></small></div>LawfulMonad</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>Type u_1 → Type u_2</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token">] :
    (</span><span class="alectryon-token"><span class="k">do</span><span class="bp">&#39;</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">let</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>y</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">y</span></span><span class="alectryon-token"> <span class="bp">←</span>
           </span><span class="alectryon-token"><span class="k">if</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">then</span></span><span class="alectryon-token"> {
             </span><span class="alectryon-token"><span class="k">let</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> <span class="bp">←</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ma</var><b>: </b><span>m α</span></span></div></blockquote></div></small></div><span class="nv">ma</span></span><span class="alectryon-token"><span class="bp">;</span>
             </span><span class="alectryon-token"><span class="k">return</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token">
           } </span><span class="alectryon-token"><span class="k">else</span></span><span class="alectryon-token"> {
             </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ma'</var><b>: </b><span>m α</span></span></div></blockquote></div></small></div><span class="nv">ma&#39;</span></span><span class="alectryon-token">
           }<span class="bp">;</span>
         </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>pure</var><b>: </b><span>{f : Type u_1 → Type u_2} → [self : Pure f] → {α : Type u_1} → α → f α</span></span></div></blockquote></div></small></div>pure</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>y</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">y</span></span><span class="alectryon-token">)
    <span class="bp">=</span>
    (</span><span class="alectryon-token"><span class="k">if</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">then</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ma</var><b>: </b><span>m α</span></span></div></blockquote></div></small></div><span class="nv">ma</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">else</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ma'</var><b>: </b><span>m α</span></span></div></blockquote></div></small></div><span class="nv">ma&#39;</span></span><span class="alectryon-token">)
:= </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Return-lean-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="Return-lean-chk8"><span class="alectryon-token"><span class="kd">by</span></span><span class="alectryon-token"></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">?</span>u.4867 <span class="bp">→</span> <span class="kt">Type</span> <span class="bp">?</span>u.4866</span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">?</span>u.4867</span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>ma, ma'</var><span class="hyp-type"><b>: </b><span>m α</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(ExceptCpsT.runCatch <span class="k">do</span>
    <span class="k">let</span> y <span class="bp">←</span>
      <span class="k">if</span> b <span class="bp">=</span> true <span class="k">then</span> <span class="k">do</span>
          <span class="k">let</span> x <span class="bp">←</span> ExceptCpsT.lift ma
          throw x
        <span class="k">else</span> ExceptCpsT.lift ma&#39;
    ExceptCpsT.lift (pure y)) <span class="bp">=</span>
  <span class="k">if</span> b <span class="bp">=</span> true <span class="k">then</span> ma <span class="k">else</span> ma&#39;</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Return-lean-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="Return-lean-chk9"><span class="alectryon-token"><span class="k">cases</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div><span class="nv">b</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">?</span>u.4867 <span class="bp">→</span> <span class="kt">Type</span> <span class="bp">?</span>u.4866</span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">?</span>u.4867</span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>ma, ma'</var><span class="hyp-type"><b>: </b><span>m α</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">false</span></span><div class="goal-conclusion">(ExceptCpsT.runCatch <span class="k">do</span>
    <span class="k">let</span> y <span class="bp">←</span>
      <span class="k">if</span> false <span class="bp">=</span> true <span class="k">then</span> <span class="k">do</span>
          <span class="k">let</span> x <span class="bp">←</span> ExceptCpsT.lift ma
          throw x
        <span class="k">else</span> ExceptCpsT.lift ma&#39;
    ExceptCpsT.lift (pure y)) <span class="bp">=</span>
  <span class="k">if</span> false <span class="bp">=</span> true <span class="k">then</span> ma <span class="k">else</span> ma&#39;</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Return-lean-chka" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">?</span>u.4867 <span class="bp">→</span> <span class="kt">Type</span> <span class="bp">?</span>u.4866</span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">?</span>u.4867</span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>ma, ma'</var><span class="hyp-type"><b>: </b><span>m α</span></span></span><br></div><label class="goal-separator" for="Return-lean-chka"><hr><span class="goal-name">true</span></label><div class="goal-conclusion">(ExceptCpsT.runCatch <span class="k">do</span>
    <span class="k">let</span> y <span class="bp">←</span>
      <span class="k">if</span> true <span class="bp">=</span> true <span class="k">then</span> <span class="k">do</span>
          <span class="k">let</span> x <span class="bp">←</span> ExceptCpsT.lift ma
          throw x
        <span class="k">else</span> ExceptCpsT.lift ma&#39;
    ExceptCpsT.lift (pure y)) <span class="bp">=</span>
  <span class="k">if</span> true <span class="bp">=</span> true <span class="k">then</span> ma <span class="k">else</span> ma&#39;</div></blockquote></div></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Return-lean-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="Return-lean-chkb"><span class="alectryon-token"><span class="k">&lt;;&gt;</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">?</span>u.4867 <span class="bp">→</span> <span class="kt">Type</span> <span class="bp">?</span>u.4866</span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">?</span>u.4867</span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>ma, ma'</var><span class="hyp-type"><b>: </b><span>m α</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">false</span></span><div class="goal-conclusion">(ExceptCpsT.runCatch <span class="k">do</span>
    <span class="k">let</span> y <span class="bp">←</span>
      <span class="k">if</span> false <span class="bp">=</span> true <span class="k">then</span> <span class="k">do</span>
          <span class="k">let</span> x <span class="bp">←</span> ExceptCpsT.lift ma
          throw x
        <span class="k">else</span> ExceptCpsT.lift ma&#39;
    ExceptCpsT.lift (pure y)) <span class="bp">=</span>
  <span class="k">if</span> false <span class="bp">=</span> true <span class="k">then</span> ma <span class="k">else</span> ma&#39;</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Return-lean-chkc" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">?</span>u.4867 <span class="bp">→</span> <span class="kt">Type</span> <span class="bp">?</span>u.4866</span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">?</span>u.4867</span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>ma, ma'</var><span class="hyp-type"><b>: </b><span>m α</span></span></span><br></div><label class="goal-separator" for="Return-lean-chkc"><hr><span class="goal-name">true</span></label><div class="goal-conclusion">(ExceptCpsT.runCatch <span class="k">do</span>
    <span class="k">let</span> y <span class="bp">←</span>
      <span class="k">if</span> true <span class="bp">=</span> true <span class="k">then</span> <span class="k">do</span>
          <span class="k">let</span> x <span class="bp">←</span> ExceptCpsT.lift ma
          throw x
        <span class="k">else</span> ExceptCpsT.lift ma&#39;
    ExceptCpsT.lift (pure y)) <span class="bp">=</span>
  <span class="k">if</span> true <span class="bp">=</span> true <span class="k">then</span> ma <span class="k">else</span> ma&#39;</div></blockquote></div></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Return-lean-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="Return-lean-chkd"><span class="alectryon-token"><span class="k">simp</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span></pre><div style="break-before: page; page-break-before: always;"></div><pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kn">import</span> Do.Return</span></span></pre>
<h1 id="iteration"><a class="header" href="#iteration">Iteration</a></h1>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kn">open</span></span><span class="alectryon-token"> Lean

<span class="c">/-</span><span class="cm"> Disable the automatic monadic lifting feature described in the paper.</span>
<span class="cm">   We want to make it clear that we do not depend on it. -/</span>
</span><span class="alectryon-token"><span class="kd">set_option</span></span><span class="alectryon-token"> autoLift </span><span class="alectryon-token"><span class="k">false</span></span><span class="alectryon-token">

</span><span class="alectryon-token"><span class="k">syntax</span></span><span class="alectryon-token"> <span class="s2">&quot;for&quot;</span> ident <span class="s2">&quot;in&quot;</span> term <span class="s2">&quot;do&#39;&quot;</span> stmt:<span class="mi">1</span> : stmt
</span><span class="alectryon-token"><span class="k">syntax</span></span><span class="alectryon-token"> <span class="s2">&quot;break &quot;</span> : stmt
</span><span class="alectryon-token"><span class="k">syntax</span></span><span class="alectryon-token"> <span class="s2">&quot;continue &quot;</span> : stmt

</span><span class="alectryon-token"><span class="k">syntax</span></span><span class="alectryon-token"> <span class="s2">&quot;break&quot;</span> : expander
</span><span class="alectryon-token"><span class="k">syntax</span></span><span class="alectryon-token"> <span class="s2">&quot;continue&quot;</span> : expander
</span><span class="alectryon-token"><span class="k">syntax</span></span><span class="alectryon-token"> <span class="s2">&quot;lift&quot;</span> : expander

</span><span class="alectryon-token"><span class="k">macro_rules</span></span><span class="alectryon-token">
  <span class="bp">|</span> <span class="bp">`</span>(stmt<span class="bp">|</span> </span><span class="alectryon-token">expand<span class="bp">!</span></span><span class="alectryon-token"> <span class="bp">$</span>_   </span><span class="alectryon-token"><span class="k">in</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">break</span></span><span class="alectryon-token">) <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>`(stmt| break)</var><b>: </b><span>MacroM Syntax</span></span></div></blockquote></div></small></div><span class="bp">`</span>(stmt<span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>`(stmt| break)</var><b>: </b><span>MacroM Syntax</span></span></div></blockquote></div></small></div><span class="k">break</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>`(stmt| break)</var><b>: </b><span>MacroM Syntax</span></span></div></blockquote></div></small></div>)</span><span class="alectryon-token">                                              <span class="c1">-- subsumes (S7, R7, B2, L1)</span>
  <span class="bp">|</span> <span class="bp">`</span>(stmt<span class="bp">|</span> </span><span class="alectryon-token">expand<span class="bp">!</span></span><span class="alectryon-token"> <span class="bp">$</span>_   </span><span class="alectryon-token"><span class="k">in</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">continue</span></span><span class="alectryon-token">) <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>`(stmt| continue)</var><b>: </b><span>MacroM Syntax</span></span></div></blockquote></div></small></div><span class="bp">`</span>(stmt<span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>`(stmt| continue)</var><b>: </b><span>MacroM Syntax</span></span></div></blockquote></div></small></div><span class="k">continue</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>`(stmt| continue)</var><b>: </b><span>MacroM Syntax</span></span></div></blockquote></div></small></div>)</span><span class="alectryon-token">                                        <span class="c1">-- subsumes (S8, R8, L2)</span>
  <span class="bp">|</span> <span class="bp">`</span>(stmt<span class="bp">|</span> </span><span class="alectryon-token">expand<span class="bp">!</span></span><span class="alectryon-token"> <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>exp</var><b>: </b><span>TSyntax `expander</span></span></div></blockquote></div></small></div><span class="nv">exp</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">in</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">for</span></span><span class="alectryon-token"> <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>TSyntax `ident</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">in</span></span><span class="alectryon-token"> <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>TSyntax `term</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">do</span><span class="bp">&#39;</span></span><span class="alectryon-token"> <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>TSyntax `stmt</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token">) <span class="bp">=&gt;</span> <span class="bp">`</span>(stmt<span class="bp">|</span> </span><span class="alectryon-token"><span class="k">for</span></span><span class="alectryon-token"> <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>TSyntax `ident</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">in</span></span><span class="alectryon-token"> <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>TSyntax `term</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">do</span><span class="bp">&#39;</span></span><span class="alectryon-token"> </span><span class="alectryon-token">expand<span class="bp">!</span></span><span class="alectryon-token"> <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>exp</var><b>: </b><span>TSyntax `expander</span></span></div></blockquote></div></small></div><span class="nv">exp</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">in</span></span><span class="alectryon-token"> <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>TSyntax `stmt</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token">)</span><span class="alectryon-token">  <span class="c1">-- subsumes (L8, R9)</span>

</span><span class="alectryon-token"><span class="k">macro_rules</span></span><span class="alectryon-token">
  <span class="bp">|</span> <span class="bp">`</span>(</span><span class="alectryon-token">d<span class="bp">!</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">for</span></span><span class="alectryon-token"> <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>TSyntax `ident</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">in</span></span><span class="alectryon-token"> <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>TSyntax `term</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">do</span><span class="bp">&#39;</span></span><span class="alectryon-token"> <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>TSyntax `stmt</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token">) <span class="bp">=&gt;</span> </span><span class="alectryon-token"><span class="k">do</span></span><span class="alectryon-token">  <span class="c1">-- (D5), optimized like (1&#39;)</span>
    </span><span class="alectryon-token"><span class="k">let</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">mut</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>TSyntax `stmt</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token"> := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>TSyntax `stmt</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token">
    </span><span class="alectryon-token"><span class="k">let</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>sb</var><b>: </b><span>TSyntax `stmt</span></span></div></blockquote></div></small></div><span class="nv">sb</span></span><span class="alectryon-token"> <span class="bp">←</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>expandStmt</var><b>: </b><span>TSyntax `stmt → MacroM (TSyntax `stmt)</span></span></div></blockquote></div></small></div><span class="k">expandStmt</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>(← `(stmt| expand! break in $s))</var><b>: </b><span>TSyntax `stmt</span></span></div></blockquote></div></small></div>(<span class="bp">←</span> <span class="bp">`</span>(stmt<span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>(← `(stmt| expand! break in $s))</var><b>: </b><span>TSyntax `stmt</span></span></div></blockquote></div></small></div>expand<span class="bp">!</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>(← `(stmt| expand! break in $s))</var><b>: </b><span>TSyntax `stmt</span></span></div></blockquote></div></small></div> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>(← `(stmt| expand! break in $s))</var><b>: </b><span>TSyntax `stmt</span></span></div></blockquote></div></small></div><span class="k">break</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>(← `(stmt| expand! break in $s))</var><b>: </b><span>TSyntax `stmt</span></span></div></blockquote></div></small></div> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>(← `(stmt| expand! break in $s))</var><b>: </b><span>TSyntax `stmt</span></span></div></blockquote></div></small></div><span class="k">in</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>(← `(stmt| expand! break in $s))</var><b>: </b><span>TSyntax `stmt</span></span></div></blockquote></div></small></div> <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>TSyntax `stmt</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>(← `(stmt| expand! break in $s))</var><b>: </b><span>TSyntax `stmt</span></span></div></blockquote></div></small></div>))</span><span class="alectryon-token">
    </span><span class="alectryon-token"><span class="k">let</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>hasBreak</var><b>: </b><span>Prop</span></span></div></blockquote></div></small></div><span class="nv">hasBreak</span></span><span class="alectryon-token"> := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>sb</var><b>: </b><span>TSyntax `stmt</span></span></div></blockquote></div></small></div><span class="nv">sb</span></span><span class="alectryon-token"><span class="k">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>raw</var><b>: </b><span>{ks : SyntaxNodeKinds} → TSyntax ks → Syntax</span></span></div></blockquote></div></small></div><span class="k">raw</span></span><span class="alectryon-token"><span class="k">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>count</var><b>: </b><span>Syntax → (Syntax → Bool) → Nat</span></span></div></blockquote></div></small></div><span class="k">count</span></span><span class="alectryon-token"> (<span class="bp">·</span> </span><span class="alectryon-token"><span class="k">matches</span></span><span class="alectryon-token"> <span class="bp">`</span>(stmt<span class="bp">|</span> </span><span class="alectryon-token"><span class="k">break</span></span><span class="alectryon-token">)) <span class="bp">&lt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>TSyntax `stmt</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token"><span class="k">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>raw</var><b>: </b><span>{ks : SyntaxNodeKinds} → TSyntax ks → Syntax</span></span></div></blockquote></div></small></div><span class="k">raw</span></span><span class="alectryon-token"><span class="k">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>count</var><b>: </b><span>Syntax → (Syntax → Bool) → Nat</span></span></div></blockquote></div></small></div><span class="k">count</span></span><span class="alectryon-token"> (<span class="bp">·</span> </span><span class="alectryon-token"><span class="k">matches</span></span><span class="alectryon-token"> <span class="bp">`</span>(stmt<span class="bp">|</span> </span><span class="alectryon-token"><span class="k">break</span></span><span class="alectryon-token">))
    </span><span class="alectryon-token"><span class="k">if</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>hasBreak</var><b>: </b><span>Prop</span></span></div></blockquote></div></small></div><span class="nv">hasBreak</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">then</span></span><span class="alectryon-token">
      </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>TSyntax `stmt</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token"> := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>sb</var><b>: </b><span>TSyntax `stmt</span></span></div></blockquote></div></small></div><span class="nv">sb</span></span><span class="alectryon-token">
    </span><span class="alectryon-token"><span class="k">let</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>sc</var><b>: </b><span>TSyntax `stmt</span></span></div></blockquote></div></small></div><span class="nv">sc</span></span><span class="alectryon-token"> <span class="bp">←</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>expandStmt</var><b>: </b><span>TSyntax `stmt → MacroM (TSyntax `stmt)</span></span></div></blockquote></div></small></div><span class="k">expandStmt</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>(← `(stmt| expand! continue in $s))</var><b>: </b><span>TSyntax `stmt</span></span></div></blockquote></div></small></div>(<span class="bp">←</span> <span class="bp">`</span>(stmt<span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>(← `(stmt| expand! continue in $s))</var><b>: </b><span>TSyntax `stmt</span></span></div></blockquote></div></small></div>expand<span class="bp">!</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>(← `(stmt| expand! continue in $s))</var><b>: </b><span>TSyntax `stmt</span></span></div></blockquote></div></small></div> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>(← `(stmt| expand! continue in $s))</var><b>: </b><span>TSyntax `stmt</span></span></div></blockquote></div></small></div><span class="k">continue</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>(← `(stmt| expand! continue in $s))</var><b>: </b><span>TSyntax `stmt</span></span></div></blockquote></div></small></div> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>(← `(stmt| expand! continue in $s))</var><b>: </b><span>TSyntax `stmt</span></span></div></blockquote></div></small></div><span class="k">in</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>(← `(stmt| expand! continue in $s))</var><b>: </b><span>TSyntax `stmt</span></span></div></blockquote></div></small></div> <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>TSyntax `stmt</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>(← `(stmt| expand! continue in $s))</var><b>: </b><span>TSyntax `stmt</span></span></div></blockquote></div></small></div>))</span><span class="alectryon-token">
    </span><span class="alectryon-token"><span class="k">let</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>hasContinue</var><b>: </b><span>Prop</span></span></div></blockquote></div></small></div><span class="nv">hasContinue</span></span><span class="alectryon-token"> := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>sc</var><b>: </b><span>TSyntax `stmt</span></span></div></blockquote></div></small></div><span class="nv">sc</span></span><span class="alectryon-token"><span class="k">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>raw</var><b>: </b><span>{ks : SyntaxNodeKinds} → TSyntax ks → Syntax</span></span></div></blockquote></div></small></div><span class="k">raw</span></span><span class="alectryon-token"><span class="k">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>count</var><b>: </b><span>Syntax → (Syntax → Bool) → Nat</span></span></div></blockquote></div></small></div><span class="k">count</span></span><span class="alectryon-token"> (<span class="bp">·</span> </span><span class="alectryon-token"><span class="k">matches</span></span><span class="alectryon-token"> <span class="bp">`</span>(stmt<span class="bp">|</span> </span><span class="alectryon-token"><span class="k">continue</span></span><span class="alectryon-token">)) <span class="bp">&lt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>TSyntax `stmt</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token"><span class="k">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>raw</var><b>: </b><span>{ks : SyntaxNodeKinds} → TSyntax ks → Syntax</span></span></div></blockquote></div></small></div><span class="k">raw</span></span><span class="alectryon-token"><span class="k">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>count</var><b>: </b><span>Syntax → (Syntax → Bool) → Nat</span></span></div></blockquote></div></small></div><span class="k">count</span></span><span class="alectryon-token"> (<span class="bp">·</span> </span><span class="alectryon-token"><span class="k">matches</span></span><span class="alectryon-token"> <span class="bp">`</span>(stmt<span class="bp">|</span> </span><span class="alectryon-token"><span class="k">continue</span></span><span class="alectryon-token">))
    </span><span class="alectryon-token"><span class="k">if</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>hasContinue</var><b>: </b><span>Prop</span></span></div></blockquote></div></small></div><span class="nv">hasContinue</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">then</span></span><span class="alectryon-token">
      </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>TSyntax `stmt</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token"> := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>sc</var><b>: </b><span>TSyntax `stmt</span></span></div></blockquote></div></small></div><span class="nv">sc</span></span><span class="alectryon-token">
    </span><span class="alectryon-token"><span class="k">let</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">mut</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>body</var><b>: </b><span>TSyntax `term</span></span></div></blockquote></div></small></div><span class="nv">body</span></span><span class="alectryon-token"> <span class="bp">←</span> <span class="bp">`</span>(</span><span class="alectryon-token">d<span class="bp">!</span></span><span class="alectryon-token"> <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>TSyntax `stmt</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token">)
    </span><span class="alectryon-token"><span class="k">if</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>hasContinue</var><b>: </b><span>Prop</span></span></div></blockquote></div></small></div><span class="nv">hasContinue</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">then</span></span><span class="alectryon-token">
      </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>body</var><b>: </b><span>TSyntax `term</span></span></div></blockquote></div></small></div><span class="nv">body</span></span><span class="alectryon-token"> <span class="bp">←</span> <span class="bp">`</span>(ExceptCpsT.runCatch <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>body</var><b>: </b><span>TSyntax `term</span></span></div></blockquote></div></small></div><span class="nv">body</span></span><span class="alectryon-token">)
    </span><span class="alectryon-token"><span class="k">let</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">mut</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>loop</var><b>: </b><span>TSyntax `term</span></span></div></blockquote></div></small></div><span class="nv">loop</span></span><span class="alectryon-token"> <span class="bp">←</span> <span class="bp">`</span>(forM <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>TSyntax `term</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><span class="k">fun</span></span><span class="alectryon-token"> <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>TSyntax `ident</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>body</var><b>: </b><span>TSyntax `term</span></span></div></blockquote></div></small></div><span class="nv">body</span></span><span class="alectryon-token">))
    </span><span class="alectryon-token"><span class="k">if</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>hasBreak</var><b>: </b><span>Prop</span></span></div></blockquote></div></small></div><span class="nv">hasBreak</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">then</span></span><span class="alectryon-token">
      </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>loop</var><b>: </b><span>TSyntax `term</span></span></div></blockquote></div></small></div><span class="nv">loop</span></span><span class="alectryon-token"> <span class="bp">←</span> <span class="bp">`</span>(ExceptCpsT.runCatch <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>loop</var><b>: </b><span>TSyntax `term</span></span></div></blockquote></div></small></div><span class="nv">loop</span></span><span class="alectryon-token">)
    </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>pure</var><b>: </b><span>{f : Type → Type} → [self : Pure f] → {α : Type} → α → f α</span></span></div></blockquote></div></small></div><span class="k">pure</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>loop</var><b>: </b><span>TSyntax `term</span></span></div></blockquote></div></small></div><span class="nv">loop</span></span><span class="alectryon-token">
  <span class="bp">|</span> <span class="bp">`</span>(</span><span class="alectryon-token">d<span class="bp">!</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">break</span></span><span class="alectryon-token"><span class="k">%$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>Syntax</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token">) <span class="bp">=&gt;</span>
    </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>throw</var><b>: </b><span>{ε : Type} → {m : Type → Type} → [self : MonadExcept ε m] → {α : Type} → ε → m α</span></span></div></blockquote></div></small></div><span class="k">throw</span></span><span class="alectryon-token"> <span class="bp">&lt;|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Macro.Exception.error</var><b>: </b><span>Syntax → String → Macro.Exception</span></span></div></blockquote></div></small></div><span class="k">Macro.Exception.error</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>Syntax</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>&quot;unexpected 'break' outside loop&quot;</var><b>: </b><span>String</span></span></div></blockquote></div></small></div><span class="s2">&quot;unexpected &#39;break&#39; outside loop&quot;</span></span><span class="alectryon-token">
  <span class="bp">|</span> <span class="bp">`</span>(</span><span class="alectryon-token">d<span class="bp">!</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">continue</span></span><span class="alectryon-token"><span class="k">%$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>c</var><b>: </b><span>Syntax</span></span></div></blockquote></div></small></div><span class="nv">c</span></span><span class="alectryon-token">) <span class="bp">=&gt;</span>
    </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>throw</var><b>: </b><span>{ε : Type} → {m : Type → Type} → [self : MonadExcept ε m] → {α : Type} → ε → m α</span></span></div></blockquote></div></small></div><span class="k">throw</span></span><span class="alectryon-token"> <span class="bp">&lt;|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Macro.Exception.error</var><b>: </b><span>Syntax → String → Macro.Exception</span></span></div></blockquote></div></small></div><span class="k">Macro.Exception.error</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>c</var><b>: </b><span>Syntax</span></span></div></blockquote></div></small></div><span class="nv">c</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>&quot;unexpected 'continue' outside loop&quot;</var><b>: </b><span>String</span></span></div></blockquote></div></small></div><span class="s2">&quot;unexpected &#39;continue&#39; outside loop&quot;</span></span><span class="alectryon-token">

</span><span class="alectryon-token"><span class="k">macro_rules</span></span><span class="alectryon-token">
  <span class="bp">|</span> <span class="bp">`</span>(stmt<span class="bp">|</span> </span><span class="alectryon-token">expand<span class="bp">!</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">break</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">in</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">break</span></span><span class="alectryon-token">) <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>`(stmt| throw ())</var><b>: </b><span>MacroM Syntax</span></span></div></blockquote></div></small></div><span class="bp">`</span>(stmt<span class="bp">|</span> throw ())</span><span class="alectryon-token">                                           <span class="c1">-- (B1)</span>
  <span class="bp">|</span> <span class="bp">`</span>(stmt<span class="bp">|</span> </span><span class="alectryon-token">expand<span class="bp">!</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">break</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">in</span></span><span class="alectryon-token"> <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>TSyntax `term</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token">:term) <span class="bp">=&gt;</span> <span class="bp">`</span>(stmt<span class="bp">|</span> ExceptCpsT.lift <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>TSyntax `term</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token">)                               <span class="c1">-- (B3)</span>
  <span class="bp">|</span> <span class="bp">`</span>(stmt<span class="bp">|</span> </span><span class="alectryon-token">expand<span class="bp">!</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">break</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">in</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">for</span></span><span class="alectryon-token"> <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>TSyntax `ident</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">in</span></span><span class="alectryon-token"> <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>TSyntax `term</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">do</span><span class="bp">&#39;</span></span><span class="alectryon-token"> <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>TSyntax `stmt</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token">) <span class="bp">=&gt;</span> <span class="bp">`</span>(stmt<span class="bp">|</span> </span><span class="alectryon-token"><span class="k">for</span></span><span class="alectryon-token"> <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>TSyntax `ident</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">in</span></span><span class="alectryon-token"> <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>TSyntax `term</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">do</span><span class="bp">&#39;</span></span><span class="alectryon-token"> </span><span class="alectryon-token">expand<span class="bp">!</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">lift</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">in</span></span><span class="alectryon-token"> <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>TSyntax `stmt</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token">)  <span class="c1">-- (B8)</span>
  <span class="bp">|</span> <span class="bp">`</span>(stmt<span class="bp">|</span> </span><span class="alectryon-token">expand<span class="bp">!</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">continue</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">in</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">continue</span></span><span class="alectryon-token">) <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>`(stmt| throw ())</var><b>: </b><span>MacroM Syntax</span></span></div></blockquote></div></small></div><span class="bp">`</span>(stmt<span class="bp">|</span> throw ())</span><span class="alectryon-token">
  <span class="bp">|</span> <span class="bp">`</span>(stmt<span class="bp">|</span> </span><span class="alectryon-token">expand<span class="bp">!</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">continue</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">in</span></span><span class="alectryon-token"> <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>TSyntax `term</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token">:term) <span class="bp">=&gt;</span> <span class="bp">`</span>(stmt<span class="bp">|</span> ExceptCpsT.lift <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>TSyntax `term</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token">)
  <span class="bp">|</span> <span class="bp">`</span>(stmt<span class="bp">|</span> </span><span class="alectryon-token">expand<span class="bp">!</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">continue</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">in</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">for</span></span><span class="alectryon-token"> <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>TSyntax `ident</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">in</span></span><span class="alectryon-token"> <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>TSyntax `term</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">do</span><span class="bp">&#39;</span></span><span class="alectryon-token"> <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>TSyntax `stmt</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token">) <span class="bp">=&gt;</span> <span class="bp">`</span>(stmt<span class="bp">|</span> </span><span class="alectryon-token"><span class="k">for</span></span><span class="alectryon-token"> <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>TSyntax `ident</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">in</span></span><span class="alectryon-token"> <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>TSyntax `term</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">do</span><span class="bp">&#39;</span></span><span class="alectryon-token"> </span><span class="alectryon-token">expand<span class="bp">!</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">lift</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">in</span></span><span class="alectryon-token"> <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>TSyntax `stmt</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token">)</span><span class="alectryon-token">

</span><span class="alectryon-token"><span class="k">macro_rules</span></span><span class="alectryon-token">
  <span class="bp">|</span> <span class="bp">`</span>(stmt<span class="bp">|</span> </span><span class="alectryon-token">expand<span class="bp">!</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">lift</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">in</span></span><span class="alectryon-token"> <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>TSyntax `term</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token">:term) <span class="bp">=&gt;</span> <span class="bp">`</span>(stmt<span class="bp">|</span> ExceptCpsT.lift <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>TSyntax `term</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token">)</span><span class="alectryon-token">  <span class="c1">-- (L3)</span>

</span><span class="alectryon-token"><span class="k">macro_rules</span></span><span class="alectryon-token">
  <span class="bp">|</span> <span class="bp">`</span>(stmt<span class="bp">|</span> </span><span class="alectryon-token">expand<span class="bp">!</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">mut</span></span><span class="alectryon-token"> <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>y</var><b>: </b><span>TSyntax `ident</span></span></div></blockquote></div></small></div><span class="nv">y</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">in</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">for</span></span><span class="alectryon-token"> <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>TSyntax `ident</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">in</span></span><span class="alectryon-token"> <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>TSyntax `term</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">do</span><span class="bp">&#39;</span></span><span class="alectryon-token"> <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>TSyntax `stmt</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token">) <span class="bp">=&gt;</span> <span class="bp">`</span>(stmt<span class="bp">|</span> </span><span class="alectryon-token"><span class="k">for</span></span><span class="alectryon-token"> <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>TSyntax `ident</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">in</span></span><span class="alectryon-token"> <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>TSyntax `term</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">do</span><span class="bp">&#39;</span></span><span class="alectryon-token"> { </span><span class="alectryon-token"><span class="k">let</span></span><span class="alectryon-token"> <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>y</var><b>: </b><span>TSyntax `ident</span></span></div></blockquote></div></small></div><span class="nv">y</span></span><span class="alectryon-token"> <span class="bp">←</span> get<span class="bp">;</span> </span><span class="alectryon-token">expand<span class="bp">!</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">mut</span></span><span class="alectryon-token"> <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>y</var><b>: </b><span>TSyntax `ident</span></span></div></blockquote></div></small></div><span class="nv">y</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">in</span></span><span class="alectryon-token"> <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>TSyntax `stmt</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token"> })</span><span class="alectryon-token">  <span class="c1">-- (S9)</span>

</span><span class="alectryon-token"><span class="kd">variable</span></span><span class="alectryon-token"> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Monad</var><b>: </b><span>(Type ?u.36846 → Type ?u.36845) → Type (max (?u.36846 + 1) ?u.36845)</span></span></div></blockquote></div></small></div>Monad</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>Type ?u.7311 → Type ?u.7310</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token">]
</span><span class="alectryon-token"><span class="kd">variable</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ma</var><b>: </b><span>m α</span></span></div></blockquote></div></small></div><span class="nv">ma</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ma'</var><b>: </b><span>m α</span></span></div></blockquote></div></small></div><span class="nv">ma&#39;</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>Type ?u.7322 → Type ?u.7321</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token">)
</span><span class="alectryon-token"><span class="kd">variable</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Bool</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Bool</span><span class="alectryon-token">)
</span><span class="alectryon-token"><span class="kd">variable</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>xs</var><b>: </b><span>List α</span></span></div></blockquote></div></small></div><span class="nv">xs</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>List</var><b>: </b><span>Type → Type</span></span></div></blockquote></div></small></div>List</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token">) (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>act</var><b>: </b><span>α → m Unit</span></span></div></blockquote></div></small></div><span class="nv">act</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>Type → Type u_1</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Unit</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Unit</span><span class="alectryon-token">)

</span><span class="alectryon-token"><span class="kn">attribute</span></span><span class="alectryon-token"> [</span><span class="alectryon-token"><span class="kn">local</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">simp</span></span><span class="alectryon-token">] </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>map_eq_pure_bind</var><b>: </b><span>∀ {m : Type u_1 → Type u_2} {α β : Type u_1} [inst : Monad m] [inst_1 : LawfulMonad m] (f : α → β) (x : m α),
  f &lt;$&gt; x = do
    let a ← x
    pure (f a)</span></span></div></blockquote></div></small></div>map_eq_pure_bind</span><span class="alectryon-token">

</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>example</var><b>: </b><span>∀ {m : Type → Type u_1} {α : Type} [inst : Monad m] (xs : List α) (act : α → m Unit) [inst_1 : LawfulMonad m],
  (forM xs fun x =&gt; act x) = List.forM xs act</span></span></div></blockquote></div></small></div><span class="kd">example</span></span><span class="alectryon-token"> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>LawfulMonad</var><b>: </b><span>(m : Type → Type u_1) → [inst : Monad m] → Prop</span></span></div></blockquote></div></small></div>LawfulMonad</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>Type → Type u_1</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token">] :
    (</span><span class="alectryon-token"><span class="k">do</span><span class="bp">&#39;</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">for</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">in</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>xs</var><b>: </b><span>List α</span></span></div></blockquote></div></small></div><span class="nv">xs</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">do</span><span class="bp">&#39;</span></span><span class="alectryon-token"> {
           </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>act</var><b>: </b><span>α → m Unit</span></span></div></blockquote></div></small></div><span class="nv">act</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token">
         })
    <span class="bp">=</span>
    </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>xs</var><b>: </b><span>List α</span></span></div></blockquote></div></small></div><span class="nv">xs</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>forM</var><b>: </b><span>{m : Type → Type u_1} → [inst : Monad m] → {α : Type} → List α → (α → m PUnit) → m PUnit</span></span></div></blockquote></div></small></div>forM</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>act</var><b>: </b><span>α → m Unit</span></span></div></blockquote></div></small></div><span class="nv">act</span></span><span class="alectryon-token">
:= </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="For-lean-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="For-lean-chk0"><span class="alectryon-token"><span class="kd">by</span></span><span class="alectryon-token"></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="bp">?</span>u.7430</span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>ma, ma'</var><span class="hyp-type"><b>: </b><span>m α</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>List α</span></span></span><br><span><var>act</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> m Unit</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(forM xs <span class="k">fun</span> x <span class="bp">=&gt;</span> act x) <span class="bp">=</span> List.forM xs act</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="For-lean-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="For-lean-chk1"><span class="alectryon-token"><span class="k">induction</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>xs</var><b>: </b><span>List α</span></span></div></blockquote></div></small></div><span class="nv">xs</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="bp">?</span>u.7430</span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>ma, ma'</var><span class="hyp-type"><b>: </b><span>m α</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>List α</span></span></span><br><span><var>act</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> m Unit</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">nil</span></span><div class="goal-conclusion">(forM [] <span class="k">fun</span> x <span class="bp">=&gt;</span> act x) <span class="bp">=</span> List.forM [] act</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="For-lean-chk2" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="bp">?</span>u.7430</span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>ma, ma'</var><span class="hyp-type"><b>: </b><span>m α</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>List α</span></span></span><br><span><var>act</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> m Unit</span></span></span><br><span><var>head✝</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br><span><var>tail✝</var><span class="hyp-type"><b>: </b><span>List α</span></span></span><br></div><label class="goal-separator" for="For-lean-chk2"><hr><span class="goal-name">cons</span></label><div class="goal-conclusion">(forM (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) <span class="k">fun</span> x <span class="bp">=&gt;</span> act x) <span class="bp">=</span> List.forM (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) act</div></blockquote></div></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="For-lean-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="For-lean-chk3"><span class="alectryon-token"><span class="k">&lt;;&gt;</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="bp">?</span>u.7430</span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>ma, ma'</var><span class="hyp-type"><b>: </b><span>m α</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>List α</span></span></span><br><span><var>act</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> m Unit</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">nil</span></span><div class="goal-conclusion">(forM [] <span class="k">fun</span> x <span class="bp">=&gt;</span> act x) <span class="bp">=</span> List.forM [] act</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="For-lean-chk4" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="bp">?</span>u.7430</span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>ma, ma'</var><span class="hyp-type"><b>: </b><span>m α</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>List α</span></span></span><br><span><var>act</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> m Unit</span></span></span><br><span><var>head✝</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br><span><var>tail✝</var><span class="hyp-type"><b>: </b><span>List α</span></span></span><br></div><label class="goal-separator" for="For-lean-chk4"><hr><span class="goal-name">cons</span></label><div class="goal-conclusion">(forM (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) <span class="k">fun</span> x <span class="bp">=&gt;</span> act x) <span class="bp">=</span> List.forM (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) act</div></blockquote></div></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="For-lean-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="For-lean-chk5"><span class="alectryon-token">simp_all<span class="bp">!</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">

</span><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ex2</var><b>: </b><span>{β : Type} → (β → α → m β) → β → List α → m β</span></span></div></blockquote></div></small></div><span class="nv">ex2</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>β → α → m β</span></span></div></blockquote></div></small></div><span class="nv">f</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>β</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">β</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>Type → Type u_1</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>β</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">β</span></span><span class="alectryon-token">) (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>init</var><b>: </b><span>β</span></span></div></blockquote></div></small></div><span class="nv">init</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>β</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">β</span></span><span class="alectryon-token">) (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>xs</var><b>: </b><span>List α</span></span></div></blockquote></div></small></div><span class="nv">xs</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>List</var><b>: </b><span>Type → Type</span></span></div></blockquote></div></small></div>List</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token">) : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>Type → Type u_1</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>β</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">β</span></span><span class="alectryon-token"> := </span><span class="alectryon-token"><span class="k">do</span><span class="bp">&#39;</span></span><span class="alectryon-token">
  </span><span class="alectryon-token"><span class="k">let</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">mut</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>y</var><b>: </b><span>β</span></span></div></blockquote></div></small></div><span class="nv">y</span></span><span class="alectryon-token"> := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>init</var><b>: </b><span>β</span></span></div></blockquote></div></small></div><span class="nv">init</span></span><span class="alectryon-token"><span class="bp">;</span>
  </span><span class="alectryon-token"><span class="k">for</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">in</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>xs</var><b>: </b><span>List α</span></span></div></blockquote></div></small></div><span class="nv">xs</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">do</span><span class="bp">&#39;</span></span><span class="alectryon-token"> {
    y <span class="bp">←</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>β → α → m β</span></span></div></blockquote></div></small></div><span class="nv">f</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>y</var><b>: </b><span>β</span></span></div></blockquote></div></small></div><span class="nv">y</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token">
  }<span class="bp">;</span>
  </span><span class="alectryon-token"><span class="k">return</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>y</var><b>: </b><span>β</span></span></div></blockquote></div></small></div><span class="nv">y</span></span><span class="alectryon-token">

</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>example</var><b>: </b><span>∀ {m : Type → Type u_1} {α : Type} [inst : Monad m] (xs : List α) {β : Type} {init : β} [inst_1 : LawfulMonad m]
  (f : β → α → m β), ex2 f init xs = List.foldlM f init xs</span></span></div></blockquote></div></small></div><span class="kd">example</span></span><span class="alectryon-token"> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>LawfulMonad</var><b>: </b><span>(m : Type ?u.8985 → Type ?u.8984) → [inst : Monad m] → Prop</span></span></div></blockquote></div></small></div>LawfulMonad</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>Type → Type u_1</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token">] (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>β → α → m β</span></span></div></blockquote></div></small></div><span class="nv">f</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>β</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">β</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>Type → Type u_1</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>β</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">β</span></span><span class="alectryon-token">) :
    </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ex2</var><b>: </b><span>{m : Type → Type u_1} → {α : Type} → [inst : Monad m] → {β : Type} → (β → α → m β) → β → List α → m β</span></span></div></blockquote></div></small></div>ex2</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>β → α → m β</span></span></div></blockquote></div></small></div><span class="nv">f</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>init</var><b>: </b><span>β</span></span></div></blockquote></div></small></div><span class="nv">init</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>xs</var><b>: </b><span>List α</span></span></div></blockquote></div></small></div><span class="nv">xs</span></span><span class="alectryon-token"> <span class="bp">=</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>xs</var><b>: </b><span>List α</span></span></div></blockquote></div></small></div><span class="nv">xs</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>foldlM</var><b>: </b><span>{m : Type → Type u_1} → [inst : Monad m] → {s α : Type} → (s → α → m s) → s → List α → m s</span></span></div></blockquote></div></small></div>foldlM</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>β → α → m β</span></span></div></blockquote></div></small></div><span class="nv">f</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>init</var><b>: </b><span>β</span></span></div></blockquote></div></small></div><span class="nv">init</span></span><span class="alectryon-token"> := </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="For-lean-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="For-lean-chk6"><span class="alectryon-token"><span class="kd">by</span></span><span class="alectryon-token"></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="bp">?</span>u.8948</span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>ma, ma'</var><span class="hyp-type"><b>: </b><span>m α</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>List α</span></span></span><br><span><var>act</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> m Unit</span></span></span><br><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>init</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>β <span class="bp">→</span> α <span class="bp">→</span> m β</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ex2 f init xs <span class="bp">=</span> List.foldlM f init xs</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="For-lean-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="For-lean-chk7"><span class="alectryon-token"><span class="k">unfold</span></span><span class="alectryon-token"> ex2</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="bp">?</span>u.8948</span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>ma, ma'</var><span class="hyp-type"><b>: </b><span>m α</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>List α</span></span></span><br><span><var>act</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> m Unit</span></span></span><br><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>init</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>β <span class="bp">→</span> α <span class="bp">→</span> m β</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ExceptCpsT.runCatch
    (<span class="k">let</span> y := init<span class="bp">;</span>
    StateT.run&#39;
      (<span class="k">do</span>
        forM xs <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
            <span class="k">let</span> y <span class="bp">←</span> get
            <span class="k">let</span> y <span class="bp">←</span> StateT.lift (ExceptCpsT.lift (f y x))
            <span class="k">let</span> _ <span class="bp">←</span> get
            set y
        <span class="k">let</span> y <span class="bp">←</span> get
        StateT.lift (throw y))
      y) <span class="bp">=</span>
  List.foldlM f init xs</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"><span class="bp">;</span></span><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="For-lean-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="For-lean-chk8"><span class="alectryon-token"><span class="k">induction</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>xs</var><b>: </b><span>List α</span></span></div></blockquote></div></small></div><span class="nv">xs</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">generalizing</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>init</var><b>: </b><span>β</span></span></div></blockquote></div></small></div><span class="nv">init</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="bp">?</span>u.8948</span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>ma, ma'</var><span class="hyp-type"><b>: </b><span>m α</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>List α</span></span></span><br><span><var>act</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> m Unit</span></span></span><br><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>β <span class="bp">→</span> α <span class="bp">→</span> m β</span></span></span><br><span><var>init</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">nil</span></span><div class="goal-conclusion">ExceptCpsT.runCatch
    (<span class="k">let</span> y := init<span class="bp">;</span>
    StateT.run&#39;
      (<span class="k">do</span>
        forM [] <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
            <span class="k">let</span> y <span class="bp">←</span> get
            <span class="k">let</span> y <span class="bp">←</span> StateT.lift (ExceptCpsT.lift (f y x))
            <span class="k">let</span> _ <span class="bp">←</span> get
            set y
        <span class="k">let</span> y <span class="bp">←</span> get
        StateT.lift (throw y))
      y) <span class="bp">=</span>
  List.foldlM f init []</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="For-lean-chk9" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="bp">?</span>u.8948</span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>ma, ma'</var><span class="hyp-type"><b>: </b><span>m α</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>List α</span></span></span><br><span><var>act</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> m Unit</span></span></span><br><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>β <span class="bp">→</span> α <span class="bp">→</span> m β</span></span></span><br><span><var>head✝</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br><span><var>tail✝</var><span class="hyp-type"><b>: </b><span>List α</span></span></span><br><span><var>init</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br></div><label class="goal-separator" for="For-lean-chk9"><hr><span class="goal-name">cons</span></label><div class="goal-conclusion">ExceptCpsT.runCatch
    (<span class="k">let</span> y := init<span class="bp">;</span>
    StateT.run&#39;
      (<span class="k">do</span>
        forM (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
            <span class="k">let</span> y <span class="bp">←</span> get
            <span class="k">let</span> y <span class="bp">←</span> StateT.lift (ExceptCpsT.lift (f y x))
            <span class="k">let</span> _ <span class="bp">←</span> get
            set y
        <span class="k">let</span> y <span class="bp">←</span> get
        StateT.lift (throw y))
      y) <span class="bp">=</span>
  List.foldlM f init (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>)</div></blockquote></div></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="For-lean-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="For-lean-chka"><span class="alectryon-token"><span class="k">&lt;;&gt;</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="bp">?</span>u.8948</span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>ma, ma'</var><span class="hyp-type"><b>: </b><span>m α</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>List α</span></span></span><br><span><var>act</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> m Unit</span></span></span><br><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>β <span class="bp">→</span> α <span class="bp">→</span> m β</span></span></span><br><span><var>init</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">nil</span></span><div class="goal-conclusion">ExceptCpsT.runCatch
    (<span class="k">let</span> y := init<span class="bp">;</span>
    StateT.run&#39;
      (<span class="k">do</span>
        forM [] <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
            <span class="k">let</span> y <span class="bp">←</span> get
            <span class="k">let</span> y <span class="bp">←</span> StateT.lift (ExceptCpsT.lift (f y x))
            <span class="k">let</span> _ <span class="bp">←</span> get
            set y
        <span class="k">let</span> y <span class="bp">←</span> get
        StateT.lift (throw y))
      y) <span class="bp">=</span>
  List.foldlM f init []</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="For-lean-chkb" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="bp">?</span>u.8948</span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>ma, ma'</var><span class="hyp-type"><b>: </b><span>m α</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>List α</span></span></span><br><span><var>act</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> m Unit</span></span></span><br><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>β <span class="bp">→</span> α <span class="bp">→</span> m β</span></span></span><br><span><var>head✝</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br><span><var>tail✝</var><span class="hyp-type"><b>: </b><span>List α</span></span></span><br><span><var>init</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br></div><label class="goal-separator" for="For-lean-chkb"><hr><span class="goal-name">cons</span></label><div class="goal-conclusion">ExceptCpsT.runCatch
    (<span class="k">let</span> y := init<span class="bp">;</span>
    StateT.run&#39;
      (<span class="k">do</span>
        forM (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
            <span class="k">let</span> y <span class="bp">←</span> get
            <span class="k">let</span> y <span class="bp">←</span> StateT.lift (ExceptCpsT.lift (f y x))
            <span class="k">let</span> _ <span class="bp">←</span> get
            set y
        <span class="k">let</span> y <span class="bp">←</span> get
        StateT.lift (throw y))
      y) <span class="bp">=</span>
  List.foldlM f init (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>)</div></blockquote></div></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="For-lean-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="For-lean-chkc"><span class="alectryon-token">simp_all<span class="bp">!</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">

<span class="bp">@</span>[</span><span class="alectryon-token"><span class="k">simp</span></span><span class="alectryon-token">] </span><span class="alectryon-token"><span class="kd">theorem</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>List.find?_cons</var><b>: </b><span>∀ {x : α} {p : α → Bool} {xs : List α}, find? p (x :: xs) = if p x = true then some x else find? p xs</span></span></div></blockquote></div></small></div>List.find<span class="bp">?</span>_cons</span><span class="alectryon-token"> {</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>xs</var><b>: </b><span>List α</span></span></div></blockquote></div></small></div><span class="nv">xs</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>List</var><b>: </b><span>Type ?u.17785 → Type ?u.17785</span></span></div></blockquote></div></small></div>List</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token">} : (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token">::</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>xs</var><b>: </b><span>List α</span></span></div></blockquote></div></small></div><span class="nv">xs</span></span><span class="alectryon-token">)<span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>find?</var><b>: </b><span>{α : Type} → (α → Bool) → List α → Option α</span></span></div></blockquote></div></small></div>find<span class="bp">?</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>p</var><b>: </b><span>α → Bool</span></span></div></blockquote></div></small></div><span class="nv">p</span></span><span class="alectryon-token"> <span class="bp">=</span> </span><span class="alectryon-token"><span class="k">if</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>p</var><b>: </b><span>α → Bool</span></span></div></blockquote></div></small></div><span class="nv">p</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">then</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>some</var><b>: </b><span>{α : Type} → α → Option α</span></span></div></blockquote></div></small></div>some</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">else</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>xs</var><b>: </b><span>List α</span></span></div></blockquote></div></small></div><span class="nv">xs</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>find?</var><b>: </b><span>{α : Type} → (α → Bool) → List α → Option α</span></span></div></blockquote></div></small></div>find<span class="bp">?</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>p</var><b>: </b><span>α → Bool</span></span></div></blockquote></div></small></div><span class="nv">p</span></span><span class="alectryon-token"> := </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="For-lean-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="For-lean-chkd"><span class="alectryon-token"><span class="kd">by</span></span><span class="alectryon-token"></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="bp">?</span>u.17767</span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>ma, ma'</var><span class="hyp-type"><b>: </b><span>m α</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>xs✝</var><span class="hyp-type"><b>: </b><span>List α</span></span></span><br><span><var>act</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> m Unit</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> Bool</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>List α</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">find<span class="bp">?</span> p (x :: xs) <span class="bp">=</span> <span class="k">if</span> p x <span class="bp">=</span> true <span class="k">then</span> some x <span class="k">else</span> find<span class="bp">?</span> p xs</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="For-lean-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="For-lean-chke"><span class="alectryon-token"><span class="k">cases</span></span><span class="alectryon-token"> h : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>p</var><b>: </b><span>α → Bool</span></span></div></blockquote></div></small></div><span class="nv">p</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">x</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="bp">?</span>u.17767</span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>ma, ma'</var><span class="hyp-type"><b>: </b><span>m α</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>xs✝</var><span class="hyp-type"><b>: </b><span>List α</span></span></span><br><span><var>act</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> m Unit</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> Bool</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>List α</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>p x <span class="bp">=</span> false</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">false</span></span><div class="goal-conclusion">find<span class="bp">?</span> p (x :: xs) <span class="bp">=</span> <span class="k">if</span> false <span class="bp">=</span> true <span class="k">then</span> some x <span class="k">else</span> find<span class="bp">?</span> p xs</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="For-lean-chkf" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="bp">?</span>u.17767</span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>ma, ma'</var><span class="hyp-type"><b>: </b><span>m α</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>xs✝</var><span class="hyp-type"><b>: </b><span>List α</span></span></span><br><span><var>act</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> m Unit</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> Bool</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>List α</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>p x <span class="bp">=</span> true</span></span></span><br></div><label class="goal-separator" for="For-lean-chkf"><hr><span class="goal-name">true</span></label><div class="goal-conclusion">find<span class="bp">?</span> p (x :: xs) <span class="bp">=</span> <span class="k">if</span> true <span class="bp">=</span> true <span class="k">then</span> some x <span class="k">else</span> find<span class="bp">?</span> p xs</div></blockquote></div></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="For-lean-chk10" style="display: none" type="checkbox"><label class="alectryon-input" for="For-lean-chk10"><span class="alectryon-token"><span class="k">&lt;;&gt;</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="bp">?</span>u.17767</span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>ma, ma'</var><span class="hyp-type"><b>: </b><span>m α</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>xs✝</var><span class="hyp-type"><b>: </b><span>List α</span></span></span><br><span><var>act</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> m Unit</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> Bool</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>List α</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>p x <span class="bp">=</span> false</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">false</span></span><div class="goal-conclusion">find<span class="bp">?</span> p (x :: xs) <span class="bp">=</span> <span class="k">if</span> false <span class="bp">=</span> true <span class="k">then</span> some x <span class="k">else</span> find<span class="bp">?</span> p xs</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="For-lean-chk11" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="bp">?</span>u.17767</span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>ma, ma'</var><span class="hyp-type"><b>: </b><span>m α</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>xs✝</var><span class="hyp-type"><b>: </b><span>List α</span></span></span><br><span><var>act</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> m Unit</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> Bool</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>List α</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>p x <span class="bp">=</span> true</span></span></span><br></div><label class="goal-separator" for="For-lean-chk11"><hr><span class="goal-name">true</span></label><div class="goal-conclusion">find<span class="bp">?</span> p (x :: xs) <span class="bp">=</span> <span class="k">if</span> true <span class="bp">=</span> true <span class="k">then</span> some x <span class="k">else</span> find<span class="bp">?</span> p xs</div></blockquote></div></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="For-lean-chk12" style="display: none" type="checkbox"><label class="alectryon-input" for="For-lean-chk12"><span class="alectryon-token">simp_all<span class="bp">!</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">

</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>example</var><b>: </b><span>∀ {α : Type} (xs : List α) (p : α → Bool),
  Id.run
      (ExceptCpsT.runCatch do
        forM xs fun x =&gt; if p x = true then throw (some x) else ExceptCpsT.lift (pure ())
        ExceptCpsT.lift (pure none)) =
    List.find? p xs</span></span></div></blockquote></div></small></div><span class="kd">example</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>p</var><b>: </b><span>α → Bool</span></span></div></blockquote></div></small></div><span class="nv">p</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Bool</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Bool</span><span class="alectryon-token">) : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Id.run</var><b>: </b><span>{α : Type} → Id α → α</span></span></div></blockquote></div></small></div><span class="k">Id.run</span></span><span class="alectryon-token">
    (</span><span class="alectryon-token"><span class="k">do</span><span class="bp">&#39;</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">for</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">in</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>xs</var><b>: </b><span>List α</span></span></div></blockquote></div></small></div><span class="nv">xs</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">do</span><span class="bp">&#39;</span></span><span class="alectryon-token"> {
           </span><span class="alectryon-token"><span class="k">if</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>p</var><b>: </b><span>α → Bool</span></span></div></blockquote></div></small></div><span class="nv">p</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">then</span></span><span class="alectryon-token"> {
             </span><span class="alectryon-token"><span class="k">return</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>some</var><b>: </b><span>{α : Type} → α → Option α</span></span></div></blockquote></div></small></div><span class="k">some</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token">
           }
         }<span class="bp">;</span>
         </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>pure</var><b>: </b><span>{f : Type → Type} → [self : Pure f] → {α : Type} → α → f α</span></span></div></blockquote></div></small></div><span class="k">pure</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>none</var><b>: </b><span>{α : Type} → Option α</span></span></div></blockquote></div></small></div><span class="k">none</span></span><span class="alectryon-token">)</span><span class="alectryon-token">
    <span class="bp">=</span>
    </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>xs</var><b>: </b><span>List α</span></span></div></blockquote></div></small></div><span class="nv">xs</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>find?</var><b>: </b><span>{α : Type} → (α → Bool) → List α → Option α</span></span></div></blockquote></div></small></div>find<span class="bp">?</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>p</var><b>: </b><span>α → Bool</span></span></div></blockquote></div></small></div><span class="nv">p</span></span><span class="alectryon-token">
:= </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="For-lean-chk13" style="display: none" type="checkbox"><label class="alectryon-input" for="For-lean-chk13"><span class="alectryon-token"><span class="kd">by</span></span><span class="alectryon-token"></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="bp">?</span>u.18571</span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>ma, ma'</var><span class="hyp-type"><b>: </b><span>m α</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>List α</span></span></span><br><span><var>act</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> m Unit</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> Bool</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Id.run
    (ExceptCpsT.runCatch <span class="k">do</span>
      forM xs <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">if</span> p x <span class="bp">=</span> true <span class="k">then</span> throw (some x) <span class="k">else</span> ExceptCpsT.lift (pure ())
      ExceptCpsT.lift (pure none)) <span class="bp">=</span>
  List.find<span class="bp">?</span> p xs</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="For-lean-chk14" style="display: none" type="checkbox"><label class="alectryon-input" for="For-lean-chk14"><span class="alectryon-token"><span class="k">induction</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>xs</var><b>: </b><span>List α</span></span></div></blockquote></div></small></div><span class="nv">xs</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">with</span></span><span class="alectryon-token"></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="bp">?</span>u.18571</span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>ma, ma'</var><span class="hyp-type"><b>: </b><span>m α</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>List α</span></span></span><br><span><var>act</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> m Unit</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> Bool</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Id.run
    (ExceptCpsT.runCatch <span class="k">do</span>
      forM xs <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">if</span> p x <span class="bp">=</span> true <span class="k">then</span> throw (some x) <span class="k">else</span> ExceptCpsT.lift (pure ())
      ExceptCpsT.lift (pure none)) <span class="bp">=</span>
  List.find<span class="bp">?</span> p xs</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
      </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="For-lean-chk15" style="display: none" type="checkbox"><label class="alectryon-input" for="For-lean-chk15"><span class="alectryon-token"><span class="bp">|</span> nil <span class="bp">=&gt;</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="bp">?</span>u.18571</span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>ma, ma'</var><span class="hyp-type"><b>: </b><span>m α</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>List α</span></span></span><br><span><var>act</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> m Unit</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> Bool</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">nil</span></span><div class="goal-conclusion">Id.run
    (ExceptCpsT.runCatch <span class="k">do</span>
      forM [] <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">if</span> p x <span class="bp">=</span> true <span class="k">then</span> throw (some x) <span class="k">else</span> ExceptCpsT.lift (pure ())
      ExceptCpsT.lift (pure none)) <span class="bp">=</span>
  List.find<span class="bp">?</span> p []</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="For-lean-chk16" style="display: none" type="checkbox"><label class="alectryon-input" for="For-lean-chk16"><span class="alectryon-token"><span class="k">simp</span></span><span class="alectryon-token"> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Id.run</var><b>: </b><span>{α : Type ?u.18948} → Id α → α</span></span></div></blockquote></div></small></div>Id.run</span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>List.find?</var><b>: </b><span>{α : Type ?u.18951} → (α → Bool) → List α → Option α</span></span></div></blockquote></div></small></div>List.find<span class="bp">?</span></span><span class="alectryon-token">]</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
      </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="For-lean-chk17" style="display: none" type="checkbox"><label class="alectryon-input" for="For-lean-chk17"><span class="alectryon-token"><span class="bp">|</span> cons </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="bp">?</span>u.18571</span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>ma, ma'</var><span class="hyp-type"><b>: </b><span>m α</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>List α</span></span></span><br><span><var>act</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> m Unit</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> Bool</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br><span><var>tail✝</var><span class="hyp-type"><b>: </b><span>List α</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">cons</span></span><div class="goal-conclusion">Id.run
    (ExceptCpsT.runCatch <span class="k">do</span>
      forM (x :: tail<span class="bp">✝</span>) <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">if</span> p x <span class="bp">=</span> true <span class="k">then</span> throw (some x) <span class="k">else</span> ExceptCpsT.lift (pure ())
      ExceptCpsT.lift (pure none)) <span class="bp">=</span>
  List.find<span class="bp">?</span> p (x :: tail<span class="bp">✝</span>)</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="For-lean-chk18" style="display: none" type="checkbox"><label class="alectryon-input" for="For-lean-chk18"><span class="alectryon-token"><span class="k">cases</span></span><span class="alectryon-token"> h : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>p</var><b>: </b><span>α → Bool</span></span></div></blockquote></div></small></div><span class="nv">p</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">x</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="bp">?</span>u.18571</span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>ma, ma'</var><span class="hyp-type"><b>: </b><span>m α</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>List α</span></span></span><br><span><var>act</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> m Unit</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> Bool</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br><span><var>tail✝</var><span class="hyp-type"><b>: </b><span>List α</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>p x <span class="bp">=</span> false</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">cons.false</span></span><div class="goal-conclusion">Id.run
    (ExceptCpsT.runCatch <span class="k">do</span>
      forM (x :: tail<span class="bp">✝</span>) <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">if</span> p x <span class="bp">=</span> true <span class="k">then</span> throw (some x) <span class="k">else</span> ExceptCpsT.lift (pure ())
      ExceptCpsT.lift (pure none)) <span class="bp">=</span>
  List.find<span class="bp">?</span> p (x :: tail<span class="bp">✝</span>)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="For-lean-chk19" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="bp">?</span>u.18571</span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>ma, ma'</var><span class="hyp-type"><b>: </b><span>m α</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>List α</span></span></span><br><span><var>act</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> m Unit</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> Bool</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br><span><var>tail✝</var><span class="hyp-type"><b>: </b><span>List α</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>p x <span class="bp">=</span> true</span></span></span><br></div><label class="goal-separator" for="For-lean-chk19"><hr><span class="goal-name">cons.true</span></label><div class="goal-conclusion">Id.run
    (ExceptCpsT.runCatch <span class="k">do</span>
      forM (x :: tail<span class="bp">✝</span>) <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">if</span> p x <span class="bp">=</span> true <span class="k">then</span> throw (some x) <span class="k">else</span> ExceptCpsT.lift (pure ())
      ExceptCpsT.lift (pure none)) <span class="bp">=</span>
  List.find<span class="bp">?</span> p (x :: tail<span class="bp">✝</span>)</div></blockquote></div></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="For-lean-chk1a" style="display: none" type="checkbox"><label class="alectryon-input" for="For-lean-chk1a"><span class="alectryon-token"><span class="k">&lt;;&gt;</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="bp">?</span>u.18571</span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>ma, ma'</var><span class="hyp-type"><b>: </b><span>m α</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>List α</span></span></span><br><span><var>act</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> m Unit</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> Bool</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br><span><var>tail✝</var><span class="hyp-type"><b>: </b><span>List α</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>p x <span class="bp">=</span> false</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">cons.false</span></span><div class="goal-conclusion">Id.run
    (ExceptCpsT.runCatch <span class="k">do</span>
      forM (x :: tail<span class="bp">✝</span>) <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">if</span> p x <span class="bp">=</span> true <span class="k">then</span> throw (some x) <span class="k">else</span> ExceptCpsT.lift (pure ())
      ExceptCpsT.lift (pure none)) <span class="bp">=</span>
  List.find<span class="bp">?</span> p (x :: tail<span class="bp">✝</span>)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="For-lean-chk1b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="bp">?</span>u.18571</span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>ma, ma'</var><span class="hyp-type"><b>: </b><span>m α</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>List α</span></span></span><br><span><var>act</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> m Unit</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> Bool</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br><span><var>tail✝</var><span class="hyp-type"><b>: </b><span>List α</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>p x <span class="bp">=</span> true</span></span></span><br></div><label class="goal-separator" for="For-lean-chk1b"><hr><span class="goal-name">cons.true</span></label><div class="goal-conclusion">Id.run
    (ExceptCpsT.runCatch <span class="k">do</span>
      forM (x :: tail<span class="bp">✝</span>) <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">if</span> p x <span class="bp">=</span> true <span class="k">then</span> throw (some x) <span class="k">else</span> ExceptCpsT.lift (pure ())
      ExceptCpsT.lift (pure none)) <span class="bp">=</span>
  List.find<span class="bp">?</span> p (x :: tail<span class="bp">✝</span>)</div></blockquote></div></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="For-lean-chk1c" style="display: none" type="checkbox"><label class="alectryon-input" for="For-lean-chk1c"><span class="alectryon-token"><span class="k">simp_all</span></span><span class="alectryon-token"> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Id.run</var><b>: </b><span>{α : Type ?u.19970} → Id α → α</span></span></div></blockquote></div></small></div><span class="k">Id.run</span></span><span class="alectryon-token">]</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">

</span><span class="alectryon-token"><span class="kd">variable</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>p</var><b>: </b><span>α → m Bool</span></span></div></blockquote></div></small></div><span class="nv">p</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>Type → Type ?u.38841</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Bool</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Bool</span><span class="alectryon-token">)

</span><span class="alectryon-token"><span class="kd">theorem</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>byCases_Bool_bind</var><b>: </b><span>∀ {m : Type → Type u_1} [inst : Monad m] {β : Type} (x : m Bool) (f g : Bool → m β),
  f true = g true → f false = g false → x &gt;&gt;= f = x &gt;&gt;= g</span></span></div></blockquote></div></small></div><span class="nv">byCases_Bool_bind</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>m Bool</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>Type → Type u_1</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Bool</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Bool</span><span class="alectryon-token">) (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>Bool → m β</span></span></div></blockquote></div></small></div><span class="nv">f</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>g</var><b>: </b><span>Bool → m β</span></span></div></blockquote></div></small></div><span class="nv">g</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Bool</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Bool</span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>Type → Type u_1</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>β</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">β</span></span><span class="alectryon-token">) (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>isTrue</var><b>: </b><span>f true = g true</span></span></div></blockquote></div></small></div><span class="nv">isTrue</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>Bool → m β</span></span></div></blockquote></div></small></div><span class="nv">f</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>true</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div>true</span><span class="alectryon-token"> <span class="bp">=</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>g</var><b>: </b><span>Bool → m β</span></span></div></blockquote></div></small></div><span class="nv">g</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>true</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div>true</span><span class="alectryon-token">) (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>isFalse</var><b>: </b><span>f false = g false</span></span></div></blockquote></div></small></div><span class="nv">isFalse</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>Bool → m β</span></span></div></blockquote></div></small></div><span class="nv">f</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>false</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div>false</span><span class="alectryon-token"> <span class="bp">=</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>g</var><b>: </b><span>Bool → m β</span></span></div></blockquote></div></small></div><span class="nv">g</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>false</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div>false</span><span class="alectryon-token">) : (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>m Bool</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> <span class="bp">&gt;&gt;=</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>Bool → m β</span></span></div></blockquote></div></small></div><span class="nv">f</span></span><span class="alectryon-token">) <span class="bp">=</span> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>m Bool</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> <span class="bp">&gt;&gt;=</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>g</var><b>: </b><span>Bool → m β</span></span></div></blockquote></div></small></div><span class="nv">g</span></span><span class="alectryon-token">) := </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="For-lean-chk1d" style="display: none" type="checkbox"><label class="alectryon-input" for="For-lean-chk1d"><span class="alectryon-token"><span class="kd">by</span></span><span class="alectryon-token"></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>ma, ma'</var><span class="hyp-type"><b>: </b><span>m α</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>List α</span></span></span><br><span><var>act</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> m Unit</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> m Bool</span></span></span><br><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>m Bool</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>Bool <span class="bp">→</span> m β</span></span></span><br><span><var>isTrue</var><span class="hyp-type"><b>: </b><span>f true <span class="bp">=</span> g true</span></span></span><br><span><var>isFalse</var><span class="hyp-type"><b>: </b><span>f false <span class="bp">=</span> g false</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x <span class="bp">&gt;&gt;=</span> f <span class="bp">=</span> x <span class="bp">&gt;&gt;=</span> g</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="For-lean-chk1e" style="display: none" type="checkbox"><label class="alectryon-input" for="For-lean-chk1e"><span class="alectryon-token"><span class="k">have</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>Bool → m β</span></span></div></blockquote></div></small></div><span class="nv">f</span></span><span class="alectryon-token"> <span class="bp">=</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>g</var><b>: </b><span>Bool → m β</span></span></div></blockquote></div></small></div><span class="nv">g</span></span><span class="alectryon-token"> :=</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>ma, ma'</var><span class="hyp-type"><b>: </b><span>m α</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>List α</span></span></span><br><span><var>act</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> m Unit</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> m Bool</span></span></span><br><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>m Bool</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>Bool <span class="bp">→</span> m β</span></span></span><br><span><var>isTrue</var><span class="hyp-type"><b>: </b><span>f true <span class="bp">=</span> g true</span></span></span><br><span><var>isFalse</var><span class="hyp-type"><b>: </b><span>f false <span class="bp">=</span> g false</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x <span class="bp">&gt;&gt;=</span> f <span class="bp">=</span> x <span class="bp">&gt;&gt;=</span> g</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="For-lean-chk1f" style="display: none" type="checkbox"><label class="alectryon-input" for="For-lean-chk1f"><span class="alectryon-token"><span class="kd">by</span></span><span class="alectryon-token"></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>ma, ma'</var><span class="hyp-type"><b>: </b><span>m α</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>List α</span></span></span><br><span><var>act</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> m Unit</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> m Bool</span></span></span><br><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>m Bool</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>Bool <span class="bp">→</span> m β</span></span></span><br><span><var>isTrue</var><span class="hyp-type"><b>: </b><span>f true <span class="bp">=</span> g true</span></span></span><br><span><var>isFalse</var><span class="hyp-type"><b>: </b><span>f false <span class="bp">=</span> g false</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f <span class="bp">=</span> g</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
    </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="For-lean-chk20" style="display: none" type="checkbox"><label class="alectryon-input" for="For-lean-chk20"><span class="alectryon-token"><span class="k">funext</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div><span class="nv">b</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>ma, ma'</var><span class="hyp-type"><b>: </b><span>m α</span></span></span><br><span><var>b✝</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>List α</span></span></span><br><span><var>act</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> m Unit</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> m Bool</span></span></span><br><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>m Bool</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>Bool <span class="bp">→</span> m β</span></span></span><br><span><var>isTrue</var><span class="hyp-type"><b>: </b><span>f true <span class="bp">=</span> g true</span></span></span><br><span><var>isFalse</var><span class="hyp-type"><b>: </b><span>f false <span class="bp">=</span> g false</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">h</span></span><div class="goal-conclusion">f b <span class="bp">=</span> g b</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
    </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="For-lean-chk21" style="display: none" type="checkbox"><label class="alectryon-input" for="For-lean-chk21"><span class="alectryon-token"><span class="k">cases</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">with</span></span><span class="alectryon-token"></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>ma, ma'</var><span class="hyp-type"><b>: </b><span>m α</span></span></span><br><span><var>b✝</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>List α</span></span></span><br><span><var>act</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> m Unit</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> m Bool</span></span></span><br><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>m Bool</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>Bool <span class="bp">→</span> m β</span></span></span><br><span><var>isTrue</var><span class="hyp-type"><b>: </b><span>f true <span class="bp">=</span> g true</span></span></span><br><span><var>isFalse</var><span class="hyp-type"><b>: </b><span>f false <span class="bp">=</span> g false</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">h</span></span><div class="goal-conclusion">f b <span class="bp">=</span> g b</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
    </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="For-lean-chk22" style="display: none" type="checkbox"><label class="alectryon-input" for="For-lean-chk22"><span class="alectryon-token"><span class="bp">|</span> true  <span class="bp">=&gt;</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>ma, ma'</var><span class="hyp-type"><b>: </b><span>m α</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>List α</span></span></span><br><span><var>act</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> m Unit</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> m Bool</span></span></span><br><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>m Bool</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>Bool <span class="bp">→</span> m β</span></span></span><br><span><var>isTrue</var><span class="hyp-type"><b>: </b><span>f true <span class="bp">=</span> g true</span></span></span><br><span><var>isFalse</var><span class="hyp-type"><b>: </b><span>f false <span class="bp">=</span> g false</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">h.true</span></span><div class="goal-conclusion">f true <span class="bp">=</span> g true</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="For-lean-chk23" style="display: none" type="checkbox"><label class="alectryon-input" for="For-lean-chk23"><span class="alectryon-token"><span class="k">exact</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>isTrue</var><b>: </b><span>f true = g true</span></span></div></blockquote></div></small></div><span class="nv">isTrue</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
    </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="For-lean-chk24" style="display: none" type="checkbox"><label class="alectryon-input" for="For-lean-chk24"><span class="alectryon-token"><span class="bp">|</span> false <span class="bp">=&gt;</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>ma, ma'</var><span class="hyp-type"><b>: </b><span>m α</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>List α</span></span></span><br><span><var>act</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> m Unit</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> m Bool</span></span></span><br><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>m Bool</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>Bool <span class="bp">→</span> m β</span></span></span><br><span><var>isTrue</var><span class="hyp-type"><b>: </b><span>f true <span class="bp">=</span> g true</span></span></span><br><span><var>isFalse</var><span class="hyp-type"><b>: </b><span>f false <span class="bp">=</span> g false</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">h.false</span></span><div class="goal-conclusion">f false <span class="bp">=</span> g false</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="For-lean-chk25" style="display: none" type="checkbox"><label class="alectryon-input" for="For-lean-chk25"><span class="alectryon-token"><span class="k">exact</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>isFalse</var><b>: </b><span>f false = g false</span></span></div></blockquote></div></small></div><span class="nv">isFalse</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="For-lean-chk26" style="display: none" type="checkbox"><label class="alectryon-input" for="For-lean-chk26"><span class="alectryon-token"><span class="k">rw</span></span><span class="alectryon-token"> [</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>ma, ma'</var><span class="hyp-type"><b>: </b><span>m α</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>List α</span></span></span><br><span><var>act</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> m Unit</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> m Bool</span></span></span><br><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>m Bool</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>Bool <span class="bp">→</span> m β</span></span></span><br><span><var>isTrue</var><span class="hyp-type"><b>: </b><span>f true <span class="bp">=</span> g true</span></span></span><br><span><var>isFalse</var><span class="hyp-type"><b>: </b><span>f false <span class="bp">=</span> g false</span></span></span><br><span><var>this</var><span class="hyp-type"><b>: </b><span>f <span class="bp">=</span> g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x <span class="bp">&gt;&gt;=</span> f <span class="bp">=</span> x <span class="bp">&gt;&gt;=</span> g</div></blockquote></div></div></small></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="For-lean-chk27" style="display: none" type="checkbox"><label class="alectryon-input" for="For-lean-chk27"><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>this</var><b>: </b><span>f = g</span></span></div></blockquote></div></small></div><span class="nv">this</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>ma, ma'</var><span class="hyp-type"><b>: </b><span>m α</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>List α</span></span></span><br><span><var>act</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> m Unit</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> m Bool</span></span></span><br><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>m Bool</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>Bool <span class="bp">→</span> m β</span></span></span><br><span><var>isTrue</var><span class="hyp-type"><b>: </b><span>f true <span class="bp">=</span> g true</span></span></span><br><span><var>isFalse</var><span class="hyp-type"><b>: </b><span>f false <span class="bp">=</span> g false</span></span></span><br><span><var>this</var><span class="hyp-type"><b>: </b><span>f <span class="bp">=</span> g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x <span class="bp">&gt;&gt;=</span> g <span class="bp">=</span> x <span class="bp">&gt;&gt;=</span> g</div></blockquote></div></div></small></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="For-lean-chk28" style="display: none" type="checkbox"><label class="alectryon-input" for="For-lean-chk28"><span class="alectryon-token">]</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">

</span><span class="alectryon-token"><span class="kd">theorem</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>eq_findM</var><b>: </b><span>∀ {m : Type → Type u_1} {α : Type} [inst : Monad m] (xs : List α) (p : α → m Bool) [inst_1 : LawfulMonad m],
  (ExceptCpsT.runCatch do
      forM xs fun x =&gt; do
          let b ← ExceptCpsT.lift (p x)
          if b = true then throw (some x) else ExceptCpsT.lift (pure ())
      ExceptCpsT.lift (pure none)) =
    List.findM? p xs</span></span></div></blockquote></div></small></div><span class="nv">eq_findM</span></span><span class="alectryon-token"> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>LawfulMonad</var><b>: </b><span>(m : Type → Type u_1) → [inst : Monad m] → Prop</span></span></div></blockquote></div></small></div>LawfulMonad</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>Type → Type u_1</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token">] :
    (</span><span class="alectryon-token"><span class="k">do</span><span class="bp">&#39;</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">for</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">in</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>xs</var><b>: </b><span>List α</span></span></div></blockquote></div></small></div><span class="nv">xs</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">do</span><span class="bp">&#39;</span></span><span class="alectryon-token"> {
           </span><span class="alectryon-token"><span class="k">let</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token"> <span class="bp">←</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>p</var><b>: </b><span>α → m Bool</span></span></div></blockquote></div></small></div><span class="nv">p</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"><span class="bp">;</span>
           </span><span class="alectryon-token"><span class="k">if</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">then</span></span><span class="alectryon-token"> {
             </span><span class="alectryon-token"><span class="k">return</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>some</var><b>: </b><span>{α : Type} → α → Option α</span></span></div></blockquote></div></small></div>some</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token">
           }
         }<span class="bp">;</span>
         </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>pure</var><b>: </b><span>{f : Type → Type u_1} → [self : Pure f] → {α : Type} → α → f α</span></span></div></blockquote></div></small></div>pure</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>none</var><b>: </b><span>{α : Type} → Option α</span></span></div></blockquote></div></small></div>none</span><span class="alectryon-token">)
    <span class="bp">=</span>
    </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>xs</var><b>: </b><span>List α</span></span></div></blockquote></div></small></div><span class="nv">xs</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>findM?</var><b>: </b><span>{m : Type → Type u_1} → [inst : Monad m] → {α : Type} → (α → m Bool) → List α → m (Option α)</span></span></div></blockquote></div></small></div>findM<span class="bp">?</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>p</var><b>: </b><span>α → m Bool</span></span></div></blockquote></div></small></div><span class="nv">p</span></span><span class="alectryon-token">
:= </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="For-lean-chk29" style="display: none" type="checkbox"><label class="alectryon-input" for="For-lean-chk29"><span class="alectryon-token"><span class="kd">by</span></span><span class="alectryon-token"></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>ma, ma'</var><span class="hyp-type"><b>: </b><span>m α</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>List α</span></span></span><br><span><var>act</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> m Unit</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> m Bool</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(ExceptCpsT.runCatch <span class="k">do</span>
    forM xs <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
        <span class="k">let</span> b <span class="bp">←</span> ExceptCpsT.lift (p x)
        <span class="k">if</span> b <span class="bp">=</span> true <span class="k">then</span> throw (some x) <span class="k">else</span> ExceptCpsT.lift (pure ())
    ExceptCpsT.lift (pure none)) <span class="bp">=</span>
  List.findM<span class="bp">?</span> p xs</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="For-lean-chk2a" style="display: none" type="checkbox"><label class="alectryon-input" for="For-lean-chk2a"><span class="alectryon-token"><span class="k">induction</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>xs</var><b>: </b><span>List α</span></span></div></blockquote></div></small></div><span class="nv">xs</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">with</span></span><span class="alectryon-token"></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>ma, ma'</var><span class="hyp-type"><b>: </b><span>m α</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>List α</span></span></span><br><span><var>act</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> m Unit</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> m Bool</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(ExceptCpsT.runCatch <span class="k">do</span>
    forM xs <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
        <span class="k">let</span> b <span class="bp">←</span> ExceptCpsT.lift (p x)
        <span class="k">if</span> b <span class="bp">=</span> true <span class="k">then</span> throw (some x) <span class="k">else</span> ExceptCpsT.lift (pure ())
    ExceptCpsT.lift (pure none)) <span class="bp">=</span>
  List.findM<span class="bp">?</span> p xs</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
      </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="For-lean-chk2b" style="display: none" type="checkbox"><label class="alectryon-input" for="For-lean-chk2b"><span class="alectryon-token"><span class="bp">|</span> nil <span class="bp">=&gt;</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>ma, ma'</var><span class="hyp-type"><b>: </b><span>m α</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>List α</span></span></span><br><span><var>act</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> m Unit</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> m Bool</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">nil</span></span><div class="goal-conclusion">(ExceptCpsT.runCatch <span class="k">do</span>
    forM [] <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
        <span class="k">let</span> b <span class="bp">←</span> ExceptCpsT.lift (p x)
        <span class="k">if</span> b <span class="bp">=</span> true <span class="k">then</span> throw (some x) <span class="k">else</span> ExceptCpsT.lift (pure ())
    ExceptCpsT.lift (pure none)) <span class="bp">=</span>
  List.findM<span class="bp">?</span> p []</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="For-lean-chk2c" style="display: none" type="checkbox"><label class="alectryon-input" for="For-lean-chk2c"><span class="alectryon-token">simp<span class="bp">!</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
      </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="For-lean-chk2d" style="display: none" type="checkbox"><label class="alectryon-input" for="For-lean-chk2d"><span class="alectryon-token"><span class="bp">|</span> cons </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>xs</var><b>: </b><span>List α</span></span></div></blockquote></div></small></div><span class="nv">xs</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ih</var><b>: </b><span>(ExceptCpsT.runCatch do
    forM xs fun x =&gt; do
        let b ← ExceptCpsT.lift (p x)
        if b = true then throw (some x) else ExceptCpsT.lift (pure ())
    ExceptCpsT.lift (pure none)) =
  List.findM? p xs</span></span></div></blockquote></div></small></div><span class="nv">ih</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>ma, ma'</var><span class="hyp-type"><b>: </b><span>m α</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>xs✝</var><span class="hyp-type"><b>: </b><span>List α</span></span></span><br><span><var>act</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> m Unit</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> m Bool</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>List α</span></span></span><br><span><var>ih</var><span class="hyp-type"><b>: </b><span>(ExceptCpsT.runCatch <span class="k">do</span>
    forM xs <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
        <span class="k">let</span> b <span class="bp">←</span> ExceptCpsT.lift (p x)
        <span class="k">if</span> b <span class="bp">=</span> true <span class="k">then</span> throw (some x) <span class="k">else</span> ExceptCpsT.lift (pure ())
    ExceptCpsT.lift (pure none)) <span class="bp">=</span>
  List.findM<span class="bp">?</span> p xs</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">cons</span></span><div class="goal-conclusion">(ExceptCpsT.runCatch <span class="k">do</span>
    forM (x :: xs) <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
        <span class="k">let</span> b <span class="bp">←</span> ExceptCpsT.lift (p x)
        <span class="k">if</span> b <span class="bp">=</span> true <span class="k">then</span> throw (some x) <span class="k">else</span> ExceptCpsT.lift (pure ())
    ExceptCpsT.lift (pure none)) <span class="bp">=</span>
  List.findM<span class="bp">?</span> p (x :: xs)</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
        </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="For-lean-chk2e" style="display: none" type="checkbox"><label class="alectryon-input" for="For-lean-chk2e"><span class="alectryon-token"><span class="k">rw</span></span><span class="alectryon-token"> [</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>ma, ma'</var><span class="hyp-type"><b>: </b><span>m α</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>xs✝</var><span class="hyp-type"><b>: </b><span>List α</span></span></span><br><span><var>act</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> m Unit</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> m Bool</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>List α</span></span></span><br><span><var>ih</var><span class="hyp-type"><b>: </b><span>(ExceptCpsT.runCatch <span class="k">do</span>
    forM xs <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
        <span class="k">let</span> b <span class="bp">←</span> ExceptCpsT.lift (p x)
        <span class="k">if</span> b <span class="bp">=</span> true <span class="k">then</span> throw (some x) <span class="k">else</span> ExceptCpsT.lift (pure ())
    ExceptCpsT.lift (pure none)) <span class="bp">=</span>
  List.findM<span class="bp">?</span> p xs</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">cons</span></span><div class="goal-conclusion">(ExceptCpsT.runCatch <span class="k">do</span>
    forM (x :: xs) <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
        <span class="k">let</span> b <span class="bp">←</span> ExceptCpsT.lift (p x)
        <span class="k">if</span> b <span class="bp">=</span> true <span class="k">then</span> throw (some x) <span class="k">else</span> ExceptCpsT.lift (pure ())
    ExceptCpsT.lift (pure none)) <span class="bp">=</span>
  List.findM<span class="bp">?</span> p (x :: xs)</div></blockquote></div></div></small></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="For-lean-chk2f" style="display: none" type="checkbox"><label class="alectryon-input" for="For-lean-chk2f"><span class="alectryon-token">List.findM<span class="bp">?</span>,</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>ma, ma'</var><span class="hyp-type"><b>: </b><span>m α</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>xs✝</var><span class="hyp-type"><b>: </b><span>List α</span></span></span><br><span><var>act</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> m Unit</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> m Bool</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>List α</span></span></span><br><span><var>ih</var><span class="hyp-type"><b>: </b><span>(ExceptCpsT.runCatch <span class="k">do</span>
    forM xs <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
        <span class="k">let</span> b <span class="bp">←</span> ExceptCpsT.lift (p x)
        <span class="k">if</span> b <span class="bp">=</span> true <span class="k">then</span> throw (some x) <span class="k">else</span> ExceptCpsT.lift (pure ())
    ExceptCpsT.lift (pure none)) <span class="bp">=</span>
  List.findM<span class="bp">?</span> p xs</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">cons</span></span><div class="goal-conclusion">(ExceptCpsT.runCatch <span class="k">do</span>
    forM (x :: xs) <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
        <span class="k">let</span> b <span class="bp">←</span> ExceptCpsT.lift (p x)
        <span class="k">if</span> b <span class="bp">=</span> true <span class="k">then</span> throw (some x) <span class="k">else</span> ExceptCpsT.lift (pure ())
    ExceptCpsT.lift (pure none)) <span class="bp">=</span>
  <span class="k">do</span>
  <span class="k">let</span> a <span class="bp">←</span> p x
  <span class="k">match</span> a <span class="k">with</span>
    <span class="bp">|</span> true <span class="bp">=&gt;</span> pure (some x)
    <span class="bp">|</span> false <span class="bp">=&gt;</span> List.findM<span class="bp">?</span> p xs</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="For-lean-chk30" style="display: none" type="checkbox"><label class="alectryon-input" for="For-lean-chk30"><span class="alectryon-token"><span class="bp">←</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ih</var><b>: </b><span>(ExceptCpsT.runCatch do
    forM xs fun x =&gt; do
        let b ← ExceptCpsT.lift (p x)
        if b = true then throw (some x) else ExceptCpsT.lift (pure ())
    ExceptCpsT.lift (pure none)) =
  List.findM? p xs</span></span></div></blockquote></div></small></div><span class="nv">ih</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>ma, ma'</var><span class="hyp-type"><b>: </b><span>m α</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>xs✝</var><span class="hyp-type"><b>: </b><span>List α</span></span></span><br><span><var>act</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> m Unit</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> m Bool</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>List α</span></span></span><br><span><var>ih</var><span class="hyp-type"><b>: </b><span>(ExceptCpsT.runCatch <span class="k">do</span>
    forM xs <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
        <span class="k">let</span> b <span class="bp">←</span> ExceptCpsT.lift (p x)
        <span class="k">if</span> b <span class="bp">=</span> true <span class="k">then</span> throw (some x) <span class="k">else</span> ExceptCpsT.lift (pure ())
    ExceptCpsT.lift (pure none)) <span class="bp">=</span>
  List.findM<span class="bp">?</span> p xs</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">cons</span></span><div class="goal-conclusion">(ExceptCpsT.runCatch <span class="k">do</span>
    forM (x :: xs) <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
        <span class="k">let</span> b <span class="bp">←</span> ExceptCpsT.lift (p x)
        <span class="k">if</span> b <span class="bp">=</span> true <span class="k">then</span> throw (some x) <span class="k">else</span> ExceptCpsT.lift (pure ())
    ExceptCpsT.lift (pure none)) <span class="bp">=</span>
  <span class="k">do</span>
  <span class="k">let</span> a <span class="bp">←</span> p x
  <span class="k">match</span> a <span class="k">with</span>
    <span class="bp">|</span> true <span class="bp">=&gt;</span> pure (some x)
    <span class="bp">|</span> false <span class="bp">=&gt;</span>
      ExceptCpsT.runCatch <span class="k">do</span>
        forM xs <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
            <span class="k">let</span> b <span class="bp">←</span> ExceptCpsT.lift (p x)
            <span class="k">if</span> b <span class="bp">=</span> true <span class="k">then</span> throw (some x) <span class="k">else</span> ExceptCpsT.lift (pure ())
        ExceptCpsT.lift (pure none)</div></blockquote></div></div></small></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="For-lean-chk31" style="display: none" type="checkbox"><label class="alectryon-input" for="For-lean-chk31"><span class="alectryon-token">]</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>ma, ma'</var><span class="hyp-type"><b>: </b><span>m α</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>xs✝</var><span class="hyp-type"><b>: </b><span>List α</span></span></span><br><span><var>act</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> m Unit</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> m Bool</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>List α</span></span></span><br><span><var>ih</var><span class="hyp-type"><b>: </b><span>(ExceptCpsT.runCatch <span class="k">do</span>
    forM xs <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
        <span class="k">let</span> b <span class="bp">←</span> ExceptCpsT.lift (p x)
        <span class="k">if</span> b <span class="bp">=</span> true <span class="k">then</span> throw (some x) <span class="k">else</span> ExceptCpsT.lift (pure ())
    ExceptCpsT.lift (pure none)) <span class="bp">=</span>
  List.findM<span class="bp">?</span> p xs</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">cons</span></span><div class="goal-conclusion">(ExceptCpsT.runCatch <span class="k">do</span>
    forM (x :: xs) <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
        <span class="k">let</span> b <span class="bp">←</span> ExceptCpsT.lift (p x)
        <span class="k">if</span> b <span class="bp">=</span> true <span class="k">then</span> throw (some x) <span class="k">else</span> ExceptCpsT.lift (pure ())
    ExceptCpsT.lift (pure none)) <span class="bp">=</span>
  <span class="k">do</span>
  <span class="k">let</span> a <span class="bp">←</span> p x
  <span class="k">match</span> a <span class="k">with</span>
    <span class="bp">|</span> true <span class="bp">=&gt;</span> pure (some x)
    <span class="bp">|</span> false <span class="bp">=&gt;</span>
      ExceptCpsT.runCatch <span class="k">do</span>
        forM xs <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
            <span class="k">let</span> b <span class="bp">←</span> ExceptCpsT.lift (p x)
            <span class="k">if</span> b <span class="bp">=</span> true <span class="k">then</span> throw (some x) <span class="k">else</span> ExceptCpsT.lift (pure ())
        ExceptCpsT.lift (pure none)</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"><span class="bp">;</span></span><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="For-lean-chk32" style="display: none" type="checkbox"><label class="alectryon-input" for="For-lean-chk32"><span class="alectryon-token"><span class="k">simp</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>ma, ma'</var><span class="hyp-type"><b>: </b><span>m α</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>xs✝</var><span class="hyp-type"><b>: </b><span>List α</span></span></span><br><span><var>act</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> m Unit</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> m Bool</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>List α</span></span></span><br><span><var>ih</var><span class="hyp-type"><b>: </b><span>(ExceptCpsT.runCatch <span class="k">do</span>
    forM xs <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
        <span class="k">let</span> b <span class="bp">←</span> ExceptCpsT.lift (p x)
        <span class="k">if</span> b <span class="bp">=</span> true <span class="k">then</span> throw (some x) <span class="k">else</span> ExceptCpsT.lift (pure ())
    ExceptCpsT.lift (pure none)) <span class="bp">=</span>
  List.findM<span class="bp">?</span> p xs</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">cons</span></span><div class="goal-conclusion">(<span class="k">do</span>
    <span class="k">let</span> a <span class="bp">←</span> p x
    ExceptCpsT.runCatch <span class="k">do</span>
        <span class="k">if</span> a <span class="bp">=</span> true <span class="k">then</span> throw (some x) <span class="k">else</span> ExceptCpsT.lift (pure ())
        forM xs <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
            <span class="k">let</span> b <span class="bp">←</span> ExceptCpsT.lift (p x)
            <span class="k">if</span> b <span class="bp">=</span> true <span class="k">then</span> throw (some x) <span class="k">else</span> ExceptCpsT.lift (pure ())
        ExceptCpsT.lift (pure none)) <span class="bp">=</span>
  <span class="k">do</span>
  <span class="k">let</span> a <span class="bp">←</span> p x
  <span class="k">match</span> a <span class="k">with</span>
    <span class="bp">|</span> true <span class="bp">=&gt;</span> pure (some x)
    <span class="bp">|</span> false <span class="bp">=&gt;</span>
      ExceptCpsT.runCatch <span class="k">do</span>
        forM xs <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
            <span class="k">let</span> b <span class="bp">←</span> ExceptCpsT.lift (p x)
            <span class="k">if</span> b <span class="bp">=</span> true <span class="k">then</span> throw (some x) <span class="k">else</span> ExceptCpsT.lift (pure ())
        ExceptCpsT.lift (pure none)</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
        </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="For-lean-chk33" style="display: none" type="checkbox"><label class="alectryon-input" for="For-lean-chk33"><span class="alectryon-token"><span class="k">apply</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>byCases_Bool_bind</var><b>: </b><span>∀ {m : Type → Type u_1} [inst : Monad m] {β : Type} (x : m Bool) (f g : Bool → m β),
  f true = g true → f false = g false → x &gt;&gt;= f = x &gt;&gt;= g</span></span></div></blockquote></div></small></div><span class="k">byCases_Bool_bind</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>ma, ma'</var><span class="hyp-type"><b>: </b><span>m α</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>xs✝</var><span class="hyp-type"><b>: </b><span>List α</span></span></span><br><span><var>act</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> m Unit</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> m Bool</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>List α</span></span></span><br><span><var>ih</var><span class="hyp-type"><b>: </b><span>(ExceptCpsT.runCatch <span class="k">do</span>
    forM xs <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
        <span class="k">let</span> b <span class="bp">←</span> ExceptCpsT.lift (p x)
        <span class="k">if</span> b <span class="bp">=</span> true <span class="k">then</span> throw (some x) <span class="k">else</span> ExceptCpsT.lift (pure ())
    ExceptCpsT.lift (pure none)) <span class="bp">=</span>
  List.findM<span class="bp">?</span> p xs</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">cons.isTrue</span></span><div class="goal-conclusion">(ExceptCpsT.runCatch <span class="k">do</span>
    <span class="k">if</span> true <span class="bp">=</span> true <span class="k">then</span> throw (some x) <span class="k">else</span> ExceptCpsT.lift (pure ())
    forM xs <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
        <span class="k">let</span> b <span class="bp">←</span> ExceptCpsT.lift (p x)
        <span class="k">if</span> b <span class="bp">=</span> true <span class="k">then</span> throw (some x) <span class="k">else</span> ExceptCpsT.lift (pure ())
    ExceptCpsT.lift (pure none)) <span class="bp">=</span>
  <span class="k">match</span> true <span class="k">with</span>
  <span class="bp">|</span> true <span class="bp">=&gt;</span> pure (some x)
  <span class="bp">|</span> false <span class="bp">=&gt;</span>
    ExceptCpsT.runCatch <span class="k">do</span>
      forM xs <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
          <span class="k">let</span> b <span class="bp">←</span> ExceptCpsT.lift (p x)
          <span class="k">if</span> b <span class="bp">=</span> true <span class="k">then</span> throw (some x) <span class="k">else</span> ExceptCpsT.lift (pure ())
      ExceptCpsT.lift (pure none)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="For-lean-chk34" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>ma, ma'</var><span class="hyp-type"><b>: </b><span>m α</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>xs✝</var><span class="hyp-type"><b>: </b><span>List α</span></span></span><br><span><var>act</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> m Unit</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> m Bool</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>List α</span></span></span><br><span><var>ih</var><span class="hyp-type"><b>: </b><span>(ExceptCpsT.runCatch <span class="k">do</span>
    forM xs <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
        <span class="k">let</span> b <span class="bp">←</span> ExceptCpsT.lift (p x)
        <span class="k">if</span> b <span class="bp">=</span> true <span class="k">then</span> throw (some x) <span class="k">else</span> ExceptCpsT.lift (pure ())
    ExceptCpsT.lift (pure none)) <span class="bp">=</span>
  List.findM<span class="bp">?</span> p xs</span></span></span><br></div><label class="goal-separator" for="For-lean-chk34"><hr><span class="goal-name">cons.isFalse</span></label><div class="goal-conclusion">(ExceptCpsT.runCatch <span class="k">do</span>
    <span class="k">if</span> false <span class="bp">=</span> true <span class="k">then</span> throw (some x) <span class="k">else</span> ExceptCpsT.lift (pure ())
    forM xs <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
        <span class="k">let</span> b <span class="bp">←</span> ExceptCpsT.lift (p x)
        <span class="k">if</span> b <span class="bp">=</span> true <span class="k">then</span> throw (some x) <span class="k">else</span> ExceptCpsT.lift (pure ())
    ExceptCpsT.lift (pure none)) <span class="bp">=</span>
  <span class="k">match</span> false <span class="k">with</span>
  <span class="bp">|</span> true <span class="bp">=&gt;</span> pure (some x)
  <span class="bp">|</span> false <span class="bp">=&gt;</span>
    ExceptCpsT.runCatch <span class="k">do</span>
      forM xs <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
          <span class="k">let</span> b <span class="bp">←</span> ExceptCpsT.lift (p x)
          <span class="k">if</span> b <span class="bp">=</span> true <span class="k">then</span> throw (some x) <span class="k">else</span> ExceptCpsT.lift (pure ())
      ExceptCpsT.lift (pure none)</div></blockquote></div></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="For-lean-chk35" style="display: none" type="checkbox"><label class="alectryon-input" for="For-lean-chk35"><span class="alectryon-token"><span class="k">&lt;;&gt;</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>ma, ma'</var><span class="hyp-type"><b>: </b><span>m α</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>xs✝</var><span class="hyp-type"><b>: </b><span>List α</span></span></span><br><span><var>act</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> m Unit</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> m Bool</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>List α</span></span></span><br><span><var>ih</var><span class="hyp-type"><b>: </b><span>(ExceptCpsT.runCatch <span class="k">do</span>
    forM xs <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
        <span class="k">let</span> b <span class="bp">←</span> ExceptCpsT.lift (p x)
        <span class="k">if</span> b <span class="bp">=</span> true <span class="k">then</span> throw (some x) <span class="k">else</span> ExceptCpsT.lift (pure ())
    ExceptCpsT.lift (pure none)) <span class="bp">=</span>
  List.findM<span class="bp">?</span> p xs</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">cons.isTrue</span></span><div class="goal-conclusion">(ExceptCpsT.runCatch <span class="k">do</span>
    <span class="k">if</span> true <span class="bp">=</span> true <span class="k">then</span> throw (some x) <span class="k">else</span> ExceptCpsT.lift (pure ())
    forM xs <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
        <span class="k">let</span> b <span class="bp">←</span> ExceptCpsT.lift (p x)
        <span class="k">if</span> b <span class="bp">=</span> true <span class="k">then</span> throw (some x) <span class="k">else</span> ExceptCpsT.lift (pure ())
    ExceptCpsT.lift (pure none)) <span class="bp">=</span>
  <span class="k">match</span> true <span class="k">with</span>
  <span class="bp">|</span> true <span class="bp">=&gt;</span> pure (some x)
  <span class="bp">|</span> false <span class="bp">=&gt;</span>
    ExceptCpsT.runCatch <span class="k">do</span>
      forM xs <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
          <span class="k">let</span> b <span class="bp">←</span> ExceptCpsT.lift (p x)
          <span class="k">if</span> b <span class="bp">=</span> true <span class="k">then</span> throw (some x) <span class="k">else</span> ExceptCpsT.lift (pure ())
      ExceptCpsT.lift (pure none)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="For-lean-chk36" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>ma, ma'</var><span class="hyp-type"><b>: </b><span>m α</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>xs✝</var><span class="hyp-type"><b>: </b><span>List α</span></span></span><br><span><var>act</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> m Unit</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> m Bool</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>List α</span></span></span><br><span><var>ih</var><span class="hyp-type"><b>: </b><span>(ExceptCpsT.runCatch <span class="k">do</span>
    forM xs <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
        <span class="k">let</span> b <span class="bp">←</span> ExceptCpsT.lift (p x)
        <span class="k">if</span> b <span class="bp">=</span> true <span class="k">then</span> throw (some x) <span class="k">else</span> ExceptCpsT.lift (pure ())
    ExceptCpsT.lift (pure none)) <span class="bp">=</span>
  List.findM<span class="bp">?</span> p xs</span></span></span><br></div><label class="goal-separator" for="For-lean-chk36"><hr><span class="goal-name">cons.isFalse</span></label><div class="goal-conclusion">(ExceptCpsT.runCatch <span class="k">do</span>
    <span class="k">if</span> false <span class="bp">=</span> true <span class="k">then</span> throw (some x) <span class="k">else</span> ExceptCpsT.lift (pure ())
    forM xs <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
        <span class="k">let</span> b <span class="bp">←</span> ExceptCpsT.lift (p x)
        <span class="k">if</span> b <span class="bp">=</span> true <span class="k">then</span> throw (some x) <span class="k">else</span> ExceptCpsT.lift (pure ())
    ExceptCpsT.lift (pure none)) <span class="bp">=</span>
  <span class="k">match</span> false <span class="k">with</span>
  <span class="bp">|</span> true <span class="bp">=&gt;</span> pure (some x)
  <span class="bp">|</span> false <span class="bp">=&gt;</span>
    ExceptCpsT.runCatch <span class="k">do</span>
      forM xs <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
          <span class="k">let</span> b <span class="bp">←</span> ExceptCpsT.lift (p x)
          <span class="k">if</span> b <span class="bp">=</span> true <span class="k">then</span> throw (some x) <span class="k">else</span> ExceptCpsT.lift (pure ())
      ExceptCpsT.lift (pure none)</div></blockquote></div></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="For-lean-chk37" style="display: none" type="checkbox"><label class="alectryon-input" for="For-lean-chk37"><span class="alectryon-token"><span class="k">simp</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">

</span><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ex3</var><b>: </b><span>[inst : Monad m] → (α → m Bool) → List (List α) → m (Option α)</span></span></div></blockquote></div></small></div><span class="nv">ex3</span></span><span class="alectryon-token"> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Monad</var><b>: </b><span>(Type → Type u_1) → Type (max 1 u_1)</span></span></div></blockquote></div></small></div>Monad</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>Type → Type u_1</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token">] (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>p</var><b>: </b><span>α → m Bool</span></span></div></blockquote></div></small></div><span class="nv">p</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>Type → Type u_1</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Bool</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Bool</span><span class="alectryon-token">) (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>xss</var><b>: </b><span>List (List α)</span></span></div></blockquote></div></small></div><span class="nv">xss</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>List</var><b>: </b><span>Type → Type</span></span></div></blockquote></div></small></div>List</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>List</var><b>: </b><span>Type → Type</span></span></div></blockquote></div></small></div>List</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token">)) : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>Type → Type u_1</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Option</var><b>: </b><span>Type → Type</span></span></div></blockquote></div></small></div>Option</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token">) := </span><span class="alectryon-token"><span class="k">do</span><span class="bp">&#39;</span></span><span class="alectryon-token">
  </span><span class="alectryon-token"><span class="k">for</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>xs</var><b>: </b><span>List α</span></span></div></blockquote></div></small></div><span class="nv">xs</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">in</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>xss</var><b>: </b><span>List (List α)</span></span></div></blockquote></div></small></div><span class="nv">xss</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">do</span><span class="bp">&#39;</span></span><span class="alectryon-token"> {
    </span><span class="alectryon-token"><span class="k">for</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">in</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>xs</var><b>: </b><span>List α</span></span></div></blockquote></div></small></div><span class="nv">xs</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">do</span><span class="bp">&#39;</span></span><span class="alectryon-token"> {
      </span><span class="alectryon-token"><span class="k">let</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token"> <span class="bp">←</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>p</var><b>: </b><span>α → m Bool</span></span></div></blockquote></div></small></div><span class="nv">p</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"><span class="bp">;</span>
      </span><span class="alectryon-token"><span class="k">if</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">then</span></span><span class="alectryon-token"> {
        </span><span class="alectryon-token"><span class="k">return</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>some</var><b>: </b><span>{α : Type} → α → Option α</span></span></div></blockquote></div></small></div>some</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token">
      }
    }
  }<span class="bp">;</span>
  </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>pure</var><b>: </b><span>{f : Type → Type u_1} → [self : Pure f] → {α : Type} → α → f α</span></span></div></blockquote></div></small></div>pure</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>none</var><b>: </b><span>{α : Type} → Option α</span></span></div></blockquote></div></small></div>none</span><span class="alectryon-token">

</span><span class="alectryon-token"><span class="kd">theorem</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>eq_findSomeM_findM</var><b>: </b><span>∀ {m : Type → Type u_1} {α : Type} [inst : Monad m] (p : α → m Bool) [inst_1 : LawfulMonad m] (xss : List (List α)),
  ex3 p xss = List.findSomeM? (fun xs =&gt; List.findM? p xs) xss</span></span></div></blockquote></div></small></div><span class="nv">eq_findSomeM_findM</span></span><span class="alectryon-token"> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>LawfulMonad</var><b>: </b><span>(m : Type → Type u_1) → [inst : Monad m] → Prop</span></span></div></blockquote></div></small></div>LawfulMonad</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>Type → Type u_1</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token">] (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>xss</var><b>: </b><span>List (List α)</span></span></div></blockquote></div></small></div><span class="nv">xss</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>List</var><b>: </b><span>Type → Type</span></span></div></blockquote></div></small></div>List</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>List</var><b>: </b><span>Type → Type</span></span></div></blockquote></div></small></div>List</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token">)) :
    </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ex3</var><b>: </b><span>{m : Type → Type u_1} → {α : Type} → [inst : Monad m] → (α → m Bool) → List (List α) → m (Option α)</span></span></div></blockquote></div></small></div>ex3</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>p</var><b>: </b><span>α → m Bool</span></span></div></blockquote></div></small></div><span class="nv">p</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>xss</var><b>: </b><span>List (List α)</span></span></div></blockquote></div></small></div><span class="nv">xss</span></span><span class="alectryon-token"> <span class="bp">=</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>xss</var><b>: </b><span>List (List α)</span></span></div></blockquote></div></small></div><span class="nv">xss</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>findSomeM?</var><b>: </b><span>{m : Type → Type u_1} → [inst : Monad m] → {α β : Type} → (α → m (Option β)) → List α → m (Option β)</span></span></div></blockquote></div></small></div>findSomeM<span class="bp">?</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><span class="k">fun</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>xs</var><b>: </b><span>List α</span></span></div></blockquote></div></small></div><span class="nv">xs</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>xs</var><b>: </b><span>List α</span></span></div></blockquote></div></small></div><span class="nv">xs</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>findM?</var><b>: </b><span>{m : Type → Type u_1} → [inst : Monad m] → {α : Type} → (α → m Bool) → List α → m (Option α)</span></span></div></blockquote></div></small></div>findM<span class="bp">?</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>p</var><b>: </b><span>α → m Bool</span></span></div></blockquote></div></small></div><span class="nv">p</span></span><span class="alectryon-token">) := </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="For-lean-chk38" style="display: none" type="checkbox"><label class="alectryon-input" for="For-lean-chk38"><span class="alectryon-token"><span class="kd">by</span></span><span class="alectryon-token"></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>ma, ma'</var><span class="hyp-type"><b>: </b><span>m α</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>List α</span></span></span><br><span><var>act</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> m Unit</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> m Bool</span></span></span><br><span><var>xss</var><span class="hyp-type"><b>: </b><span>List (List α)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ex3 p xss <span class="bp">=</span> List.findSomeM<span class="bp">?</span> (<span class="k">fun</span> xs <span class="bp">=&gt;</span> List.findM<span class="bp">?</span> p xs) xss</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="For-lean-chk39" style="display: none" type="checkbox"><label class="alectryon-input" for="For-lean-chk39"><span class="alectryon-token"><span class="k">unfold</span></span><span class="alectryon-token"> ex3</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>ma, ma'</var><span class="hyp-type"><b>: </b><span>m α</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>List α</span></span></span><br><span><var>act</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> m Unit</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> m Bool</span></span></span><br><span><var>xss</var><span class="hyp-type"><b>: </b><span>List (List α)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(ExceptCpsT.runCatch <span class="k">do</span>
    forM xss <span class="k">fun</span> xs <span class="bp">=&gt;</span>
        forM xs <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
          <span class="k">let</span> b <span class="bp">←</span> ExceptCpsT.lift (p x)
          <span class="k">if</span> b <span class="bp">=</span> true <span class="k">then</span> throw (some x) <span class="k">else</span> ExceptCpsT.lift (pure ())
    ExceptCpsT.lift (pure none)) <span class="bp">=</span>
  List.findSomeM<span class="bp">?</span> (<span class="k">fun</span> xs <span class="bp">=&gt;</span> List.findM<span class="bp">?</span> p xs) xss</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="For-lean-chk3a" style="display: none" type="checkbox"><label class="alectryon-input" for="For-lean-chk3a"><span class="alectryon-token"><span class="k">induction</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>xss</var><b>: </b><span>List (List α)</span></span></div></blockquote></div></small></div><span class="nv">xss</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">with</span></span><span class="alectryon-token"></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>ma, ma'</var><span class="hyp-type"><b>: </b><span>m α</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>List α</span></span></span><br><span><var>act</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> m Unit</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> m Bool</span></span></span><br><span><var>xss</var><span class="hyp-type"><b>: </b><span>List (List α)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(ExceptCpsT.runCatch <span class="k">do</span>
    forM xss <span class="k">fun</span> xs <span class="bp">=&gt;</span>
        forM xs <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
          <span class="k">let</span> b <span class="bp">←</span> ExceptCpsT.lift (p x)
          <span class="k">if</span> b <span class="bp">=</span> true <span class="k">then</span> throw (some x) <span class="k">else</span> ExceptCpsT.lift (pure ())
    ExceptCpsT.lift (pure none)) <span class="bp">=</span>
  List.findSomeM<span class="bp">?</span> (<span class="k">fun</span> xs <span class="bp">=&gt;</span> List.findM<span class="bp">?</span> p xs) xss</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="For-lean-chk3b" style="display: none" type="checkbox"><label class="alectryon-input" for="For-lean-chk3b"><span class="alectryon-token"><span class="bp">|</span> nil <span class="bp">=&gt;</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>ma, ma'</var><span class="hyp-type"><b>: </b><span>m α</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>List α</span></span></span><br><span><var>act</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> m Unit</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> m Bool</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">nil</span></span><div class="goal-conclusion">(ExceptCpsT.runCatch <span class="k">do</span>
    forM [] <span class="k">fun</span> xs <span class="bp">=&gt;</span>
        forM xs <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
          <span class="k">let</span> b <span class="bp">←</span> ExceptCpsT.lift (p x)
          <span class="k">if</span> b <span class="bp">=</span> true <span class="k">then</span> throw (some x) <span class="k">else</span> ExceptCpsT.lift (pure ())
    ExceptCpsT.lift (pure none)) <span class="bp">=</span>
  List.findSomeM<span class="bp">?</span> (<span class="k">fun</span> xs <span class="bp">=&gt;</span> List.findM<span class="bp">?</span> p xs) []</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="For-lean-chk3c" style="display: none" type="checkbox"><label class="alectryon-input" for="For-lean-chk3c"><span class="alectryon-token">simp<span class="bp">!</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="For-lean-chk3d" style="display: none" type="checkbox"><label class="alectryon-input" for="For-lean-chk3d"><span class="alectryon-token"><span class="bp">|</span> cons </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>xs</var><b>: </b><span>List α</span></span></div></blockquote></div></small></div><span class="nv">xs</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>xss</var><b>: </b><span>List (List α)</span></span></div></blockquote></div></small></div><span class="nv">xss</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ih</var><b>: </b><span>(ExceptCpsT.runCatch do
    forM xss fun xs =&gt;
        forM xs fun x =&gt; do
          let b ← ExceptCpsT.lift (p x)
          if b = true then throw (some x) else ExceptCpsT.lift (pure ())
    ExceptCpsT.lift (pure none)) =
  List.findSomeM? (fun xs =&gt; List.findM? p xs) xss</span></span></div></blockquote></div></small></div><span class="nv">ih</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>ma, ma'</var><span class="hyp-type"><b>: </b><span>m α</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>xs✝</var><span class="hyp-type"><b>: </b><span>List α</span></span></span><br><span><var>act</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> m Unit</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> m Bool</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>List α</span></span></span><br><span><var>xss</var><span class="hyp-type"><b>: </b><span>List (List α)</span></span></span><br><span><var>ih</var><span class="hyp-type"><b>: </b><span>(ExceptCpsT.runCatch <span class="k">do</span>
    forM xss <span class="k">fun</span> xs <span class="bp">=&gt;</span>
        forM xs <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
          <span class="k">let</span> b <span class="bp">←</span> ExceptCpsT.lift (p x)
          <span class="k">if</span> b <span class="bp">=</span> true <span class="k">then</span> throw (some x) <span class="k">else</span> ExceptCpsT.lift (pure ())
    ExceptCpsT.lift (pure none)) <span class="bp">=</span>
  List.findSomeM<span class="bp">?</span> (<span class="k">fun</span> xs <span class="bp">=&gt;</span> List.findM<span class="bp">?</span> p xs) xss</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">cons</span></span><div class="goal-conclusion">(ExceptCpsT.runCatch <span class="k">do</span>
    forM (xs :: xss) <span class="k">fun</span> xs <span class="bp">=&gt;</span>
        forM xs <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
          <span class="k">let</span> b <span class="bp">←</span> ExceptCpsT.lift (p x)
          <span class="k">if</span> b <span class="bp">=</span> true <span class="k">then</span> throw (some x) <span class="k">else</span> ExceptCpsT.lift (pure ())
    ExceptCpsT.lift (pure none)) <span class="bp">=</span>
  List.findSomeM<span class="bp">?</span> (<span class="k">fun</span> xs <span class="bp">=&gt;</span> List.findM<span class="bp">?</span> p xs) (xs :: xss)</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
    </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="For-lean-chk3e" style="display: none" type="checkbox"><label class="alectryon-input" for="For-lean-chk3e"><span class="alectryon-token"><span class="k">simp</span></span><span class="alectryon-token"> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>List.findSomeM?</var><b>: </b><span>{m : Type ?u.27569 → Type ?u.27568} →
  [inst : Monad m] → {α : Type ?u.27567} → {β : Type ?u.27569} → (α → m (Option β)) → List α → m (Option β)</span></span></div></blockquote></div></small></div>List.findSomeM<span class="bp">?</span></span><span class="alectryon-token">]</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>ma, ma'</var><span class="hyp-type"><b>: </b><span>m α</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>xs✝</var><span class="hyp-type"><b>: </b><span>List α</span></span></span><br><span><var>act</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> m Unit</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> m Bool</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>List α</span></span></span><br><span><var>xss</var><span class="hyp-type"><b>: </b><span>List (List α)</span></span></span><br><span><var>ih</var><span class="hyp-type"><b>: </b><span>(ExceptCpsT.runCatch <span class="k">do</span>
    forM xss <span class="k">fun</span> xs <span class="bp">=&gt;</span>
        forM xs <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
          <span class="k">let</span> b <span class="bp">←</span> ExceptCpsT.lift (p x)
          <span class="k">if</span> b <span class="bp">=</span> true <span class="k">then</span> throw (some x) <span class="k">else</span> ExceptCpsT.lift (pure ())
    ExceptCpsT.lift (pure none)) <span class="bp">=</span>
  List.findSomeM<span class="bp">?</span> (<span class="k">fun</span> xs <span class="bp">=&gt;</span> List.findM<span class="bp">?</span> p xs) xss</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">cons</span></span><div class="goal-conclusion">(ExceptCpsT.runCatch <span class="k">do</span>
    forM xs <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
        <span class="k">let</span> b <span class="bp">←</span> ExceptCpsT.lift (p x)
        <span class="k">if</span> b <span class="bp">=</span> true <span class="k">then</span> throw (some x) <span class="k">else</span> ExceptCpsT.lift (pure ())
    forM xss <span class="k">fun</span> xs <span class="bp">=&gt;</span>
        forM xs <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
          <span class="k">let</span> b <span class="bp">←</span> ExceptCpsT.lift (p x)
          <span class="k">if</span> b <span class="bp">=</span> true <span class="k">then</span> throw (some x) <span class="k">else</span> ExceptCpsT.lift (pure ())
    ExceptCpsT.lift (pure none)) <span class="bp">=</span>
  <span class="k">do</span>
  <span class="k">let</span> a <span class="bp">←</span> List.findM<span class="bp">?</span> p xs
  <span class="k">match</span> a <span class="k">with</span>
    <span class="bp">|</span> some b <span class="bp">=&gt;</span> pure (some b)
    <span class="bp">|</span> none <span class="bp">=&gt;</span> List.findSomeM<span class="bp">?</span> (<span class="k">fun</span> xs <span class="bp">=&gt;</span> List.findM<span class="bp">?</span> p xs) xss</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
    </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="For-lean-chk3f" style="display: none" type="checkbox"><label class="alectryon-input" for="For-lean-chk3f"><span class="alectryon-token"><span class="k">rw</span></span><span class="alectryon-token"> [</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>ma, ma'</var><span class="hyp-type"><b>: </b><span>m α</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>xs✝</var><span class="hyp-type"><b>: </b><span>List α</span></span></span><br><span><var>act</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> m Unit</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> m Bool</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>List α</span></span></span><br><span><var>xss</var><span class="hyp-type"><b>: </b><span>List (List α)</span></span></span><br><span><var>ih</var><span class="hyp-type"><b>: </b><span>(ExceptCpsT.runCatch <span class="k">do</span>
    forM xss <span class="k">fun</span> xs <span class="bp">=&gt;</span>
        forM xs <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
          <span class="k">let</span> b <span class="bp">←</span> ExceptCpsT.lift (p x)
          <span class="k">if</span> b <span class="bp">=</span> true <span class="k">then</span> throw (some x) <span class="k">else</span> ExceptCpsT.lift (pure ())
    ExceptCpsT.lift (pure none)) <span class="bp">=</span>
  List.findSomeM<span class="bp">?</span> (<span class="k">fun</span> xs <span class="bp">=&gt;</span> List.findM<span class="bp">?</span> p xs) xss</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">cons</span></span><div class="goal-conclusion">(ExceptCpsT.runCatch <span class="k">do</span>
    forM xs <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
        <span class="k">let</span> b <span class="bp">←</span> ExceptCpsT.lift (p x)
        <span class="k">if</span> b <span class="bp">=</span> true <span class="k">then</span> throw (some x) <span class="k">else</span> ExceptCpsT.lift (pure ())
    forM xss <span class="k">fun</span> xs <span class="bp">=&gt;</span>
        forM xs <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
          <span class="k">let</span> b <span class="bp">←</span> ExceptCpsT.lift (p x)
          <span class="k">if</span> b <span class="bp">=</span> true <span class="k">then</span> throw (some x) <span class="k">else</span> ExceptCpsT.lift (pure ())
    ExceptCpsT.lift (pure none)) <span class="bp">=</span>
  <span class="k">do</span>
  <span class="k">let</span> a <span class="bp">←</span> List.findM<span class="bp">?</span> p xs
  <span class="k">match</span> a <span class="k">with</span>
    <span class="bp">|</span> some b <span class="bp">=&gt;</span> pure (some b)
    <span class="bp">|</span> none <span class="bp">=&gt;</span> List.findSomeM<span class="bp">?</span> (<span class="k">fun</span> xs <span class="bp">=&gt;</span> List.findM<span class="bp">?</span> p xs) xss</div></blockquote></div></div></small></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="For-lean-chk40" style="display: none" type="checkbox"><label class="alectryon-input" for="For-lean-chk40"><span class="alectryon-token"><span class="bp">←</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ih</var><b>: </b><span>(ExceptCpsT.runCatch do
    forM xss fun xs =&gt;
        forM xs fun x =&gt; do
          let b ← ExceptCpsT.lift (p x)
          if b = true then throw (some x) else ExceptCpsT.lift (pure ())
    ExceptCpsT.lift (pure none)) =
  List.findSomeM? (fun xs =&gt; List.findM? p xs) xss</span></span></div></blockquote></div></small></div><span class="nv">ih</span></span><span class="alectryon-token">,</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>ma, ma'</var><span class="hyp-type"><b>: </b><span>m α</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>xs✝</var><span class="hyp-type"><b>: </b><span>List α</span></span></span><br><span><var>act</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> m Unit</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> m Bool</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>List α</span></span></span><br><span><var>xss</var><span class="hyp-type"><b>: </b><span>List (List α)</span></span></span><br><span><var>ih</var><span class="hyp-type"><b>: </b><span>(ExceptCpsT.runCatch <span class="k">do</span>
    forM xss <span class="k">fun</span> xs <span class="bp">=&gt;</span>
        forM xs <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
          <span class="k">let</span> b <span class="bp">←</span> ExceptCpsT.lift (p x)
          <span class="k">if</span> b <span class="bp">=</span> true <span class="k">then</span> throw (some x) <span class="k">else</span> ExceptCpsT.lift (pure ())
    ExceptCpsT.lift (pure none)) <span class="bp">=</span>
  List.findSomeM<span class="bp">?</span> (<span class="k">fun</span> xs <span class="bp">=&gt;</span> List.findM<span class="bp">?</span> p xs) xss</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">cons</span></span><div class="goal-conclusion">(ExceptCpsT.runCatch <span class="k">do</span>
    forM xs <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
        <span class="k">let</span> b <span class="bp">←</span> ExceptCpsT.lift (p x)
        <span class="k">if</span> b <span class="bp">=</span> true <span class="k">then</span> throw (some x) <span class="k">else</span> ExceptCpsT.lift (pure ())
    forM xss <span class="k">fun</span> xs <span class="bp">=&gt;</span>
        forM xs <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
          <span class="k">let</span> b <span class="bp">←</span> ExceptCpsT.lift (p x)
          <span class="k">if</span> b <span class="bp">=</span> true <span class="k">then</span> throw (some x) <span class="k">else</span> ExceptCpsT.lift (pure ())
    ExceptCpsT.lift (pure none)) <span class="bp">=</span>
  <span class="k">do</span>
  <span class="k">let</span> a <span class="bp">←</span> List.findM<span class="bp">?</span> p xs
  <span class="k">match</span> a <span class="k">with</span>
    <span class="bp">|</span> some b <span class="bp">=&gt;</span> pure (some b)
    <span class="bp">|</span> none <span class="bp">=&gt;</span>
      ExceptCpsT.runCatch <span class="k">do</span>
        forM xss <span class="k">fun</span> xs <span class="bp">=&gt;</span>
            forM xs <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
              <span class="k">let</span> b <span class="bp">←</span> ExceptCpsT.lift (p x)
              <span class="k">if</span> b <span class="bp">=</span> true <span class="k">then</span> throw (some x) <span class="k">else</span> ExceptCpsT.lift (pure ())
        ExceptCpsT.lift (pure none)</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="For-lean-chk41" style="display: none" type="checkbox"><label class="alectryon-input" for="For-lean-chk41"><span class="alectryon-token"><span class="bp">←</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>eq_findM</var><b>: </b><span>∀ {m : Type → Type u_1} {α : Type} [inst : Monad m] (xs : List α) (p : α → m Bool) [inst_1 : LawfulMonad m],
  (ExceptCpsT.runCatch do
      forM xs fun x =&gt; do
          let b ← ExceptCpsT.lift (p x)
          if b = true then throw (some x) else ExceptCpsT.lift (pure ())
      ExceptCpsT.lift (pure none)) =
    List.findM? p xs</span></span></div></blockquote></div></small></div>eq_findM</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>ma, ma'</var><span class="hyp-type"><b>: </b><span>m α</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>xs✝</var><span class="hyp-type"><b>: </b><span>List α</span></span></span><br><span><var>act</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> m Unit</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> m Bool</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>List α</span></span></span><br><span><var>xss</var><span class="hyp-type"><b>: </b><span>List (List α)</span></span></span><br><span><var>ih</var><span class="hyp-type"><b>: </b><span>(ExceptCpsT.runCatch <span class="k">do</span>
    forM xss <span class="k">fun</span> xs <span class="bp">=&gt;</span>
        forM xs <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
          <span class="k">let</span> b <span class="bp">←</span> ExceptCpsT.lift (p x)
          <span class="k">if</span> b <span class="bp">=</span> true <span class="k">then</span> throw (some x) <span class="k">else</span> ExceptCpsT.lift (pure ())
    ExceptCpsT.lift (pure none)) <span class="bp">=</span>
  List.findSomeM<span class="bp">?</span> (<span class="k">fun</span> xs <span class="bp">=&gt;</span> List.findM<span class="bp">?</span> p xs) xss</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">cons</span></span><div class="goal-conclusion">(ExceptCpsT.runCatch <span class="k">do</span>
    forM xs <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
        <span class="k">let</span> b <span class="bp">←</span> ExceptCpsT.lift (p x)
        <span class="k">if</span> b <span class="bp">=</span> true <span class="k">then</span> throw (some x) <span class="k">else</span> ExceptCpsT.lift (pure ())
    forM xss <span class="k">fun</span> xs <span class="bp">=&gt;</span>
        forM xs <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
          <span class="k">let</span> b <span class="bp">←</span> ExceptCpsT.lift (p x)
          <span class="k">if</span> b <span class="bp">=</span> true <span class="k">then</span> throw (some x) <span class="k">else</span> ExceptCpsT.lift (pure ())
    ExceptCpsT.lift (pure none)) <span class="bp">=</span>
  <span class="k">do</span>
  <span class="k">let</span> a <span class="bp">←</span>
    ExceptCpsT.runCatch <span class="k">do</span>
        forM xs <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
            <span class="k">let</span> b <span class="bp">←</span> ExceptCpsT.lift (p x)
            <span class="k">if</span> b <span class="bp">=</span> true <span class="k">then</span> throw (some x) <span class="k">else</span> ExceptCpsT.lift (pure ())
        ExceptCpsT.lift (pure none)
  <span class="k">match</span> a <span class="k">with</span>
    <span class="bp">|</span> some b <span class="bp">=&gt;</span> pure (some b)
    <span class="bp">|</span> none <span class="bp">=&gt;</span>
      ExceptCpsT.runCatch <span class="k">do</span>
        forM xss <span class="k">fun</span> xs <span class="bp">=&gt;</span>
            forM xs <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
              <span class="k">let</span> b <span class="bp">←</span> ExceptCpsT.lift (p x)
              <span class="k">if</span> b <span class="bp">=</span> true <span class="k">then</span> throw (some x) <span class="k">else</span> ExceptCpsT.lift (pure ())
        ExceptCpsT.lift (pure none)</div></blockquote></div></div></small></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="For-lean-chk42" style="display: none" type="checkbox"><label class="alectryon-input" for="For-lean-chk42"><span class="alectryon-token">]</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>ma, ma'</var><span class="hyp-type"><b>: </b><span>m α</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>xs✝</var><span class="hyp-type"><b>: </b><span>List α</span></span></span><br><span><var>act</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> m Unit</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> m Bool</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>List α</span></span></span><br><span><var>xss</var><span class="hyp-type"><b>: </b><span>List (List α)</span></span></span><br><span><var>ih</var><span class="hyp-type"><b>: </b><span>(ExceptCpsT.runCatch <span class="k">do</span>
    forM xss <span class="k">fun</span> xs <span class="bp">=&gt;</span>
        forM xs <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
          <span class="k">let</span> b <span class="bp">←</span> ExceptCpsT.lift (p x)
          <span class="k">if</span> b <span class="bp">=</span> true <span class="k">then</span> throw (some x) <span class="k">else</span> ExceptCpsT.lift (pure ())
    ExceptCpsT.lift (pure none)) <span class="bp">=</span>
  List.findSomeM<span class="bp">?</span> (<span class="k">fun</span> xs <span class="bp">=&gt;</span> List.findM<span class="bp">?</span> p xs) xss</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">cons</span></span><div class="goal-conclusion">(ExceptCpsT.runCatch <span class="k">do</span>
    forM xs <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
        <span class="k">let</span> b <span class="bp">←</span> ExceptCpsT.lift (p x)
        <span class="k">if</span> b <span class="bp">=</span> true <span class="k">then</span> throw (some x) <span class="k">else</span> ExceptCpsT.lift (pure ())
    forM xss <span class="k">fun</span> xs <span class="bp">=&gt;</span>
        forM xs <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
          <span class="k">let</span> b <span class="bp">←</span> ExceptCpsT.lift (p x)
          <span class="k">if</span> b <span class="bp">=</span> true <span class="k">then</span> throw (some x) <span class="k">else</span> ExceptCpsT.lift (pure ())
    ExceptCpsT.lift (pure none)) <span class="bp">=</span>
  <span class="k">do</span>
  <span class="k">let</span> a <span class="bp">←</span>
    ExceptCpsT.runCatch <span class="k">do</span>
        forM xs <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
            <span class="k">let</span> b <span class="bp">←</span> ExceptCpsT.lift (p x)
            <span class="k">if</span> b <span class="bp">=</span> true <span class="k">then</span> throw (some x) <span class="k">else</span> ExceptCpsT.lift (pure ())
        ExceptCpsT.lift (pure none)
  <span class="k">match</span> a <span class="k">with</span>
    <span class="bp">|</span> some b <span class="bp">=&gt;</span> pure (some b)
    <span class="bp">|</span> none <span class="bp">=&gt;</span>
      ExceptCpsT.runCatch <span class="k">do</span>
        forM xss <span class="k">fun</span> xs <span class="bp">=&gt;</span>
            forM xs <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
              <span class="k">let</span> b <span class="bp">←</span> ExceptCpsT.lift (p x)
              <span class="k">if</span> b <span class="bp">=</span> true <span class="k">then</span> throw (some x) <span class="k">else</span> ExceptCpsT.lift (pure ())
        ExceptCpsT.lift (pure none)</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
    </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="For-lean-chk43" style="display: none" type="checkbox"><label class="alectryon-input" for="For-lean-chk43"><span class="alectryon-token"><span class="k">induction</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>xs</var><b>: </b><span>List α</span></span></div></blockquote></div></small></div><span class="nv">xs</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">with</span></span><span class="alectryon-token"></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>ma, ma'</var><span class="hyp-type"><b>: </b><span>m α</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>xs✝</var><span class="hyp-type"><b>: </b><span>List α</span></span></span><br><span><var>act</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> m Unit</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> m Bool</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>List α</span></span></span><br><span><var>xss</var><span class="hyp-type"><b>: </b><span>List (List α)</span></span></span><br><span><var>ih</var><span class="hyp-type"><b>: </b><span>(ExceptCpsT.runCatch <span class="k">do</span>
    forM xss <span class="k">fun</span> xs <span class="bp">=&gt;</span>
        forM xs <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
          <span class="k">let</span> b <span class="bp">←</span> ExceptCpsT.lift (p x)
          <span class="k">if</span> b <span class="bp">=</span> true <span class="k">then</span> throw (some x) <span class="k">else</span> ExceptCpsT.lift (pure ())
    ExceptCpsT.lift (pure none)) <span class="bp">=</span>
  List.findSomeM<span class="bp">?</span> (<span class="k">fun</span> xs <span class="bp">=&gt;</span> List.findM<span class="bp">?</span> p xs) xss</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">cons</span></span><div class="goal-conclusion">(ExceptCpsT.runCatch <span class="k">do</span>
    forM xs <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
        <span class="k">let</span> b <span class="bp">←</span> ExceptCpsT.lift (p x)
        <span class="k">if</span> b <span class="bp">=</span> true <span class="k">then</span> throw (some x) <span class="k">else</span> ExceptCpsT.lift (pure ())
    forM xss <span class="k">fun</span> xs <span class="bp">=&gt;</span>
        forM xs <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
          <span class="k">let</span> b <span class="bp">←</span> ExceptCpsT.lift (p x)
          <span class="k">if</span> b <span class="bp">=</span> true <span class="k">then</span> throw (some x) <span class="k">else</span> ExceptCpsT.lift (pure ())
    ExceptCpsT.lift (pure none)) <span class="bp">=</span>
  <span class="k">do</span>
  <span class="k">let</span> a <span class="bp">←</span>
    ExceptCpsT.runCatch <span class="k">do</span>
        forM xs <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
            <span class="k">let</span> b <span class="bp">←</span> ExceptCpsT.lift (p x)
            <span class="k">if</span> b <span class="bp">=</span> true <span class="k">then</span> throw (some x) <span class="k">else</span> ExceptCpsT.lift (pure ())
        ExceptCpsT.lift (pure none)
  <span class="k">match</span> a <span class="k">with</span>
    <span class="bp">|</span> some b <span class="bp">=&gt;</span> pure (some b)
    <span class="bp">|</span> none <span class="bp">=&gt;</span>
      ExceptCpsT.runCatch <span class="k">do</span>
        forM xss <span class="k">fun</span> xs <span class="bp">=&gt;</span>
            forM xs <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
              <span class="k">let</span> b <span class="bp">←</span> ExceptCpsT.lift (p x)
              <span class="k">if</span> b <span class="bp">=</span> true <span class="k">then</span> throw (some x) <span class="k">else</span> ExceptCpsT.lift (pure ())
        ExceptCpsT.lift (pure none)</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
    </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="For-lean-chk44" style="display: none" type="checkbox"><label class="alectryon-input" for="For-lean-chk44"><span class="alectryon-token"><span class="bp">|</span> nil <span class="bp">=&gt;</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>ma, ma'</var><span class="hyp-type"><b>: </b><span>m α</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>List α</span></span></span><br><span><var>act</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> m Unit</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> m Bool</span></span></span><br><span><var>xss</var><span class="hyp-type"><b>: </b><span>List (List α)</span></span></span><br><span><var>ih</var><span class="hyp-type"><b>: </b><span>(ExceptCpsT.runCatch <span class="k">do</span>
    forM xss <span class="k">fun</span> xs <span class="bp">=&gt;</span>
        forM xs <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
          <span class="k">let</span> b <span class="bp">←</span> ExceptCpsT.lift (p x)
          <span class="k">if</span> b <span class="bp">=</span> true <span class="k">then</span> throw (some x) <span class="k">else</span> ExceptCpsT.lift (pure ())
    ExceptCpsT.lift (pure none)) <span class="bp">=</span>
  List.findSomeM<span class="bp">?</span> (<span class="k">fun</span> xs <span class="bp">=&gt;</span> List.findM<span class="bp">?</span> p xs) xss</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">cons.nil</span></span><div class="goal-conclusion">(ExceptCpsT.runCatch <span class="k">do</span>
    forM [] <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
        <span class="k">let</span> b <span class="bp">←</span> ExceptCpsT.lift (p x)
        <span class="k">if</span> b <span class="bp">=</span> true <span class="k">then</span> throw (some x) <span class="k">else</span> ExceptCpsT.lift (pure ())
    forM xss <span class="k">fun</span> xs <span class="bp">=&gt;</span>
        forM xs <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
          <span class="k">let</span> b <span class="bp">←</span> ExceptCpsT.lift (p x)
          <span class="k">if</span> b <span class="bp">=</span> true <span class="k">then</span> throw (some x) <span class="k">else</span> ExceptCpsT.lift (pure ())
    ExceptCpsT.lift (pure none)) <span class="bp">=</span>
  <span class="k">do</span>
  <span class="k">let</span> a <span class="bp">←</span>
    ExceptCpsT.runCatch <span class="k">do</span>
        forM [] <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
            <span class="k">let</span> b <span class="bp">←</span> ExceptCpsT.lift (p x)
            <span class="k">if</span> b <span class="bp">=</span> true <span class="k">then</span> throw (some x) <span class="k">else</span> ExceptCpsT.lift (pure ())
        ExceptCpsT.lift (pure none)
  <span class="k">match</span> a <span class="k">with</span>
    <span class="bp">|</span> some b <span class="bp">=&gt;</span> pure (some b)
    <span class="bp">|</span> none <span class="bp">=&gt;</span>
      ExceptCpsT.runCatch <span class="k">do</span>
        forM xss <span class="k">fun</span> xs <span class="bp">=&gt;</span>
            forM xs <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
              <span class="k">let</span> b <span class="bp">←</span> ExceptCpsT.lift (p x)
              <span class="k">if</span> b <span class="bp">=</span> true <span class="k">then</span> throw (some x) <span class="k">else</span> ExceptCpsT.lift (pure ())
        ExceptCpsT.lift (pure none)</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="For-lean-chk45" style="display: none" type="checkbox"><label class="alectryon-input" for="For-lean-chk45"><span class="alectryon-token"><span class="k">simp</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
    </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="For-lean-chk46" style="display: none" type="checkbox"><label class="alectryon-input" for="For-lean-chk46"><span class="alectryon-token"><span class="bp">|</span> cons </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>xs</var><b>: </b><span>List α</span></span></div></blockquote></div></small></div><span class="nv">xs</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ih</var><b>: </b><span>(ExceptCpsT.runCatch do
    forM xs fun x =&gt; do
        let b ← ExceptCpsT.lift (p x)
        if b = true then throw (some x) else ExceptCpsT.lift (pure ())
    forM xss fun xs =&gt;
        forM xs fun x =&gt; do
          let b ← ExceptCpsT.lift (p x)
          if b = true then throw (some x) else ExceptCpsT.lift (pure ())
    ExceptCpsT.lift (pure none)) =
  do
  let a ←
    ExceptCpsT.runCatch do
        forM xs fun x =&gt; do
            let b ← ExceptCpsT.lift (p x)
            if b = true then throw (some x) else ExceptCpsT.lift (pure ())
        ExceptCpsT.lift (pure none)
  match a with
    | some b =&gt; pure (some b)
    | none =&gt;
      ExceptCpsT.runCatch do
        forM xss fun xs =&gt;
            forM xs fun x =&gt; do
              let b ← ExceptCpsT.lift (p x)
              if b = true then throw (some x) else ExceptCpsT.lift (pure ())
        ExceptCpsT.lift (pure none)</span></span></div></blockquote></div></small></div><span class="nv">ih</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>ma, ma'</var><span class="hyp-type"><b>: </b><span>m α</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>xs✝</var><span class="hyp-type"><b>: </b><span>List α</span></span></span><br><span><var>act</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> m Unit</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> m Bool</span></span></span><br><span><var>xss</var><span class="hyp-type"><b>: </b><span>List (List α)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>List α</span></span></span><br><span><var>ih</var><span class="hyp-type"><b>: </b><span>(ExceptCpsT.runCatch <span class="k">do</span>
    forM xs <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
        <span class="k">let</span> b <span class="bp">←</span> ExceptCpsT.lift (p x)
        <span class="k">if</span> b <span class="bp">=</span> true <span class="k">then</span> throw (some x) <span class="k">else</span> ExceptCpsT.lift (pure ())
    forM xss <span class="k">fun</span> xs <span class="bp">=&gt;</span>
        forM xs <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
          <span class="k">let</span> b <span class="bp">←</span> ExceptCpsT.lift (p x)
          <span class="k">if</span> b <span class="bp">=</span> true <span class="k">then</span> throw (some x) <span class="k">else</span> ExceptCpsT.lift (pure ())
    ExceptCpsT.lift (pure none)) <span class="bp">=</span>
  <span class="k">do</span>
  <span class="k">let</span> a <span class="bp">←</span>
    ExceptCpsT.runCatch <span class="k">do</span>
        forM xs <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
            <span class="k">let</span> b <span class="bp">←</span> ExceptCpsT.lift (p x)
            <span class="k">if</span> b <span class="bp">=</span> true <span class="k">then</span> throw (some x) <span class="k">else</span> ExceptCpsT.lift (pure ())
        ExceptCpsT.lift (pure none)
  <span class="k">match</span> a <span class="k">with</span>
    <span class="bp">|</span> some b <span class="bp">=&gt;</span> pure (some b)
    <span class="bp">|</span> none <span class="bp">=&gt;</span>
      ExceptCpsT.runCatch <span class="k">do</span>
        forM xss <span class="k">fun</span> xs <span class="bp">=&gt;</span>
            forM xs <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
              <span class="k">let</span> b <span class="bp">←</span> ExceptCpsT.lift (p x)
              <span class="k">if</span> b <span class="bp">=</span> true <span class="k">then</span> throw (some x) <span class="k">else</span> ExceptCpsT.lift (pure ())
        ExceptCpsT.lift (pure none)</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">cons.cons</span></span><div class="goal-conclusion">(ExceptCpsT.runCatch <span class="k">do</span>
    forM (x :: xs) <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
        <span class="k">let</span> b <span class="bp">←</span> ExceptCpsT.lift (p x)
        <span class="k">if</span> b <span class="bp">=</span> true <span class="k">then</span> throw (some x) <span class="k">else</span> ExceptCpsT.lift (pure ())
    forM xss <span class="k">fun</span> xs <span class="bp">=&gt;</span>
        forM xs <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
          <span class="k">let</span> b <span class="bp">←</span> ExceptCpsT.lift (p x)
          <span class="k">if</span> b <span class="bp">=</span> true <span class="k">then</span> throw (some x) <span class="k">else</span> ExceptCpsT.lift (pure ())
    ExceptCpsT.lift (pure none)) <span class="bp">=</span>
  <span class="k">do</span>
  <span class="k">let</span> a <span class="bp">←</span>
    ExceptCpsT.runCatch <span class="k">do</span>
        forM (x :: xs) <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
            <span class="k">let</span> b <span class="bp">←</span> ExceptCpsT.lift (p x)
            <span class="k">if</span> b <span class="bp">=</span> true <span class="k">then</span> throw (some x) <span class="k">else</span> ExceptCpsT.lift (pure ())
        ExceptCpsT.lift (pure none)
  <span class="k">match</span> a <span class="k">with</span>
    <span class="bp">|</span> some b <span class="bp">=&gt;</span> pure (some b)
    <span class="bp">|</span> none <span class="bp">=&gt;</span>
      ExceptCpsT.runCatch <span class="k">do</span>
        forM xss <span class="k">fun</span> xs <span class="bp">=&gt;</span>
            forM xs <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
              <span class="k">let</span> b <span class="bp">←</span> ExceptCpsT.lift (p x)
              <span class="k">if</span> b <span class="bp">=</span> true <span class="k">then</span> throw (some x) <span class="k">else</span> ExceptCpsT.lift (pure ())
        ExceptCpsT.lift (pure none)</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="For-lean-chk47" style="display: none" type="checkbox"><label class="alectryon-input" for="For-lean-chk47"><span class="alectryon-token"><span class="k">simp</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>ma, ma'</var><span class="hyp-type"><b>: </b><span>m α</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>xs✝</var><span class="hyp-type"><b>: </b><span>List α</span></span></span><br><span><var>act</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> m Unit</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> m Bool</span></span></span><br><span><var>xss</var><span class="hyp-type"><b>: </b><span>List (List α)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>List α</span></span></span><br><span><var>ih</var><span class="hyp-type"><b>: </b><span>(ExceptCpsT.runCatch <span class="k">do</span>
    forM xs <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
        <span class="k">let</span> b <span class="bp">←</span> ExceptCpsT.lift (p x)
        <span class="k">if</span> b <span class="bp">=</span> true <span class="k">then</span> throw (some x) <span class="k">else</span> ExceptCpsT.lift (pure ())
    forM xss <span class="k">fun</span> xs <span class="bp">=&gt;</span>
        forM xs <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
          <span class="k">let</span> b <span class="bp">←</span> ExceptCpsT.lift (p x)
          <span class="k">if</span> b <span class="bp">=</span> true <span class="k">then</span> throw (some x) <span class="k">else</span> ExceptCpsT.lift (pure ())
    ExceptCpsT.lift (pure none)) <span class="bp">=</span>
  <span class="k">do</span>
  <span class="k">let</span> a <span class="bp">←</span>
    ExceptCpsT.runCatch <span class="k">do</span>
        forM xs <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
            <span class="k">let</span> b <span class="bp">←</span> ExceptCpsT.lift (p x)
            <span class="k">if</span> b <span class="bp">=</span> true <span class="k">then</span> throw (some x) <span class="k">else</span> ExceptCpsT.lift (pure ())
        ExceptCpsT.lift (pure none)
  <span class="k">match</span> a <span class="k">with</span>
    <span class="bp">|</span> some b <span class="bp">=&gt;</span> pure (some b)
    <span class="bp">|</span> none <span class="bp">=&gt;</span>
      ExceptCpsT.runCatch <span class="k">do</span>
        forM xss <span class="k">fun</span> xs <span class="bp">=&gt;</span>
            forM xs <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
              <span class="k">let</span> b <span class="bp">←</span> ExceptCpsT.lift (p x)
              <span class="k">if</span> b <span class="bp">=</span> true <span class="k">then</span> throw (some x) <span class="k">else</span> ExceptCpsT.lift (pure ())
        ExceptCpsT.lift (pure none)</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">cons.cons</span></span><div class="goal-conclusion">(<span class="k">do</span>
    <span class="k">let</span> a <span class="bp">←</span> p x
    ExceptCpsT.runCatch <span class="k">do</span>
        <span class="k">if</span> a <span class="bp">=</span> true <span class="k">then</span> throw (some x) <span class="k">else</span> ExceptCpsT.lift (pure ())
        forM xs <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
            <span class="k">let</span> b <span class="bp">←</span> ExceptCpsT.lift (p x)
            <span class="k">if</span> b <span class="bp">=</span> true <span class="k">then</span> throw (some x) <span class="k">else</span> ExceptCpsT.lift (pure ())
        forM xss <span class="k">fun</span> xs <span class="bp">=&gt;</span>
            forM xs <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
              <span class="k">let</span> b <span class="bp">←</span> ExceptCpsT.lift (p x)
              <span class="k">if</span> b <span class="bp">=</span> true <span class="k">then</span> throw (some x) <span class="k">else</span> ExceptCpsT.lift (pure ())
        ExceptCpsT.lift (pure none)) <span class="bp">=</span>
  <span class="k">do</span>
  <span class="k">let</span> x_1 <span class="bp">←</span> p x
  <span class="k">let</span> a <span class="bp">←</span>
    ExceptCpsT.runCatch <span class="k">do</span>
        <span class="k">if</span> x_1 <span class="bp">=</span> true <span class="k">then</span> throw (some x) <span class="k">else</span> ExceptCpsT.lift (pure ())
        forM xs <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
            <span class="k">let</span> b <span class="bp">←</span> ExceptCpsT.lift (p x)
            <span class="k">if</span> b <span class="bp">=</span> true <span class="k">then</span> throw (some x) <span class="k">else</span> ExceptCpsT.lift (pure ())
        ExceptCpsT.lift (pure none)
  <span class="k">match</span> a <span class="k">with</span>
    <span class="bp">|</span> some b <span class="bp">=&gt;</span> pure (some b)
    <span class="bp">|</span> none <span class="bp">=&gt;</span>
      ExceptCpsT.runCatch <span class="k">do</span>
        forM xss <span class="k">fun</span> xs <span class="bp">=&gt;</span>
            forM xs <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
              <span class="k">let</span> b <span class="bp">←</span> ExceptCpsT.lift (p x)
              <span class="k">if</span> b <span class="bp">=</span> true <span class="k">then</span> throw (some x) <span class="k">else</span> ExceptCpsT.lift (pure ())
        ExceptCpsT.lift (pure none)</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"><span class="bp">;</span></span><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="For-lean-chk48" style="display: none" type="checkbox"><label class="alectryon-input" for="For-lean-chk48"><span class="alectryon-token"><span class="k">apply</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>byCases_Bool_bind</var><b>: </b><span>∀ {m : Type → Type u_1} [inst : Monad m] {β : Type} (x : m Bool) (f g : Bool → m β),
  f true = g true → f false = g false → x &gt;&gt;= f = x &gt;&gt;= g</span></span></div></blockquote></div></small></div><span class="k">byCases_Bool_bind</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>ma, ma'</var><span class="hyp-type"><b>: </b><span>m α</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>xs✝</var><span class="hyp-type"><b>: </b><span>List α</span></span></span><br><span><var>act</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> m Unit</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> m Bool</span></span></span><br><span><var>xss</var><span class="hyp-type"><b>: </b><span>List (List α)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>List α</span></span></span><br><span><var>ih</var><span class="hyp-type"><b>: </b><span>(ExceptCpsT.runCatch <span class="k">do</span>
    forM xs <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
        <span class="k">let</span> b <span class="bp">←</span> ExceptCpsT.lift (p x)
        <span class="k">if</span> b <span class="bp">=</span> true <span class="k">then</span> throw (some x) <span class="k">else</span> ExceptCpsT.lift (pure ())
    forM xss <span class="k">fun</span> xs <span class="bp">=&gt;</span>
        forM xs <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
          <span class="k">let</span> b <span class="bp">←</span> ExceptCpsT.lift (p x)
          <span class="k">if</span> b <span class="bp">=</span> true <span class="k">then</span> throw (some x) <span class="k">else</span> ExceptCpsT.lift (pure ())
    ExceptCpsT.lift (pure none)) <span class="bp">=</span>
  <span class="k">do</span>
  <span class="k">let</span> a <span class="bp">←</span>
    ExceptCpsT.runCatch <span class="k">do</span>
        forM xs <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
            <span class="k">let</span> b <span class="bp">←</span> ExceptCpsT.lift (p x)
            <span class="k">if</span> b <span class="bp">=</span> true <span class="k">then</span> throw (some x) <span class="k">else</span> ExceptCpsT.lift (pure ())
        ExceptCpsT.lift (pure none)
  <span class="k">match</span> a <span class="k">with</span>
    <span class="bp">|</span> some b <span class="bp">=&gt;</span> pure (some b)
    <span class="bp">|</span> none <span class="bp">=&gt;</span>
      ExceptCpsT.runCatch <span class="k">do</span>
        forM xss <span class="k">fun</span> xs <span class="bp">=&gt;</span>
            forM xs <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
              <span class="k">let</span> b <span class="bp">←</span> ExceptCpsT.lift (p x)
              <span class="k">if</span> b <span class="bp">=</span> true <span class="k">then</span> throw (some x) <span class="k">else</span> ExceptCpsT.lift (pure ())
        ExceptCpsT.lift (pure none)</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">cons.cons.isTrue</span></span><div class="goal-conclusion">(ExceptCpsT.runCatch <span class="k">do</span>
    <span class="k">if</span> true <span class="bp">=</span> true <span class="k">then</span> throw (some x) <span class="k">else</span> ExceptCpsT.lift (pure ())
    forM xs <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
        <span class="k">let</span> b <span class="bp">←</span> ExceptCpsT.lift (p x)
        <span class="k">if</span> b <span class="bp">=</span> true <span class="k">then</span> throw (some x) <span class="k">else</span> ExceptCpsT.lift (pure ())
    forM xss <span class="k">fun</span> xs <span class="bp">=&gt;</span>
        forM xs <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
          <span class="k">let</span> b <span class="bp">←</span> ExceptCpsT.lift (p x)
          <span class="k">if</span> b <span class="bp">=</span> true <span class="k">then</span> throw (some x) <span class="k">else</span> ExceptCpsT.lift (pure ())
    ExceptCpsT.lift (pure none)) <span class="bp">=</span>
  <span class="k">do</span>
  <span class="k">let</span> a <span class="bp">←</span>
    ExceptCpsT.runCatch <span class="k">do</span>
        <span class="k">if</span> true <span class="bp">=</span> true <span class="k">then</span> throw (some x) <span class="k">else</span> ExceptCpsT.lift (pure ())
        forM xs <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
            <span class="k">let</span> b <span class="bp">←</span> ExceptCpsT.lift (p x)
            <span class="k">if</span> b <span class="bp">=</span> true <span class="k">then</span> throw (some x) <span class="k">else</span> ExceptCpsT.lift (pure ())
        ExceptCpsT.lift (pure none)
  <span class="k">match</span> a <span class="k">with</span>
    <span class="bp">|</span> some b <span class="bp">=&gt;</span> pure (some b)
    <span class="bp">|</span> none <span class="bp">=&gt;</span>
      ExceptCpsT.runCatch <span class="k">do</span>
        forM xss <span class="k">fun</span> xs <span class="bp">=&gt;</span>
            forM xs <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
              <span class="k">let</span> b <span class="bp">←</span> ExceptCpsT.lift (p x)
              <span class="k">if</span> b <span class="bp">=</span> true <span class="k">then</span> throw (some x) <span class="k">else</span> ExceptCpsT.lift (pure ())
        ExceptCpsT.lift (pure none)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="For-lean-chk49" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>ma, ma'</var><span class="hyp-type"><b>: </b><span>m α</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>xs✝</var><span class="hyp-type"><b>: </b><span>List α</span></span></span><br><span><var>act</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> m Unit</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> m Bool</span></span></span><br><span><var>xss</var><span class="hyp-type"><b>: </b><span>List (List α)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>List α</span></span></span><br><span><var>ih</var><span class="hyp-type"><b>: </b><span>(ExceptCpsT.runCatch <span class="k">do</span>
    forM xs <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
        <span class="k">let</span> b <span class="bp">←</span> ExceptCpsT.lift (p x)
        <span class="k">if</span> b <span class="bp">=</span> true <span class="k">then</span> throw (some x) <span class="k">else</span> ExceptCpsT.lift (pure ())
    forM xss <span class="k">fun</span> xs <span class="bp">=&gt;</span>
        forM xs <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
          <span class="k">let</span> b <span class="bp">←</span> ExceptCpsT.lift (p x)
          <span class="k">if</span> b <span class="bp">=</span> true <span class="k">then</span> throw (some x) <span class="k">else</span> ExceptCpsT.lift (pure ())
    ExceptCpsT.lift (pure none)) <span class="bp">=</span>
  <span class="k">do</span>
  <span class="k">let</span> a <span class="bp">←</span>
    ExceptCpsT.runCatch <span class="k">do</span>
        forM xs <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
            <span class="k">let</span> b <span class="bp">←</span> ExceptCpsT.lift (p x)
            <span class="k">if</span> b <span class="bp">=</span> true <span class="k">then</span> throw (some x) <span class="k">else</span> ExceptCpsT.lift (pure ())
        ExceptCpsT.lift (pure none)
  <span class="k">match</span> a <span class="k">with</span>
    <span class="bp">|</span> some b <span class="bp">=&gt;</span> pure (some b)
    <span class="bp">|</span> none <span class="bp">=&gt;</span>
      ExceptCpsT.runCatch <span class="k">do</span>
        forM xss <span class="k">fun</span> xs <span class="bp">=&gt;</span>
            forM xs <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
              <span class="k">let</span> b <span class="bp">←</span> ExceptCpsT.lift (p x)
              <span class="k">if</span> b <span class="bp">=</span> true <span class="k">then</span> throw (some x) <span class="k">else</span> ExceptCpsT.lift (pure ())
        ExceptCpsT.lift (pure none)</span></span></span><br></div><label class="goal-separator" for="For-lean-chk49"><hr><span class="goal-name">cons.cons.isFalse</span></label><div class="goal-conclusion">(ExceptCpsT.runCatch <span class="k">do</span>
    <span class="k">if</span> false <span class="bp">=</span> true <span class="k">then</span> throw (some x) <span class="k">else</span> ExceptCpsT.lift (pure ())
    forM xs <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
        <span class="k">let</span> b <span class="bp">←</span> ExceptCpsT.lift (p x)
        <span class="k">if</span> b <span class="bp">=</span> true <span class="k">then</span> throw (some x) <span class="k">else</span> ExceptCpsT.lift (pure ())
    forM xss <span class="k">fun</span> xs <span class="bp">=&gt;</span>
        forM xs <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
          <span class="k">let</span> b <span class="bp">←</span> ExceptCpsT.lift (p x)
          <span class="k">if</span> b <span class="bp">=</span> true <span class="k">then</span> throw (some x) <span class="k">else</span> ExceptCpsT.lift (pure ())
    ExceptCpsT.lift (pure none)) <span class="bp">=</span>
  <span class="k">do</span>
  <span class="k">let</span> a <span class="bp">←</span>
    ExceptCpsT.runCatch <span class="k">do</span>
        <span class="k">if</span> false <span class="bp">=</span> true <span class="k">then</span> throw (some x) <span class="k">else</span> ExceptCpsT.lift (pure ())
        forM xs <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
            <span class="k">let</span> b <span class="bp">←</span> ExceptCpsT.lift (p x)
            <span class="k">if</span> b <span class="bp">=</span> true <span class="k">then</span> throw (some x) <span class="k">else</span> ExceptCpsT.lift (pure ())
        ExceptCpsT.lift (pure none)
  <span class="k">match</span> a <span class="k">with</span>
    <span class="bp">|</span> some b <span class="bp">=&gt;</span> pure (some b)
    <span class="bp">|</span> none <span class="bp">=&gt;</span>
      ExceptCpsT.runCatch <span class="k">do</span>
        forM xss <span class="k">fun</span> xs <span class="bp">=&gt;</span>
            forM xs <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
              <span class="k">let</span> b <span class="bp">←</span> ExceptCpsT.lift (p x)
              <span class="k">if</span> b <span class="bp">=</span> true <span class="k">then</span> throw (some x) <span class="k">else</span> ExceptCpsT.lift (pure ())
        ExceptCpsT.lift (pure none)</div></blockquote></div></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="For-lean-chk4a" style="display: none" type="checkbox"><label class="alectryon-input" for="For-lean-chk4a"><span class="alectryon-token"><span class="k">&lt;;&gt;</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>ma, ma'</var><span class="hyp-type"><b>: </b><span>m α</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>xs✝</var><span class="hyp-type"><b>: </b><span>List α</span></span></span><br><span><var>act</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> m Unit</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> m Bool</span></span></span><br><span><var>xss</var><span class="hyp-type"><b>: </b><span>List (List α)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>List α</span></span></span><br><span><var>ih</var><span class="hyp-type"><b>: </b><span>(ExceptCpsT.runCatch <span class="k">do</span>
    forM xs <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
        <span class="k">let</span> b <span class="bp">←</span> ExceptCpsT.lift (p x)
        <span class="k">if</span> b <span class="bp">=</span> true <span class="k">then</span> throw (some x) <span class="k">else</span> ExceptCpsT.lift (pure ())
    forM xss <span class="k">fun</span> xs <span class="bp">=&gt;</span>
        forM xs <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
          <span class="k">let</span> b <span class="bp">←</span> ExceptCpsT.lift (p x)
          <span class="k">if</span> b <span class="bp">=</span> true <span class="k">then</span> throw (some x) <span class="k">else</span> ExceptCpsT.lift (pure ())
    ExceptCpsT.lift (pure none)) <span class="bp">=</span>
  <span class="k">do</span>
  <span class="k">let</span> a <span class="bp">←</span>
    ExceptCpsT.runCatch <span class="k">do</span>
        forM xs <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
            <span class="k">let</span> b <span class="bp">←</span> ExceptCpsT.lift (p x)
            <span class="k">if</span> b <span class="bp">=</span> true <span class="k">then</span> throw (some x) <span class="k">else</span> ExceptCpsT.lift (pure ())
        ExceptCpsT.lift (pure none)
  <span class="k">match</span> a <span class="k">with</span>
    <span class="bp">|</span> some b <span class="bp">=&gt;</span> pure (some b)
    <span class="bp">|</span> none <span class="bp">=&gt;</span>
      ExceptCpsT.runCatch <span class="k">do</span>
        forM xss <span class="k">fun</span> xs <span class="bp">=&gt;</span>
            forM xs <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
              <span class="k">let</span> b <span class="bp">←</span> ExceptCpsT.lift (p x)
              <span class="k">if</span> b <span class="bp">=</span> true <span class="k">then</span> throw (some x) <span class="k">else</span> ExceptCpsT.lift (pure ())
        ExceptCpsT.lift (pure none)</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">cons.cons.isTrue</span></span><div class="goal-conclusion">(ExceptCpsT.runCatch <span class="k">do</span>
    <span class="k">if</span> true <span class="bp">=</span> true <span class="k">then</span> throw (some x) <span class="k">else</span> ExceptCpsT.lift (pure ())
    forM xs <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
        <span class="k">let</span> b <span class="bp">←</span> ExceptCpsT.lift (p x)
        <span class="k">if</span> b <span class="bp">=</span> true <span class="k">then</span> throw (some x) <span class="k">else</span> ExceptCpsT.lift (pure ())
    forM xss <span class="k">fun</span> xs <span class="bp">=&gt;</span>
        forM xs <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
          <span class="k">let</span> b <span class="bp">←</span> ExceptCpsT.lift (p x)
          <span class="k">if</span> b <span class="bp">=</span> true <span class="k">then</span> throw (some x) <span class="k">else</span> ExceptCpsT.lift (pure ())
    ExceptCpsT.lift (pure none)) <span class="bp">=</span>
  <span class="k">do</span>
  <span class="k">let</span> a <span class="bp">←</span>
    ExceptCpsT.runCatch <span class="k">do</span>
        <span class="k">if</span> true <span class="bp">=</span> true <span class="k">then</span> throw (some x) <span class="k">else</span> ExceptCpsT.lift (pure ())
        forM xs <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
            <span class="k">let</span> b <span class="bp">←</span> ExceptCpsT.lift (p x)
            <span class="k">if</span> b <span class="bp">=</span> true <span class="k">then</span> throw (some x) <span class="k">else</span> ExceptCpsT.lift (pure ())
        ExceptCpsT.lift (pure none)
  <span class="k">match</span> a <span class="k">with</span>
    <span class="bp">|</span> some b <span class="bp">=&gt;</span> pure (some b)
    <span class="bp">|</span> none <span class="bp">=&gt;</span>
      ExceptCpsT.runCatch <span class="k">do</span>
        forM xss <span class="k">fun</span> xs <span class="bp">=&gt;</span>
            forM xs <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
              <span class="k">let</span> b <span class="bp">←</span> ExceptCpsT.lift (p x)
              <span class="k">if</span> b <span class="bp">=</span> true <span class="k">then</span> throw (some x) <span class="k">else</span> ExceptCpsT.lift (pure ())
        ExceptCpsT.lift (pure none)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="For-lean-chk4b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>ma, ma'</var><span class="hyp-type"><b>: </b><span>m α</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>xs✝</var><span class="hyp-type"><b>: </b><span>List α</span></span></span><br><span><var>act</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> m Unit</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> m Bool</span></span></span><br><span><var>xss</var><span class="hyp-type"><b>: </b><span>List (List α)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>List α</span></span></span><br><span><var>ih</var><span class="hyp-type"><b>: </b><span>(ExceptCpsT.runCatch <span class="k">do</span>
    forM xs <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
        <span class="k">let</span> b <span class="bp">←</span> ExceptCpsT.lift (p x)
        <span class="k">if</span> b <span class="bp">=</span> true <span class="k">then</span> throw (some x) <span class="k">else</span> ExceptCpsT.lift (pure ())
    forM xss <span class="k">fun</span> xs <span class="bp">=&gt;</span>
        forM xs <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
          <span class="k">let</span> b <span class="bp">←</span> ExceptCpsT.lift (p x)
          <span class="k">if</span> b <span class="bp">=</span> true <span class="k">then</span> throw (some x) <span class="k">else</span> ExceptCpsT.lift (pure ())
    ExceptCpsT.lift (pure none)) <span class="bp">=</span>
  <span class="k">do</span>
  <span class="k">let</span> a <span class="bp">←</span>
    ExceptCpsT.runCatch <span class="k">do</span>
        forM xs <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
            <span class="k">let</span> b <span class="bp">←</span> ExceptCpsT.lift (p x)
            <span class="k">if</span> b <span class="bp">=</span> true <span class="k">then</span> throw (some x) <span class="k">else</span> ExceptCpsT.lift (pure ())
        ExceptCpsT.lift (pure none)
  <span class="k">match</span> a <span class="k">with</span>
    <span class="bp">|</span> some b <span class="bp">=&gt;</span> pure (some b)
    <span class="bp">|</span> none <span class="bp">=&gt;</span>
      ExceptCpsT.runCatch <span class="k">do</span>
        forM xss <span class="k">fun</span> xs <span class="bp">=&gt;</span>
            forM xs <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
              <span class="k">let</span> b <span class="bp">←</span> ExceptCpsT.lift (p x)
              <span class="k">if</span> b <span class="bp">=</span> true <span class="k">then</span> throw (some x) <span class="k">else</span> ExceptCpsT.lift (pure ())
        ExceptCpsT.lift (pure none)</span></span></span><br></div><label class="goal-separator" for="For-lean-chk4b"><hr><span class="goal-name">cons.cons.isFalse</span></label><div class="goal-conclusion">(ExceptCpsT.runCatch <span class="k">do</span>
    <span class="k">if</span> false <span class="bp">=</span> true <span class="k">then</span> throw (some x) <span class="k">else</span> ExceptCpsT.lift (pure ())
    forM xs <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
        <span class="k">let</span> b <span class="bp">←</span> ExceptCpsT.lift (p x)
        <span class="k">if</span> b <span class="bp">=</span> true <span class="k">then</span> throw (some x) <span class="k">else</span> ExceptCpsT.lift (pure ())
    forM xss <span class="k">fun</span> xs <span class="bp">=&gt;</span>
        forM xs <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
          <span class="k">let</span> b <span class="bp">←</span> ExceptCpsT.lift (p x)
          <span class="k">if</span> b <span class="bp">=</span> true <span class="k">then</span> throw (some x) <span class="k">else</span> ExceptCpsT.lift (pure ())
    ExceptCpsT.lift (pure none)) <span class="bp">=</span>
  <span class="k">do</span>
  <span class="k">let</span> a <span class="bp">←</span>
    ExceptCpsT.runCatch <span class="k">do</span>
        <span class="k">if</span> false <span class="bp">=</span> true <span class="k">then</span> throw (some x) <span class="k">else</span> ExceptCpsT.lift (pure ())
        forM xs <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
            <span class="k">let</span> b <span class="bp">←</span> ExceptCpsT.lift (p x)
            <span class="k">if</span> b <span class="bp">=</span> true <span class="k">then</span> throw (some x) <span class="k">else</span> ExceptCpsT.lift (pure ())
        ExceptCpsT.lift (pure none)
  <span class="k">match</span> a <span class="k">with</span>
    <span class="bp">|</span> some b <span class="bp">=&gt;</span> pure (some b)
    <span class="bp">|</span> none <span class="bp">=&gt;</span>
      ExceptCpsT.runCatch <span class="k">do</span>
        forM xss <span class="k">fun</span> xs <span class="bp">=&gt;</span>
            forM xs <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
              <span class="k">let</span> b <span class="bp">←</span> ExceptCpsT.lift (p x)
              <span class="k">if</span> b <span class="bp">=</span> true <span class="k">then</span> throw (some x) <span class="k">else</span> ExceptCpsT.lift (pure ())
        ExceptCpsT.lift (pure none)</div></blockquote></div></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="For-lean-chk4c" style="display: none" type="checkbox"><label class="alectryon-input" for="For-lean-chk4c"><span class="alectryon-token"><span class="k">simp</span></span><span class="alectryon-token"> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ih</var><b>: </b><span>(ExceptCpsT.runCatch do
    forM xs fun x =&gt; do
        let b ← ExceptCpsT.lift (p x)
        if b = true then throw (some x) else ExceptCpsT.lift (pure ())
    forM xss fun xs =&gt;
        forM xs fun x =&gt; do
          let b ← ExceptCpsT.lift (p x)
          if b = true then throw (some x) else ExceptCpsT.lift (pure ())
    ExceptCpsT.lift (pure none)) =
  do
  let a ←
    ExceptCpsT.runCatch do
        forM xs fun x =&gt; do
            let b ← ExceptCpsT.lift (p x)
            if b = true then throw (some x) else ExceptCpsT.lift (pure ())
        ExceptCpsT.lift (pure none)
  match a with
    | some b =&gt; pure (some b)
    | none =&gt;
      ExceptCpsT.runCatch do
        forM xss fun xs =&gt;
            forM xs fun x =&gt; do
              let b ← ExceptCpsT.lift (p x)
              if b = true then throw (some x) else ExceptCpsT.lift (pure ())
        ExceptCpsT.lift (pure none)</span></span></div></blockquote></div></small></div><span class="nv">ih</span></span><span class="alectryon-token">]</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">

</span><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>List.untilM</var><b>: </b><span>{m : Type → Type u_1} → {α : Type} → [inst : Monad m] → (α → m Bool) → List α → m Unit</span></span></div></blockquote></div></small></div><span class="nv">List.untilM</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>p</var><b>: </b><span>α → m Bool</span></span></div></blockquote></div></small></div><span class="nv">p</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>Type → Type u_1</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Bool</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Bool</span><span class="alectryon-token">) : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>List</var><b>: </b><span>Type → Type</span></span></div></blockquote></div></small></div>List</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>Type → Type u_1</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Unit</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Unit</span><span class="alectryon-token">
  <span class="bp">|</span> []    <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>pure</var><b>: </b><span>{f : Type → Type u_1} → [self : Pure f] → {α : Type} → α → f α</span></span></div></blockquote></div></small></div>pure</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>()</var><b>: </b><span>Unit</span></span></div></blockquote></div></small></div>()</span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token">::</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>as</var><b>: </b><span>List α</span></span></div></blockquote></div></small></div><span class="nv">as</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>p</var><b>: </b><span>α → m Bool</span></span></div></blockquote></div></small></div><span class="nv">p</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"> <span class="bp">&gt;&gt;=</span> </span><span class="alectryon-token"><span class="k">fun</span></span><span class="alectryon-token"> <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>true</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div>true</span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>pure</var><b>: </b><span>{f : Type → Type u_1} → [self : Pure f] → {α : Type} → α → f α</span></span></div></blockquote></div></small></div>pure</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>()</var><b>: </b><span>Unit</span></span></div></blockquote></div></small></div>()</span><span class="alectryon-token"> <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>false</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div>false</span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>as</var><b>: </b><span>List α</span></span></div></blockquote></div></small></div><span class="nv">as</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>untilM</var><b>: </b><span>(α → m Bool) → List α → m Unit</span></span></div></blockquote></div></small></div><span class="nv">untilM</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>p</var><b>: </b><span>α → m Bool</span></span></div></blockquote></div></small></div><span class="nv">p</span></span><span class="alectryon-token">

</span><span class="alectryon-token"><span class="kd">theorem</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>eq_untilM</var><b>: </b><span>∀ [inst : LawfulMonad m],
  ExceptCpsT.runCatch
      (forM xs fun x =&gt; do
        let b ← ExceptCpsT.lift (p x)
        if b = true then throw () else ExceptCpsT.lift (pure ())) =
    List.untilM p xs</span></span></div></blockquote></div></small></div><span class="nv">eq_untilM</span></span><span class="alectryon-token"> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>LawfulMonad</var><b>: </b><span>(m : Type → Type u_1) → [inst : Monad m] → Prop</span></span></div></blockquote></div></small></div>LawfulMonad</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>Type → Type u_1</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token">] :
  (</span><span class="alectryon-token"><span class="k">do</span><span class="bp">&#39;</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">for</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">in</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>xs</var><b>: </b><span>List α</span></span></div></blockquote></div></small></div><span class="nv">xs</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">do</span><span class="bp">&#39;</span></span><span class="alectryon-token"> {
         </span><span class="alectryon-token"><span class="k">let</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token"> <span class="bp">←</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>p</var><b>: </b><span>α → m Bool</span></span></div></blockquote></div></small></div><span class="nv">p</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"><span class="bp">;</span>
         </span><span class="alectryon-token"><span class="k">if</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">then</span></span><span class="alectryon-token"> {
           </span><span class="alectryon-token"><span class="k">break</span></span><span class="alectryon-token">
         }
       })
  <span class="bp">=</span>
  </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>xs</var><b>: </b><span>List α</span></span></div></blockquote></div></small></div><span class="nv">xs</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>untilM</var><b>: </b><span>{m : Type → Type u_1} → {α : Type} → [inst : Monad m] → (α → m Bool) → List α → m Unit</span></span></div></blockquote></div></small></div>untilM</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>p</var><b>: </b><span>α → m Bool</span></span></div></blockquote></div></small></div><span class="nv">p</span></span><span class="alectryon-token">
:= </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="For-lean-chk4d" style="display: none" type="checkbox"><label class="alectryon-input" for="For-lean-chk4d"><span class="alectryon-token"><span class="kd">by</span></span><span class="alectryon-token"></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>ma, ma'</var><span class="hyp-type"><b>: </b><span>m α</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>List α</span></span></span><br><span><var>act</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> m Unit</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> m Bool</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ExceptCpsT.runCatch
    (forM xs <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
      <span class="k">let</span> b <span class="bp">←</span> ExceptCpsT.lift (p x)
      <span class="k">if</span> b <span class="bp">=</span> true <span class="k">then</span> throw () <span class="k">else</span> ExceptCpsT.lift (pure ())) <span class="bp">=</span>
  List.untilM p xs</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="For-lean-chk4e" style="display: none" type="checkbox"><label class="alectryon-input" for="For-lean-chk4e"><span class="alectryon-token"><span class="k">induction</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>xs</var><b>: </b><span>List α</span></span></div></blockquote></div></small></div><span class="nv">xs</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">with</span></span><span class="alectryon-token"></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>ma, ma'</var><span class="hyp-type"><b>: </b><span>m α</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>List α</span></span></span><br><span><var>act</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> m Unit</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> m Bool</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ExceptCpsT.runCatch
    (forM xs <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
      <span class="k">let</span> b <span class="bp">←</span> ExceptCpsT.lift (p x)
      <span class="k">if</span> b <span class="bp">=</span> true <span class="k">then</span> throw () <span class="k">else</span> ExceptCpsT.lift (pure ())) <span class="bp">=</span>
  List.untilM p xs</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
      </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="For-lean-chk4f" style="display: none" type="checkbox"><label class="alectryon-input" for="For-lean-chk4f"><span class="alectryon-token"><span class="bp">|</span> nil <span class="bp">=&gt;</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>ma, ma'</var><span class="hyp-type"><b>: </b><span>m α</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>List α</span></span></span><br><span><var>act</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> m Unit</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> m Bool</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">nil</span></span><div class="goal-conclusion">ExceptCpsT.runCatch
    (forM [] <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
      <span class="k">let</span> b <span class="bp">←</span> ExceptCpsT.lift (p x)
      <span class="k">if</span> b <span class="bp">=</span> true <span class="k">then</span> throw () <span class="k">else</span> ExceptCpsT.lift (pure ())) <span class="bp">=</span>
  List.untilM p []</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="For-lean-chk50" style="display: none" type="checkbox"><label class="alectryon-input" for="For-lean-chk50"><span class="alectryon-token">simp<span class="bp">!</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
      </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="For-lean-chk51" style="display: none" type="checkbox"><label class="alectryon-input" for="For-lean-chk51"><span class="alectryon-token"><span class="bp">|</span> cons </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>xs</var><b>: </b><span>List α</span></span></div></blockquote></div></small></div><span class="nv">xs</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ih</var><b>: </b><span>ExceptCpsT.runCatch
    (forM xs fun x =&gt; do
      let b ← ExceptCpsT.lift (p x)
      if b = true then throw () else ExceptCpsT.lift (pure ())) =
  List.untilM p xs</span></span></div></blockquote></div></small></div><span class="nv">ih</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>ma, ma'</var><span class="hyp-type"><b>: </b><span>m α</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>xs✝</var><span class="hyp-type"><b>: </b><span>List α</span></span></span><br><span><var>act</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> m Unit</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> m Bool</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>List α</span></span></span><br><span><var>ih</var><span class="hyp-type"><b>: </b><span>ExceptCpsT.runCatch
    (forM xs <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
      <span class="k">let</span> b <span class="bp">←</span> ExceptCpsT.lift (p x)
      <span class="k">if</span> b <span class="bp">=</span> true <span class="k">then</span> throw () <span class="k">else</span> ExceptCpsT.lift (pure ())) <span class="bp">=</span>
  List.untilM p xs</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">cons</span></span><div class="goal-conclusion">ExceptCpsT.runCatch
    (forM (x :: xs) <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
      <span class="k">let</span> b <span class="bp">←</span> ExceptCpsT.lift (p x)
      <span class="k">if</span> b <span class="bp">=</span> true <span class="k">then</span> throw () <span class="k">else</span> ExceptCpsT.lift (pure ())) <span class="bp">=</span>
  List.untilM p (x :: xs)</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
        </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="For-lean-chk52" style="display: none" type="checkbox"><label class="alectryon-input" for="For-lean-chk52"><span class="alectryon-token"><span class="k">simp</span></span><span class="alectryon-token"> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>List.untilM</var><b>: </b><span>{m : Type → Type ?u.34317} → {α : Type} → [inst : Monad m] → (α → m Bool) → List α → m Unit</span></span></div></blockquote></div></small></div>List.untilM</span><span class="alectryon-token">]</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>ma, ma'</var><span class="hyp-type"><b>: </b><span>m α</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>xs✝</var><span class="hyp-type"><b>: </b><span>List α</span></span></span><br><span><var>act</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> m Unit</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> m Bool</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>List α</span></span></span><br><span><var>ih</var><span class="hyp-type"><b>: </b><span>ExceptCpsT.runCatch
    (forM xs <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
      <span class="k">let</span> b <span class="bp">←</span> ExceptCpsT.lift (p x)
      <span class="k">if</span> b <span class="bp">=</span> true <span class="k">then</span> throw () <span class="k">else</span> ExceptCpsT.lift (pure ())) <span class="bp">=</span>
  List.untilM p xs</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">cons</span></span><div class="goal-conclusion">(<span class="k">do</span>
    <span class="k">let</span> a <span class="bp">←</span> p x
    ExceptCpsT.runCatch <span class="k">do</span>
        <span class="k">if</span> a <span class="bp">=</span> true <span class="k">then</span> throw () <span class="k">else</span> ExceptCpsT.lift (pure ())
        forM xs <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
            <span class="k">let</span> b <span class="bp">←</span> ExceptCpsT.lift (p x)
            <span class="k">if</span> b <span class="bp">=</span> true <span class="k">then</span> throw () <span class="k">else</span> ExceptCpsT.lift (pure ())) <span class="bp">=</span>
  <span class="k">do</span>
  <span class="k">let</span> x <span class="bp">←</span> p x
  <span class="k">match</span> x <span class="k">with</span>
    <span class="bp">|</span> true <span class="bp">=&gt;</span> pure ()
    <span class="bp">|</span> false <span class="bp">=&gt;</span> List.untilM p xs</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"><span class="bp">;</span></span><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="For-lean-chk53" style="display: none" type="checkbox"><label class="alectryon-input" for="For-lean-chk53"><span class="alectryon-token"><span class="k">rw</span></span><span class="alectryon-token"> [</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>ma, ma'</var><span class="hyp-type"><b>: </b><span>m α</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>xs✝</var><span class="hyp-type"><b>: </b><span>List α</span></span></span><br><span><var>act</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> m Unit</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> m Bool</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>List α</span></span></span><br><span><var>ih</var><span class="hyp-type"><b>: </b><span>ExceptCpsT.runCatch
    (forM xs <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
      <span class="k">let</span> b <span class="bp">←</span> ExceptCpsT.lift (p x)
      <span class="k">if</span> b <span class="bp">=</span> true <span class="k">then</span> throw () <span class="k">else</span> ExceptCpsT.lift (pure ())) <span class="bp">=</span>
  List.untilM p xs</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">cons</span></span><div class="goal-conclusion">(<span class="k">do</span>
    <span class="k">let</span> a <span class="bp">←</span> p x
    ExceptCpsT.runCatch <span class="k">do</span>
        <span class="k">if</span> a <span class="bp">=</span> true <span class="k">then</span> throw () <span class="k">else</span> ExceptCpsT.lift (pure ())
        forM xs <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
            <span class="k">let</span> b <span class="bp">←</span> ExceptCpsT.lift (p x)
            <span class="k">if</span> b <span class="bp">=</span> true <span class="k">then</span> throw () <span class="k">else</span> ExceptCpsT.lift (pure ())) <span class="bp">=</span>
  <span class="k">do</span>
  <span class="k">let</span> x <span class="bp">←</span> p x
  <span class="k">match</span> x <span class="k">with</span>
    <span class="bp">|</span> true <span class="bp">=&gt;</span> pure ()
    <span class="bp">|</span> false <span class="bp">=&gt;</span> List.untilM p xs</div></blockquote></div></div></small></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="For-lean-chk54" style="display: none" type="checkbox"><label class="alectryon-input" for="For-lean-chk54"><span class="alectryon-token"><span class="bp">←</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ih</var><b>: </b><span>ExceptCpsT.runCatch
    (forM xs fun x =&gt; do
      let b ← ExceptCpsT.lift (p x)
      if b = true then throw () else ExceptCpsT.lift (pure ())) =
  List.untilM p xs</span></span></div></blockquote></div></small></div><span class="nv">ih</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>ma, ma'</var><span class="hyp-type"><b>: </b><span>m α</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>xs✝</var><span class="hyp-type"><b>: </b><span>List α</span></span></span><br><span><var>act</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> m Unit</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> m Bool</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>List α</span></span></span><br><span><var>ih</var><span class="hyp-type"><b>: </b><span>ExceptCpsT.runCatch
    (forM xs <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
      <span class="k">let</span> b <span class="bp">←</span> ExceptCpsT.lift (p x)
      <span class="k">if</span> b <span class="bp">=</span> true <span class="k">then</span> throw () <span class="k">else</span> ExceptCpsT.lift (pure ())) <span class="bp">=</span>
  List.untilM p xs</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">cons</span></span><div class="goal-conclusion">(<span class="k">do</span>
    <span class="k">let</span> a <span class="bp">←</span> p x
    ExceptCpsT.runCatch <span class="k">do</span>
        <span class="k">if</span> a <span class="bp">=</span> true <span class="k">then</span> throw () <span class="k">else</span> ExceptCpsT.lift (pure ())
        forM xs <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
            <span class="k">let</span> b <span class="bp">←</span> ExceptCpsT.lift (p x)
            <span class="k">if</span> b <span class="bp">=</span> true <span class="k">then</span> throw () <span class="k">else</span> ExceptCpsT.lift (pure ())) <span class="bp">=</span>
  <span class="k">do</span>
  <span class="k">let</span> x <span class="bp">←</span> p x
  <span class="k">match</span> x <span class="k">with</span>
    <span class="bp">|</span> true <span class="bp">=&gt;</span> pure ()
    <span class="bp">|</span> false <span class="bp">=&gt;</span>
      ExceptCpsT.runCatch
        (forM xs <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
          <span class="k">let</span> b <span class="bp">←</span> ExceptCpsT.lift (p x)
          <span class="k">if</span> b <span class="bp">=</span> true <span class="k">then</span> throw () <span class="k">else</span> ExceptCpsT.lift (pure ()))</div></blockquote></div></div></small></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="For-lean-chk55" style="display: none" type="checkbox"><label class="alectryon-input" for="For-lean-chk55"><span class="alectryon-token">]</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>ma, ma'</var><span class="hyp-type"><b>: </b><span>m α</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>xs✝</var><span class="hyp-type"><b>: </b><span>List α</span></span></span><br><span><var>act</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> m Unit</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> m Bool</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>List α</span></span></span><br><span><var>ih</var><span class="hyp-type"><b>: </b><span>ExceptCpsT.runCatch
    (forM xs <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
      <span class="k">let</span> b <span class="bp">←</span> ExceptCpsT.lift (p x)
      <span class="k">if</span> b <span class="bp">=</span> true <span class="k">then</span> throw () <span class="k">else</span> ExceptCpsT.lift (pure ())) <span class="bp">=</span>
  List.untilM p xs</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">cons</span></span><div class="goal-conclusion">(<span class="k">do</span>
    <span class="k">let</span> a <span class="bp">←</span> p x
    ExceptCpsT.runCatch <span class="k">do</span>
        <span class="k">if</span> a <span class="bp">=</span> true <span class="k">then</span> throw () <span class="k">else</span> ExceptCpsT.lift (pure ())
        forM xs <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
            <span class="k">let</span> b <span class="bp">←</span> ExceptCpsT.lift (p x)
            <span class="k">if</span> b <span class="bp">=</span> true <span class="k">then</span> throw () <span class="k">else</span> ExceptCpsT.lift (pure ())) <span class="bp">=</span>
  <span class="k">do</span>
  <span class="k">let</span> x <span class="bp">←</span> p x
  <span class="k">match</span> x <span class="k">with</span>
    <span class="bp">|</span> true <span class="bp">=&gt;</span> pure ()
    <span class="bp">|</span> false <span class="bp">=&gt;</span>
      ExceptCpsT.runCatch
        (forM xs <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
          <span class="k">let</span> b <span class="bp">←</span> ExceptCpsT.lift (p x)
          <span class="k">if</span> b <span class="bp">=</span> true <span class="k">then</span> throw () <span class="k">else</span> ExceptCpsT.lift (pure ()))</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"><span class="bp">;</span></span><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="For-lean-chk56" style="display: none" type="checkbox"><label class="alectryon-input" for="For-lean-chk56"><span class="alectryon-token"><span class="k">clear</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ih</var><b>: </b><span>ExceptCpsT.runCatch
    (forM xs fun x =&gt; do
      let b ← ExceptCpsT.lift (p x)
      if b = true then throw () else ExceptCpsT.lift (pure ())) =
  List.untilM p xs</span></span></div></blockquote></div></small></div><span class="nv">ih</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>ma, ma'</var><span class="hyp-type"><b>: </b><span>m α</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>xs✝</var><span class="hyp-type"><b>: </b><span>List α</span></span></span><br><span><var>act</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> m Unit</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> m Bool</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>List α</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">cons</span></span><div class="goal-conclusion">(<span class="k">do</span>
    <span class="k">let</span> a <span class="bp">←</span> p x
    ExceptCpsT.runCatch <span class="k">do</span>
        <span class="k">if</span> a <span class="bp">=</span> true <span class="k">then</span> throw () <span class="k">else</span> ExceptCpsT.lift (pure ())
        forM xs <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
            <span class="k">let</span> b <span class="bp">←</span> ExceptCpsT.lift (p x)
            <span class="k">if</span> b <span class="bp">=</span> true <span class="k">then</span> throw () <span class="k">else</span> ExceptCpsT.lift (pure ())) <span class="bp">=</span>
  <span class="k">do</span>
  <span class="k">let</span> x <span class="bp">←</span> p x
  <span class="k">match</span> x <span class="k">with</span>
    <span class="bp">|</span> true <span class="bp">=&gt;</span> pure ()
    <span class="bp">|</span> false <span class="bp">=&gt;</span>
      ExceptCpsT.runCatch
        (forM xs <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
          <span class="k">let</span> b <span class="bp">←</span> ExceptCpsT.lift (p x)
          <span class="k">if</span> b <span class="bp">=</span> true <span class="k">then</span> throw () <span class="k">else</span> ExceptCpsT.lift (pure ()))</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
        </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="For-lean-chk57" style="display: none" type="checkbox"><label class="alectryon-input" for="For-lean-chk57"><span class="alectryon-token"><span class="k">apply</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>byCases_Bool_bind</var><b>: </b><span>∀ {m : Type → Type u_1} [inst : Monad m] {β : Type} (x : m Bool) (f g : Bool → m β),
  f true = g true → f false = g false → x &gt;&gt;= f = x &gt;&gt;= g</span></span></div></blockquote></div></small></div><span class="k">byCases_Bool_bind</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>ma, ma'</var><span class="hyp-type"><b>: </b><span>m α</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>xs✝</var><span class="hyp-type"><b>: </b><span>List α</span></span></span><br><span><var>act</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> m Unit</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> m Bool</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>List α</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">cons.isTrue</span></span><div class="goal-conclusion">(ExceptCpsT.runCatch <span class="k">do</span>
    <span class="k">if</span> true <span class="bp">=</span> true <span class="k">then</span> throw () <span class="k">else</span> ExceptCpsT.lift (pure ())
    forM xs <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
        <span class="k">let</span> b <span class="bp">←</span> ExceptCpsT.lift (p x)
        <span class="k">if</span> b <span class="bp">=</span> true <span class="k">then</span> throw () <span class="k">else</span> ExceptCpsT.lift (pure ())) <span class="bp">=</span>
  <span class="k">match</span> true <span class="k">with</span>
  <span class="bp">|</span> true <span class="bp">=&gt;</span> pure ()
  <span class="bp">|</span> false <span class="bp">=&gt;</span>
    ExceptCpsT.runCatch
      (forM xs <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
        <span class="k">let</span> b <span class="bp">←</span> ExceptCpsT.lift (p x)
        <span class="k">if</span> b <span class="bp">=</span> true <span class="k">then</span> throw () <span class="k">else</span> ExceptCpsT.lift (pure ()))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="For-lean-chk58" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>ma, ma'</var><span class="hyp-type"><b>: </b><span>m α</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>xs✝</var><span class="hyp-type"><b>: </b><span>List α</span></span></span><br><span><var>act</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> m Unit</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> m Bool</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>List α</span></span></span><br></div><label class="goal-separator" for="For-lean-chk58"><hr><span class="goal-name">cons.isFalse</span></label><div class="goal-conclusion">(ExceptCpsT.runCatch <span class="k">do</span>
    <span class="k">if</span> false <span class="bp">=</span> true <span class="k">then</span> throw () <span class="k">else</span> ExceptCpsT.lift (pure ())
    forM xs <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
        <span class="k">let</span> b <span class="bp">←</span> ExceptCpsT.lift (p x)
        <span class="k">if</span> b <span class="bp">=</span> true <span class="k">then</span> throw () <span class="k">else</span> ExceptCpsT.lift (pure ())) <span class="bp">=</span>
  <span class="k">match</span> false <span class="k">with</span>
  <span class="bp">|</span> true <span class="bp">=&gt;</span> pure ()
  <span class="bp">|</span> false <span class="bp">=&gt;</span>
    ExceptCpsT.runCatch
      (forM xs <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
        <span class="k">let</span> b <span class="bp">←</span> ExceptCpsT.lift (p x)
        <span class="k">if</span> b <span class="bp">=</span> true <span class="k">then</span> throw () <span class="k">else</span> ExceptCpsT.lift (pure ()))</div></blockquote></div></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="For-lean-chk59" style="display: none" type="checkbox"><label class="alectryon-input" for="For-lean-chk59"><span class="alectryon-token"><span class="k">&lt;;&gt;</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>ma, ma'</var><span class="hyp-type"><b>: </b><span>m α</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>xs✝</var><span class="hyp-type"><b>: </b><span>List α</span></span></span><br><span><var>act</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> m Unit</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> m Bool</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>List α</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">cons.isTrue</span></span><div class="goal-conclusion">(ExceptCpsT.runCatch <span class="k">do</span>
    <span class="k">if</span> true <span class="bp">=</span> true <span class="k">then</span> throw () <span class="k">else</span> ExceptCpsT.lift (pure ())
    forM xs <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
        <span class="k">let</span> b <span class="bp">←</span> ExceptCpsT.lift (p x)
        <span class="k">if</span> b <span class="bp">=</span> true <span class="k">then</span> throw () <span class="k">else</span> ExceptCpsT.lift (pure ())) <span class="bp">=</span>
  <span class="k">match</span> true <span class="k">with</span>
  <span class="bp">|</span> true <span class="bp">=&gt;</span> pure ()
  <span class="bp">|</span> false <span class="bp">=&gt;</span>
    ExceptCpsT.runCatch
      (forM xs <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
        <span class="k">let</span> b <span class="bp">←</span> ExceptCpsT.lift (p x)
        <span class="k">if</span> b <span class="bp">=</span> true <span class="k">then</span> throw () <span class="k">else</span> ExceptCpsT.lift (pure ()))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="For-lean-chk5a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>ma, ma'</var><span class="hyp-type"><b>: </b><span>m α</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>xs✝</var><span class="hyp-type"><b>: </b><span>List α</span></span></span><br><span><var>act</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> m Unit</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> m Bool</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>List α</span></span></span><br></div><label class="goal-separator" for="For-lean-chk5a"><hr><span class="goal-name">cons.isFalse</span></label><div class="goal-conclusion">(ExceptCpsT.runCatch <span class="k">do</span>
    <span class="k">if</span> false <span class="bp">=</span> true <span class="k">then</span> throw () <span class="k">else</span> ExceptCpsT.lift (pure ())
    forM xs <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
        <span class="k">let</span> b <span class="bp">←</span> ExceptCpsT.lift (p x)
        <span class="k">if</span> b <span class="bp">=</span> true <span class="k">then</span> throw () <span class="k">else</span> ExceptCpsT.lift (pure ())) <span class="bp">=</span>
  <span class="k">match</span> false <span class="k">with</span>
  <span class="bp">|</span> true <span class="bp">=&gt;</span> pure ()
  <span class="bp">|</span> false <span class="bp">=&gt;</span>
    ExceptCpsT.runCatch
      (forM xs <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
        <span class="k">let</span> b <span class="bp">←</span> ExceptCpsT.lift (p x)
        <span class="k">if</span> b <span class="bp">=</span> true <span class="k">then</span> throw () <span class="k">else</span> ExceptCpsT.lift (pure ()))</div></blockquote></div></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="For-lean-chk5b" style="display: none" type="checkbox"><label class="alectryon-input" for="For-lean-chk5b"><span class="alectryon-token"><span class="k">simp</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">

<span class="c">/-</span><span class="cm"></span>
<span class="cm">The notation `[0:10]` is a range from 0 to 10 (exclusively).</span>
<span class="cm">-/</span>

</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="For-lean-chk5c" style="display: none" type="checkbox"><label class="alectryon-input" for="For-lean-chk5c"><span class="alectryon-token"><span class="k">#eval</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="mi">0</span>
<span class="mi">0</span>
<span class="mi">1</span>
<span class="mi">0</span>
<span class="mi">2</span>
<span class="mi">0</span>
<span class="mi">3</span>
<span class="mi">0</span>
<span class="mi">4</span>
<span class="mi">0</span>
<span class="mi">5</span>
</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">do</span><span class="bp">&#39;</span></span><span class="alectryon-token">
  </span><span class="alectryon-token"><span class="k">for</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">in</span></span><span class="alectryon-token"> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>0</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">0</span></span><span class="alectryon-token">:</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>10</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">10</span></span><span class="alectryon-token">] </span><span class="alectryon-token"><span class="k">do</span><span class="bp">&#39;</span></span><span class="alectryon-token"> {
    </span><span class="alectryon-token"><span class="k">if</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> <span class="bp">&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>5</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">5</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">then</span></span><span class="alectryon-token"> {
      </span><span class="alectryon-token"><span class="k">break</span></span><span class="alectryon-token">
    }<span class="bp">;</span>
    </span><span class="alectryon-token"><span class="k">for</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>y</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">y</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">in</span></span><span class="alectryon-token"> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>0</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">0</span></span><span class="alectryon-token">:</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token">] </span><span class="alectryon-token"><span class="k">do</span><span class="bp">&#39;</span></span><span class="alectryon-token"> {
      </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>IO.println</var><b>: </b><span>{α : Type} → [inst : ToString α] → α → IO Unit</span></span></div></blockquote></div></small></div>IO.println</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>y</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">y</span></span><span class="alectryon-token"><span class="bp">;</span>
      </span><span class="alectryon-token"><span class="k">break</span></span><span class="alectryon-token">
    }<span class="bp">;</span>
    </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>IO.println</var><b>: </b><span>{α : Type} → [inst : ToString α] → α → IO Unit</span></span></div></blockquote></div></small></div>IO.println</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token">
  }

</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="For-lean-chk5d" style="display: none" type="checkbox"><label class="alectryon-input" for="For-lean-chk5d"><span class="alectryon-token"><span class="k">#eval</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="mi">0</span>
<span class="mi">1</span>
<span class="mi">2</span>
<span class="mi">3</span>
<span class="mi">4</span>
<span class="mi">5</span>
</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">do</span><span class="bp">&#39;</span></span><span class="alectryon-token">
  </span><span class="alectryon-token"><span class="k">for</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">in</span></span><span class="alectryon-token"> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>0</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">0</span></span><span class="alectryon-token">:</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>10</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">10</span></span><span class="alectryon-token">] </span><span class="alectryon-token"><span class="k">do</span><span class="bp">&#39;</span></span><span class="alectryon-token"> {
    </span><span class="alectryon-token"><span class="k">if</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> <span class="bp">&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>5</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">5</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">then</span></span><span class="alectryon-token"> {
      </span><span class="alectryon-token"><span class="k">break</span></span><span class="alectryon-token">
    }<span class="bp">;</span>
    </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>IO.println</var><b>: </b><span>{α : Type} → [inst : ToString α] → α → IO Unit</span></span></div></blockquote></div></small></div>IO.println</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token">
  }

</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="For-lean-chk5e" style="display: none" type="checkbox"><label class="alectryon-input" for="For-lean-chk5e"><span class="alectryon-token"><span class="k">#eval</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="mi">1</span>
<span class="mi">3</span>
<span class="mi">5</span>
</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">do</span><span class="bp">&#39;</span></span><span class="alectryon-token">
  </span><span class="alectryon-token"><span class="k">for</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">in</span></span><span class="alectryon-token"> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>0</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">0</span></span><span class="alectryon-token">:</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>10</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">10</span></span><span class="alectryon-token">] </span><span class="alectryon-token"><span class="k">do</span><span class="bp">&#39;</span></span><span class="alectryon-token"> {
    </span><span class="alectryon-token"><span class="k">if</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> <span class="bp">%</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>2</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">2</span></span><span class="alectryon-token"> <span class="bp">==</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>0</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">0</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">then</span></span><span class="alectryon-token"> {
      </span><span class="alectryon-token"><span class="k">continue</span></span><span class="alectryon-token">
    }<span class="bp">;</span>
    </span><span class="alectryon-token"><span class="k">if</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> <span class="bp">&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>5</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">5</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">then</span></span><span class="alectryon-token"> {
      </span><span class="alectryon-token"><span class="k">break</span></span><span class="alectryon-token">
    }<span class="bp">;</span>
    </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>IO.println</var><b>: </b><span>{α : Type} → [inst : ToString α] → α → IO Unit</span></span></div></blockquote></div></small></div>IO.println</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token">
  }

</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="For-lean-chk5f" style="display: none" type="checkbox"><label class="alectryon-input" for="For-lean-chk5f"><span class="alectryon-token"><span class="k">#eval</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="mi">1</span>
<span class="mi">3</span>
<span class="mi">5</span>
</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">do</span><span class="bp">&#39;</span></span><span class="alectryon-token">
  </span><span class="alectryon-token"><span class="k">for</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">in</span></span><span class="alectryon-token"> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>0</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">0</span></span><span class="alectryon-token">:</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>10</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">10</span></span><span class="alectryon-token">] </span><span class="alectryon-token"><span class="k">do</span><span class="bp">&#39;</span></span><span class="alectryon-token"> {
    </span><span class="alectryon-token"><span class="k">if</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> <span class="bp">%</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>2</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">2</span></span><span class="alectryon-token"> <span class="bp">==</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>0</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">0</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">then</span></span><span class="alectryon-token"> {
      </span><span class="alectryon-token"><span class="k">continue</span></span><span class="alectryon-token">
    }<span class="bp">;</span>
    </span><span class="alectryon-token"><span class="k">if</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> <span class="bp">&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>5</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">5</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">then</span></span><span class="alectryon-token"> {
      </span><span class="alectryon-token"><span class="k">return</span></span><span class="alectryon-token"> ()
    }<span class="bp">;</span>
    </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>IO.println</var><b>: </b><span>{α : Type} → [inst : ToString α] → α → IO Unit</span></span></div></blockquote></div></small></div>IO.println</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token">
  }


<span class="c1">-- set_option trace.compiler.ir.init true</span>
</span><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ex1</var><b>: </b><span>List Nat → Nat → Id Nat</span></span></div></blockquote></div></small></div><span class="nv">ex1</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>xs</var><b>: </b><span>List Nat</span></span></div></blockquote></div></small></div><span class="nv">xs</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>List</var><b>: </b><span>Type → Type</span></span></div></blockquote></div></small></div>List</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Nat</span><span class="alectryon-token">) (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>z</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">z</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Nat</span><span class="alectryon-token">) : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Id</var><b>: </b><span>Type → Type</span></span></div></blockquote></div></small></div>Id</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Nat</span><span class="alectryon-token"> := </span><span class="alectryon-token"><span class="k">do</span><span class="bp">&#39;</span></span><span class="alectryon-token">
  </span><span class="alectryon-token"><span class="k">let</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">mut</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s1</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">s1</span></span><span class="alectryon-token"> := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>0</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">0</span></span><span class="alectryon-token"><span class="bp">;</span>
  </span><span class="alectryon-token"><span class="k">let</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">mut</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s2</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">s2</span></span><span class="alectryon-token"> := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>0</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">0</span></span><span class="alectryon-token"><span class="bp">;</span>
  </span><span class="alectryon-token"><span class="k">for</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">in</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>xs</var><b>: </b><span>List Nat</span></span></div></blockquote></div></small></div><span class="nv">xs</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">do</span><span class="bp">&#39;</span></span><span class="alectryon-token"> {
    </span><span class="alectryon-token"><span class="k">if</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> <span class="bp">%</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>2</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">2</span></span><span class="alectryon-token"> <span class="bp">==</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>0</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">0</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">then</span></span><span class="alectryon-token"> {
      </span><span class="alectryon-token"><span class="k">continue</span></span><span class="alectryon-token">
    }<span class="bp">;</span>
    </span><span class="alectryon-token"><span class="k">if</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> <span class="bp">==</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>z</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">z</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">then</span></span><span class="alectryon-token"> {
      </span><span class="alectryon-token"><span class="k">return</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s1</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">s1</span></span><span class="alectryon-token">
    }<span class="bp">;</span>
    s1 := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s1</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">s1</span></span><span class="alectryon-token"> <span class="bp">+</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"><span class="bp">;</span>
    s2 := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s2</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">s2</span></span><span class="alectryon-token"> <span class="bp">+</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s1</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">s1</span></span><span class="alectryon-token">
  }<span class="bp">;</span>
  </span><span class="alectryon-token"><span class="k">return</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s1</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">s1</span></span><span class="alectryon-token"> <span class="bp">+</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s2</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">s2</span></span><span class="alectryon-token">)

<span class="c">/-</span><span class="cm"></span>
<span class="cm">Adding `repeat` and `while` statements</span>
<span class="cm">-/</span>

<span class="c1">-- The &quot;partial&quot; keyword allows users to define non-terminating functions in Lean.</span>
<span class="c1">-- However, we currently cannot reason about them.</span>
<span class="kd">@[specialize]</span> </span><span class="alectryon-token"><span class="k">partial</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>loopForever</var><b>: </b><span>[inst : Monad m] → (Unit → m Unit) → m Unit</span></span></div></blockquote></div></small></div><span class="nv">loopForever</span></span><span class="alectryon-token"> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Monad</var><b>: </b><span>(Type → Type u_1) → Type (max 1 u_1)</span></span></div></blockquote></div></small></div>Monad</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>Type → Type u_1</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token">] (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>Unit → m Unit</span></span></div></blockquote></div></small></div><span class="nv">f</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Unit</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Unit</span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>Type → Type u_1</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Unit</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Unit</span><span class="alectryon-token">) : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>Type → Type u_1</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Unit</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Unit</span><span class="alectryon-token"> :=
  </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>Unit → m Unit</span></span></div></blockquote></div></small></div><span class="nv">f</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>()</var><b>: </b><span>Unit</span></span></div></blockquote></div></small></div>()</span><span class="alectryon-token"> <span class="bp">*&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>loopForever</var><b>: </b><span>[inst : Monad m] → (Unit → m Unit) → m Unit</span></span></div></blockquote></div></small></div><span class="nv">loopForever</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>Unit → m Unit</span></span></div></blockquote></div></small></div><span class="nv">f</span></span><span class="alectryon-token">

<span class="c1">-- `Loop&#39;` is a &quot;helper&quot; type. It is similar to `Unit`.</span>
<span class="c1">-- Its `ForM` instance produces an &quot;infinite&quot; sequence of units.</span>
</span><span class="alectryon-token"><span class="kd">inductive</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Loop'</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">Loop&#39;</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">where</span></span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>mk</var><b>: </b><span>Loop'</span></span></div></blockquote></div></small></div>mk</span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Loop'</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">Loop&#39;</span></span><span class="alectryon-token">

</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>instance</var><b>: </b><span>{m : Type → Type u_1} → ForM m Loop' Unit</span></span></div></blockquote></div></small></div><span class="kd">instance</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ForM</var><b>: </b><span>(Type → Type u_1) → Type → outParam Type → Type (max (max 1 u_1) 0)</span></span></div></blockquote></div></small></div>ForM</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>Type → Type u_1</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Loop'</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Loop&#39;</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Unit</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Unit</span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">where</span></span><span class="alectryon-token">
  forM _ </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>Unit → m PUnit</span></span></div></blockquote></div></small></div><span class="nv">f</span></span><span class="alectryon-token"> := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>loopForever</var><b>: </b><span>{m : Type → Type u_1} → [inst : Monad m] → (Unit → m Unit) → m Unit</span></span></div></blockquote></div></small></div>loopForever</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>Unit → m PUnit</span></span></div></blockquote></div></small></div><span class="nv">f</span></span><span class="alectryon-token">

</span><span class="alectryon-token"><span class="k">macro</span></span><span class="alectryon-token">:<span class="mi">0</span> </span><span class="alectryon-token"><span class="s2">&quot;repeat&quot;</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>TSyntax `stmt</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token">:stmt:<span class="mi">1</span> : stmt <span class="bp">=&gt;</span> <span class="bp">`</span>(stmt<span class="bp">|</span> </span><span class="alectryon-token"><span class="k">for</span></span><span class="alectryon-token"> u </span><span class="alectryon-token"><span class="k">in</span></span><span class="alectryon-token"> Loop&#39;.mk </span><span class="alectryon-token"><span class="k">do</span><span class="bp">&#39;</span></span><span class="alectryon-token"> <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>TSyntax `stmt</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token">)</span><span class="alectryon-token">

</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="For-lean-chk60" style="display: none" type="checkbox"><label class="alectryon-input" for="For-lean-chk60"><span class="alectryon-token"><span class="k">#eval</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="mi">0</span>
<span class="mi">1</span>
<span class="mi">2</span>
<span class="mi">3</span>
<span class="mi">4</span>
<span class="mi">5</span>
<span class="mi">6</span>
<span class="mi">7</span>
<span class="mi">8</span>
<span class="mi">9</span>
<span class="mi">10</span>
<span class="mi">11</span>
</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">do</span><span class="bp">&#39;</span></span><span class="alectryon-token">
  </span><span class="alectryon-token"><span class="k">let</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">mut</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>i</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">i</span></span><span class="alectryon-token"> := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>0</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">0</span></span><span class="alectryon-token"><span class="bp">;</span>
  </span><span class="alectryon-token"><span class="k">repeat</span></span><span class="alectryon-token"> {
    </span><span class="alectryon-token"><span class="k">if</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>i</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">i</span></span><span class="alectryon-token"> <span class="bp">&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>10</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">10</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">then</span></span><span class="alectryon-token"> {
      </span><span class="alectryon-token"><span class="k">break</span></span><span class="alectryon-token">
    }<span class="bp">;</span>
    </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>IO.println</var><b>: </b><span>{α : Type} → [inst : ToString α] → α → IO Unit</span></span></div></blockquote></div></small></div>IO.println</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>i</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">i</span></span><span class="alectryon-token"><span class="bp">;</span>
    i := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>i</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">i</span></span><span class="alectryon-token"> <span class="bp">+</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>1</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">1</span></span><span class="alectryon-token">
  }<span class="bp">;</span>
  </span><span class="alectryon-token"><span class="k">return</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>i</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">i</span></span><span class="alectryon-token">

</span><span class="alectryon-token"><span class="k">macro</span></span><span class="alectryon-token">:<span class="mi">0</span> </span><span class="alectryon-token"><span class="s2">&quot;while&quot;</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>c</var><b>: </b><span>TSyntax `term</span></span></div></blockquote></div></small></div><span class="nv">c</span></span><span class="alectryon-token">:term </span><span class="alectryon-token"><span class="s2">&quot;do&#39;&quot;</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>TSyntax `stmt</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token">:stmt:<span class="mi">1</span> : stmt <span class="bp">=&gt;</span> <span class="bp">`</span>(stmt<span class="bp">|</span> </span><span class="alectryon-token"><span class="k">repeat</span></span><span class="alectryon-token"> { </span><span class="alectryon-token"><span class="k">unless</span></span><span class="alectryon-token"> <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>c</var><b>: </b><span>TSyntax `term</span></span></div></blockquote></div></small></div><span class="nv">c</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">do</span><span class="bp">&#39;</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">break</span></span><span class="alectryon-token"><span class="bp">;</span> { <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>TSyntax `stmt</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token"> } })</span><span class="alectryon-token">

</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="For-lean-chk61" style="display: none" type="checkbox"><label class="alectryon-input" for="For-lean-chk61"><span class="alectryon-token"><span class="k">#eval</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="mi">0</span>
<span class="mi">1</span>
<span class="mi">2</span>
<span class="mi">3</span>
<span class="mi">4</span>
<span class="mi">5</span>
<span class="mi">6</span>
<span class="mi">7</span>
<span class="mi">8</span>
<span class="mi">9</span>
<span class="mi">10</span>
</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">do</span><span class="bp">&#39;</span></span><span class="alectryon-token">
  </span><span class="alectryon-token"><span class="k">let</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">mut</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>i</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">i</span></span><span class="alectryon-token"> := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>0</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">0</span></span><span class="alectryon-token"><span class="bp">;</span>
  </span><span class="alectryon-token"><span class="k">while</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>i</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">i</span></span><span class="alectryon-token"> <span class="bp">&lt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>10</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">10</span></span><span class="alectryon-token">) </span><span class="alectryon-token"><span class="k">do</span><span class="bp">&#39;</span></span><span class="alectryon-token"> {
    </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>IO.println</var><b>: </b><span>{α : Type} → [inst : ToString α] → α → IO Unit</span></span></div></blockquote></div></small></div>IO.println</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>i</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">i</span></span><span class="alectryon-token"><span class="bp">;</span>
    i := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>i</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">i</span></span><span class="alectryon-token"> <span class="bp">+</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>1</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">1</span></span><span class="alectryon-token">
  }<span class="bp">;</span>
  </span><span class="alectryon-token"><span class="k">return</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>i</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">i</span></span><span class="alectryon-token"></span></span></pre><div style="break-before: page; page-break-before: always;"></div><pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kn">import</span> Do.For  <span class="c1">-- import `runCatch`</span>
<span class="kn">import</span> Lean
<span class="kn">import</span> Aesop</span></span></pre>
<h1 id="formalization-of-extended-do-translation"><a class="header" href="#formalization-of-extended-do-translation">Formalization of Extended <code>do</code> Translation</a></h1>
<p>This is the supplement file to the paper &quot;‘do’ Unchained: Embracing Local Imperativity in a Purely
Functional Language&quot;.
It contains an intrinsically typed representation of the paper's syntax of <code>do</code> statements as well
of their translation functions and an equivalence proof thereof to a simple denotational semantics.</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --></pre>
<h2 id="contexts"><a class="header" href="#contexts">Contexts</a></h2>
<p>We represent contexts as lists of types and assignments of them as heterogeneous lists over these types.
As is common with lists, contexts grow to the left in our presentation.
The following encoding of heterogeneous lists avoids the universe bump of the usual inductive definition
(<a href="https://lists.chalmers.se/pipermail/agda/2010/001826.html">https://lists.chalmers.se/pipermail/agda/2010/001826.html</a>).</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>HList</var><b>: </b><span>List (Type u) → Type u</span></span></div></blockquote></div></small></div><span class="nv">HList</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>List</var><b>: </b><span>Type (u + 1) → Type (u + 1)</span></span></div></blockquote></div></small></div>List</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Type u</var><b>: </b><span>Type (u + 1)</span></span></div></blockquote></div></small></div><span class="kt">Type</span> u</span><span class="alectryon-token">) <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Type u</var><b>: </b><span>Type (u + 1)</span></span></div></blockquote></div></small></div><span class="kt">Type</span> u</span><span class="alectryon-token">
  <span class="bp">|</span> []      <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>PUnit</var><b>: </b><span>Type u</span></span></div></blockquote></div></small></div>PUnit</span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type u</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token"> :: </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>αs</var><b>: </b><span>List (Type u)</span></span></div></blockquote></div></small></div><span class="nv">αs</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type u</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token"> <span class="bp">×</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>HList</var><b>: </b><span>List (Type u) → Type u</span></span></div></blockquote></div></small></div><span class="nv">HList</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>αs</var><b>: </b><span>List (Type u)</span></span></div></blockquote></div></small></div><span class="nv">αs</span></span><span class="alectryon-token">

<span class="kd">@[matchPattern]</span> </span><span class="alectryon-token"><span class="k">abbrev</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>HList.nil</var><b>: </b><span>HList []</span></span></div></blockquote></div></small></div><span class="nv">HList.nil</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>HList</var><b>: </b><span>List (Type u_1) → Type u_1</span></span></div></blockquote></div></small></div>HList</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>[]</var><b>: </b><span>List (Type u_1)</span></span></div></blockquote></div></small></div>[]</span><span class="alectryon-token"> := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>⟨⟩</var><b>: </b><span>PUnit</span></span></div></blockquote></div></small></div>⟨⟩</span><span class="alectryon-token">
<span class="kd">@[matchPattern]</span> </span><span class="alectryon-token"><span class="k">abbrev</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>HList.cons</var><b>: </b><span>{α : Type u_1} → {αs : List (Type u_1)} → α → HList αs → HList (α :: αs)</span></span></div></blockquote></div></small></div><span class="nv">HList.cons</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type u_1</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token">) (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>as</var><b>: </b><span>HList αs</span></span></div></blockquote></div></small></div><span class="nv">as</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>HList</var><b>: </b><span>List (Type u_1) → Type u_1</span></span></div></blockquote></div></small></div>HList</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>αs</var><b>: </b><span>List (Type u_1)</span></span></div></blockquote></div></small></div><span class="nv">αs</span></span><span class="alectryon-token">) : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>HList</var><b>: </b><span>List (Type u_1) → Type u_1</span></span></div></blockquote></div></small></div>HList</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type u_1</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token"> :: </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>αs</var><b>: </b><span>List (Type u_1)</span></span></div></blockquote></div></small></div><span class="nv">αs</span></span><span class="alectryon-token">) := (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>as</var><b>: </b><span>HList αs</span></span></div></blockquote></div></small></div><span class="nv">as</span></span><span class="alectryon-token">)</span></span></pre>
<p>We overload the common list notations <code>::</code> and <code>[e, ...]</code> for <code>HList</code>.</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">infixr</span></span><span class="alectryon-token">:<span class="mi">67</span> <span class="s2">&quot; :: &quot;</span> <span class="bp">=&gt;</span> HList.cons

</span><span class="alectryon-token"><span class="k">syntax</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><span class="k">name</span></span><span class="alectryon-token"> := hlistCons) <span class="s2">&quot;[&quot;</span> term,<span class="bp">*</span> <span class="s2">&quot;]&quot;</span> : term
</span><span class="alectryon-token"><span class="k">macro_rules</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><span class="k">kind</span></span><span class="alectryon-token"> := hlistCons)
  <span class="bp">|</span> <span class="bp">`</span>([])          <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>`(HList.nil)</var><b>: </b><span>Lean.MacroM Lean.Syntax</span></span></div></blockquote></div></small></div><span class="bp">`</span>(HList.nil)</span><span class="alectryon-token">
  <span class="bp">|</span> <span class="bp">`</span>([<span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>Lean.TSyntax `term</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token">])        <span class="bp">=&gt;</span> <span class="bp">`</span>(HList.cons <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>Lean.TSyntax `term</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> [])
  <span class="bp">|</span> <span class="bp">`</span>([<span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>Lean.TSyntax `term</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token">, <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>xs</var><b>: </b><span>Lean.Syntax.TSepArray `term &quot;,&quot;</span></span></div></blockquote></div></small></div><span class="nv">xs</span></span><span class="alectryon-token">,<span class="bp">*</span>]) <span class="bp">=&gt;</span> <span class="bp">`</span>(HList.cons <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>Lean.TSyntax `term</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> [<span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>xs</var><b>: </b><span>Lean.Syntax.TSepArray `term &quot;,&quot;</span></span></div></blockquote></div></small></div><span class="nv">xs</span></span><span class="alectryon-token">,<span class="bp">*</span>])</span></span></pre>
<p>Lean's very general, heterogeneous definition of <code>++</code> causes some issues with our overloading above in terms
such as <code>a ++ [b]</code>, so we restrict it to the <code>List</code> interpretation in the following, which is sufficient for our purposes.</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kn">local</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">macro_rules</span></span><span class="alectryon-token">
  <span class="bp">|</span> <span class="bp">`</span>(<span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>Lean.TSyntax `term</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"> <span class="bp">++</span> <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>Lean.TSyntax `term</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token">) <span class="bp">=&gt;</span> <span class="bp">`</span>(List.append <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>Lean.TSyntax `term</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"> <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>Lean.TSyntax `term</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token">)</span><span class="alectryon-token">

</span><span class="alectryon-token"><span class="k">abbrev</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Assg</var><b>: </b><span>List (Type u_1) → Type u_1</span></span></div></blockquote></div></small></div><span class="nv">Assg</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Γ</var><b>: </b><span>List (Type u_1)</span></span></div></blockquote></div></small></div><span class="nv">Γ</span></span><span class="alectryon-token"> := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>HList</var><b>: </b><span>List (Type u_1) → Type u_1</span></span></div></blockquote></div></small></div>HList</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Γ</var><b>: </b><span>List (Type u_1)</span></span></div></blockquote></div></small></div><span class="nv">Γ</span></span><span class="alectryon-token"></span></span></pre>
<p>Updating a heterogeneous list at a given, guaranteed in-bounds index.</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>HList.set</var><b>: </b><span>{αs : List (Type u)} → HList αs → (i : Fin (List.length αs)) → List.get αs i → HList αs</span></span></div></blockquote></div></small></div><span class="nv">HList.set</span></span><span class="alectryon-token"> : {</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>αs</var><b>: </b><span>List (Type u)</span></span></div></blockquote></div></small></div><span class="nv">αs</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>List</var><b>: </b><span>Type (u + 1) → Type (u + 1)</span></span></div></blockquote></div></small></div>List</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Type u</var><b>: </b><span>Type (u + 1)</span></span></div></blockquote></div></small></div><span class="kt">Type</span> u</span><span class="alectryon-token">)} <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>HList</var><b>: </b><span>List (Type u) → Type u</span></span></div></blockquote></div></small></div>HList</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>αs</var><b>: </b><span>List (Type u)</span></span></div></blockquote></div></small></div><span class="nv">αs</span></span><span class="alectryon-token"> <span class="bp">→</span> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>i</var><b>: </b><span>Fin (List.length αs)</span></span></div></blockquote></div></small></div><span class="nv">i</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Fin</var><b>: </b><span>Nat → Type</span></span></div></blockquote></div></small></div>Fin</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>αs</var><b>: </b><span>List (Type u)</span></span></div></blockquote></div></small></div><span class="nv">αs</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>length</var><b>: </b><span>{α : Type (u + 1)} → List α → Nat</span></span></div></blockquote></div></small></div>length</span><span class="alectryon-token">) <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>αs</var><b>: </b><span>List (Type u)</span></span></div></blockquote></div></small></div><span class="nv">αs</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>get</var><b>: </b><span>{α : Type (u + 1)} → (as : List α) → Fin (List.length as) → α</span></span></div></blockquote></div></small></div>get</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>i</var><b>: </b><span>Fin (List.length αs)</span></span></div></blockquote></div></small></div><span class="nv">i</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>HList</var><b>: </b><span>List (Type u) → Type u</span></span></div></blockquote></div></small></div>HList</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>αs</var><b>: </b><span>List (Type u)</span></span></div></blockquote></div></small></div><span class="nv">αs</span></span><span class="alectryon-token">
  <span class="bp">|</span> _ :: _, _ :: </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>as</var><b>: </b><span>HList a✝</span></span></div></blockquote></div></small></div><span class="nv">as</span></span><span class="alectryon-token">, ⟨</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>0</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">0</span></span><span class="alectryon-token">,          _⟩, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>List.get (α✝ :: a✝) { val := 0, isLt := isLt✝ }</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>List.get (α✝ :: a✝) { val := 0, isLt := isLt✝ }</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token"> :: </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>as</var><b>: </b><span>HList a✝</span></span></div></blockquote></div></small></div><span class="nv">as</span></span><span class="alectryon-token">
  <span class="bp">|</span> _ :: _, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>α✝</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"> :: </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>as</var><b>: </b><span>HList a✝</span></span></div></blockquote></div></small></div><span class="nv">as</span></span><span class="alectryon-token">, ⟨</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat.succ</var><b>: </b><span>Nat → Nat</span></span></div></blockquote></div></small></div>Nat.succ</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>n</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">n</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>h</var><b>: </b><span>Nat.succ n &lt; List.length (α✝ :: a✝)</span></span></div></blockquote></div></small></div><span class="nv">h</span></span><span class="alectryon-token">⟩, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>List.get (α✝ :: a✝) { val := Nat.succ n, isLt := h }</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>α✝</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"> :: </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>set</var><b>: </b><span>{αs : List (Type u)} → HList αs → (i : Fin (List.length αs)) → List.get αs i → HList αs</span></span></div></blockquote></div></small></div><span class="nv">set</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>as</var><b>: </b><span>HList a✝</span></span></div></blockquote></div></small></div><span class="nv">as</span></span><span class="alectryon-token"> ⟨</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>n</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">n</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat.le_of_succ_le_succ</var><b>: </b><span>∀ {n m : Nat}, Nat.succ n ≤ Nat.succ m → n ≤ m</span></span></div></blockquote></div></small></div>Nat.le_of_succ_le_succ</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>h</var><b>: </b><span>Nat.succ n &lt; List.length (α✝ :: a✝)</span></span></div></blockquote></div></small></div><span class="nv">h</span></span><span class="alectryon-token">⟩ </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>List.get (α✝ :: a✝) { val := Nat.succ n, isLt := h }</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token">
  <span class="bp">|</span> [],     [],      _,               _ <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>[]</var><b>: </b><span>HList []</span></span></div></blockquote></div></small></div>[]</span><span class="alectryon-token"></span></span></pre>
<p>We write <code>∅</code> for empty contexts and assignments and <code>Γ ⊢ α</code> for the type of values of type <code>α</code> under the context <code>Γ</code></p>
<ul>
<li>that is, the function type from an assignment to <code>α</code>.</li>
</ul>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>instance</var><b>: </b><span>EmptyCollection (Assg ∅)</span></span></div></blockquote></div></small></div><span class="kd">instance</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>EmptyCollection</var><b>: </b><span>Type u_1 → Type u_1</span></span></div></blockquote></div></small></div>EmptyCollection</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Assg</var><b>: </b><span>List (Type u_1) → Type u_1</span></span></div></blockquote></div></small></div>Assg</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>∅</var><b>: </b><span>List (Type u_1)</span></span></div></blockquote></div></small></div><span class="bp">∅</span></span><span class="alectryon-token">) </span><span class="alectryon-token"><span class="k">where</span></span><span class="alectryon-token">
  emptyCollection := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>[]</var><b>: </b><span>HList []</span></span></div></blockquote></div></small></div>[]</span><span class="alectryon-token">

</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>instance</var><b>: </b><span>CoeSort (List (Type u)) (Type u)</span></span></div></blockquote></div></small></div><span class="kd">instance</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>CoeSort</var><b>: </b><span>Type (u + 1) → outParam (Type (u + 1)) → Type (u + 1)</span></span></div></blockquote></div></small></div>CoeSort</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>List</var><b>: </b><span>Type (u + 1) → Type (u + 1)</span></span></div></blockquote></div></small></div>List</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Type u</var><b>: </b><span>Type (u + 1)</span></span></div></blockquote></div></small></div><span class="kt">Type</span> u</span><span class="alectryon-token">)) (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Type u</var><b>: </b><span>Type (u + 1)</span></span></div></blockquote></div></small></div><span class="kt">Type</span> u</span><span class="alectryon-token">) := ⟨</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Assg</var><b>: </b><span>List (Type u) → Type u</span></span></div></blockquote></div></small></div>Assg</span><span class="alectryon-token">⟩

</span><span class="alectryon-token"><span class="kd">notation</span></span><span class="alectryon-token">:<span class="mi">30</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Γ</var><b>: </b><span>Lean.TSyntax `term</span></span></div></blockquote></div></small></div><span class="nv">Γ</span></span><span class="alectryon-token"> <span class="s2">&quot; ⊢ &quot;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Lean.TSyntax `term</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> Assg </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Γ</var><b>: </b><span>Lean.TSyntax `term</span></span></div></blockquote></div></small></div><span class="nv">Γ</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Lean.TSyntax `term</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token">

</span><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Assg.drop</var><b>: </b><span>{α : Type u_1} → {Γ : List (Type u_1)} → Assg (α :: Γ) → Assg Γ</span></span></div></blockquote></div></small></div><span class="nv">Assg.drop</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Assg</var><b>: </b><span>List (Type u_1) → Type u_1</span></span></div></blockquote></div></small></div>Assg</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type u_1</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token"> :: </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Γ</var><b>: </b><span>List (Type u_1)</span></span></div></blockquote></div></small></div><span class="nv">Γ</span></span><span class="alectryon-token">) <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Assg</var><b>: </b><span>List (Type u_1) → Type u_1</span></span></div></blockquote></div></small></div>Assg</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Γ</var><b>: </b><span>List (Type u_1)</span></span></div></blockquote></div></small></div><span class="nv">Γ</span></span><span class="alectryon-token">
  <span class="bp">|</span> _ :: </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>as</var><b>: </b><span>HList Γ</span></span></div></blockquote></div></small></div><span class="nv">as</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>as</var><b>: </b><span>HList Γ</span></span></div></blockquote></div></small></div><span class="nv">as</span></span><span class="alectryon-token"></span></span></pre>
<p>In one special case, we will need to manipulate contexts from the right, i.e. the outermost scope.</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Assg.extendBot</var><b>: </b><span>{α : Type u_1} → α → {Γ : List (Type u_1)} → Assg Γ → Assg (List.append Γ [α])</span></span></div></blockquote></div></small></div><span class="nv">Assg.extendBot</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type u_1</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token">) : {</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Γ</var><b>: </b><span>List (Type u_1)</span></span></div></blockquote></div></small></div><span class="nv">Γ</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>_</var><b>: </b><span>Type (u_1 + 1)</span></span></div></blockquote></div></small></div>_</span><span class="alectryon-token">} <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Assg</var><b>: </b><span>List (Type u_1) → Type u_1</span></span></div></blockquote></div></small></div>Assg</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Γ</var><b>: </b><span>List (Type u_1)</span></span></div></blockquote></div></small></div><span class="nv">Γ</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Assg</var><b>: </b><span>List (Type u_1) → Type u_1</span></span></div></blockquote></div></small></div>Assg</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Γ</var><b>: </b><span>List (Type u_1)</span></span></div></blockquote></div></small></div><span class="nv">Γ</span></span><span class="alectryon-token"> <span class="bp">++</span> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type u_1</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token">])
  <span class="bp">|</span> [],     []      <span class="bp">=&gt;</span> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token">]
  <span class="bp">|</span> _ :: _, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>α✝</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"> :: </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>as</var><b>: </b><span>HList a✝</span></span></div></blockquote></div></small></div><span class="nv">as</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>α✝</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"> :: </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>extendBot</var><b>: </b><span>{α : Type u_1} → α → {Γ : List (Type u_1)} → Assg Γ → Assg (List.append Γ [α])</span></span></div></blockquote></div></small></div><span class="nv">extendBot</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>as</var><b>: </b><span>HList a✝</span></span></div></blockquote></div></small></div><span class="nv">as</span></span><span class="alectryon-token">

</span><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Assg.dropBot</var><b>: </b><span>{α : Type u_1} → {Γ : List (Type u_1)} → Assg (List.append Γ [α]) → Assg Γ</span></span></div></blockquote></div></small></div><span class="nv">Assg.dropBot</span></span><span class="alectryon-token"> : {</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Γ</var><b>: </b><span>List (Type u_1)</span></span></div></blockquote></div></small></div><span class="nv">Γ</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>_</var><b>: </b><span>Type (u_1 + 1)</span></span></div></blockquote></div></small></div>_</span><span class="alectryon-token">} <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Assg</var><b>: </b><span>List (Type u_1) → Type u_1</span></span></div></blockquote></div></small></div>Assg</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Γ</var><b>: </b><span>List (Type u_1)</span></span></div></blockquote></div></small></div><span class="nv">Γ</span></span><span class="alectryon-token"> <span class="bp">++</span> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type u_1</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token">]) <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Assg</var><b>: </b><span>List (Type u_1) → Type u_1</span></span></div></blockquote></div></small></div>Assg</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Γ</var><b>: </b><span>List (Type u_1)</span></span></div></blockquote></div></small></div><span class="nv">Γ</span></span><span class="alectryon-token">
  <span class="bp">|</span> [],     _       <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>[]</var><b>: </b><span>HList []</span></span></div></blockquote></div></small></div>[]</span><span class="alectryon-token">
  <span class="bp">|</span> _ :: </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>_</var><b>: </b><span>List (Type u_1)</span></span></div></blockquote></div></small></div>_</span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>α✝</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"> :: </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>as</var><b>: </b><span>HList (List.append tail✝ [α])</span></span></div></blockquote></div></small></div><span class="nv">as</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>α✝</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"> :: </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>dropBot</var><b>: </b><span>{α : Type u_1} → {Γ : List (Type u_1)} → Assg (List.append Γ [α]) → Assg Γ</span></span></div></blockquote></div></small></div><span class="nv">dropBot</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>as</var><b>: </b><span>HList (List.append tail✝ [α])</span></span></div></blockquote></div></small></div><span class="nv">as</span></span><span class="alectryon-token"></span></span></pre>
<h2 id="intrinsically-typed-representation-of-do-statements"><a class="header" href="#intrinsically-typed-representation-of-do-statements">Intrinsically Typed Representation of <code>do</code> Statements</a></h2>
<p>where</p>
<ul>
<li>m: base monad</li>
<li>ω: <code>return</code> type, <code>m ω</code> is the type of the entire <code>do</code> block</li>
<li>Γ: <code>do</code>-local immutable context</li>
<li>Δ: <code>do</code>-local mutable context</li>
<li>b: <code>break</code> allowed</li>
<li>c: <code>continue</code> allowed</li>
<li>α: local result type, <code>m α</code> is the type of the statement</li>
</ul>
<p>The constructor signatures are best understood by comparing them with the corresponding typing rules in the paper.
Note that the choice of de Bruijn indices changes/simplifies some parts, such as obviating freshness checks (<code>x ∉ Δ</code>).</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">inductive</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt</var><b>: </b><span>(Type → Type u) → Type → List Type → List Type → Bool → Bool → Type → Type (max 1 u)</span></span></div></blockquote></div></small></div><span class="nv">Stmt</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>Type → Type u</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Type</var><b>: </b><span>Type 1</span></span></div></blockquote></div></small></div><span class="kt">Type</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Type u</var><b>: </b><span>Type (u + 1)</span></span></div></blockquote></div></small></div><span class="kt">Type</span> u</span><span class="alectryon-token">) (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ω</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">ω</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Type</var><b>: </b><span>Type 1</span></span></div></blockquote></div></small></div><span class="kt">Type</span></span><span class="alectryon-token">) : (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Γ</var><b>: </b><span>List Type</span></span></div></blockquote></div></small></div><span class="nv">Γ</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Δ</var><b>: </b><span>List Type</span></span></div></blockquote></div></small></div><span class="nv">Δ</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>List</var><b>: </b><span>Type 1 → Type 1</span></span></div></blockquote></div></small></div>List</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Type</var><b>: </b><span>Type 1</span></span></div></blockquote></div></small></div><span class="kt">Type</span></span><span class="alectryon-token">) <span class="bp">→</span> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>c</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div><span class="nv">c</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Bool</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Bool</span><span class="alectryon-token">) <span class="bp">→</span> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Type</var><b>: </b><span>Type 1</span></span></div></blockquote></div></small></div><span class="kt">Type</span></span><span class="alectryon-token">) <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Type _</var><b>: </b><span>Type ((max 1 u) + 1)</span></span></div></blockquote></div></small></div><span class="kt">Type</span> _</span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">where</span></span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>expr</var><b>: </b><span>{m : Type → Type u} →
  {ω : Type} → {Γ Δ : List Type} → {α : Type} → {b c : Bool} → (Assg Γ → Assg Δ → m α) → Stmt m ω Γ Δ b c α</span></span></div></blockquote></div></small></div>expr</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>Assg Γ → Assg Δ → m α</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Γ</var><b>: </b><span>List Type</span></span></div></blockquote></div></small></div><span class="nv">Γ</span></span><span class="alectryon-token"> <span class="bp">⊢</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Δ</var><b>: </b><span>List Type</span></span></div></blockquote></div></small></div><span class="nv">Δ</span></span><span class="alectryon-token"> <span class="bp">⊢</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>Type → Type u</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token">) : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt</var><b>: </b><span>(Type → Type u) → Type → List Type → List Type → Bool → Bool → Type → Type (max 1 u)</span></span></div></blockquote></div></small></div><span class="nv">Stmt</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>Type → Type u</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ω</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">ω</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Γ</var><b>: </b><span>List Type</span></span></div></blockquote></div></small></div><span class="nv">Γ</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Δ</var><b>: </b><span>List Type</span></span></div></blockquote></div></small></div><span class="nv">Δ</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>c</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div><span class="nv">c</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>bind</var><b>: </b><span>{m : Type → Type u} →
  {ω : Type} →
    {Γ Δ : List Type} →
      {b c : Bool} → {α β : Type} → Stmt m ω Γ Δ b c α → Stmt m ω (α :: Γ) Δ b c β → Stmt m ω Γ Δ b c β</span></span></div></blockquote></div></small></div>bind</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>Stmt m ω Γ Δ b c α</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt</var><b>: </b><span>(Type → Type u) → Type → List Type → List Type → Bool → Bool → Type → Type (max 1 u)</span></span></div></blockquote></div></small></div><span class="nv">Stmt</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>Type → Type u</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ω</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">ω</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Γ</var><b>: </b><span>List Type</span></span></div></blockquote></div></small></div><span class="nv">Γ</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Δ</var><b>: </b><span>List Type</span></span></div></blockquote></div></small></div><span class="nv">Δ</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>c</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div><span class="nv">c</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token">) (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s'</var><b>: </b><span>Stmt m ω (α :: Γ) Δ b c β</span></span></div></blockquote></div></small></div><span class="nv">s&#39;</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt</var><b>: </b><span>(Type → Type u) → Type → List Type → List Type → Bool → Bool → Type → Type (max 1 u)</span></span></div></blockquote></div></small></div><span class="nv">Stmt</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>Type → Type u</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ω</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">ω</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token"> :: </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Γ</var><b>: </b><span>List Type</span></span></div></blockquote></div></small></div><span class="nv">Γ</span></span><span class="alectryon-token">) </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Δ</var><b>: </b><span>List Type</span></span></div></blockquote></div></small></div><span class="nv">Δ</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>c</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div><span class="nv">c</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>β</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">β</span></span><span class="alectryon-token">) : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt</var><b>: </b><span>(Type → Type u) → Type → List Type → List Type → Bool → Bool → Type → Type (max 1 u)</span></span></div></blockquote></div></small></div><span class="nv">Stmt</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>Type → Type u</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ω</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">ω</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Γ</var><b>: </b><span>List Type</span></span></div></blockquote></div></small></div><span class="nv">Γ</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Δ</var><b>: </b><span>List Type</span></span></div></blockquote></div></small></div><span class="nv">Δ</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>c</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div><span class="nv">c</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>β</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">β</span></span><span class="alectryon-token">  <span class="c1">-- let _ ← s; s&#39;</span>
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>letmut</var><b>: </b><span>{m : Type → Type u} →
  {ω : Type} →
    {Γ Δ : List Type} →
      {α : Type} → {b c : Bool} → {β : Type} → (Assg Γ → Assg Δ → α) → Stmt m ω Γ (α :: Δ) b c β → Stmt m ω Γ Δ b c β</span></span></div></blockquote></div></small></div>letmut</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>Assg Γ → Assg Δ → α</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Γ</var><b>: </b><span>List Type</span></span></div></blockquote></div></small></div><span class="nv">Γ</span></span><span class="alectryon-token"> <span class="bp">⊢</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Δ</var><b>: </b><span>List Type</span></span></div></blockquote></div></small></div><span class="nv">Δ</span></span><span class="alectryon-token"> <span class="bp">⊢</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token">) (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>Stmt m ω Γ (α :: Δ) b c β</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt</var><b>: </b><span>(Type → Type u) → Type → List Type → List Type → Bool → Bool → Type → Type (max 1 u)</span></span></div></blockquote></div></small></div><span class="nv">Stmt</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>Type → Type u</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ω</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">ω</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Γ</var><b>: </b><span>List Type</span></span></div></blockquote></div></small></div><span class="nv">Γ</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token"> :: </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Δ</var><b>: </b><span>List Type</span></span></div></blockquote></div></small></div><span class="nv">Δ</span></span><span class="alectryon-token">) </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>c</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div><span class="nv">c</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>β</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">β</span></span><span class="alectryon-token">) : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt</var><b>: </b><span>(Type → Type u) → Type → List Type → List Type → Bool → Bool → Type → Type (max 1 u)</span></span></div></blockquote></div></small></div><span class="nv">Stmt</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>Type → Type u</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ω</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">ω</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Γ</var><b>: </b><span>List Type</span></span></div></blockquote></div></small></div><span class="nv">Γ</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Δ</var><b>: </b><span>List Type</span></span></div></blockquote></div></small></div><span class="nv">Δ</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>c</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div><span class="nv">c</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>β</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">β</span></span><span class="alectryon-token">  <span class="c1">-- let mut _ := e; s</span>
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>assg</var><b>: </b><span>{m : Type → Type u} →
  {ω : Type} →
    {Γ Δ : List Type} →
      {b c : Bool} → (x : Fin (List.length Δ)) → (Assg Γ → Assg Δ → List.get Δ x) → Stmt m ω Γ Δ b c Unit</span></span></div></blockquote></div></small></div>assg</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>failed to pretty print expression (use 'set_option pp.rawOnError true' for raw representation)</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Fin</var><b>: </b><span>Nat → Type</span></span></div></blockquote></div></small></div>Fin</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Δ</var><b>: </b><span>List Type</span></span></div></blockquote></div></small></div><span class="nv">Δ</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Δ.length</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>length</var><b>: </b><span>{α : Type 1} → List α → Nat</span></span></div></blockquote></div></small></div>length</span><span class="alectryon-token">) (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>failed to pretty print expression (use 'set_option pp.rawOnError true' for raw representation)</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Γ</var><b>: </b><span>List Type</span></span></div></blockquote></div></small></div><span class="nv">Γ</span></span><span class="alectryon-token"> <span class="bp">⊢</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Δ</var><b>: </b><span>List Type</span></span></div></blockquote></div></small></div><span class="nv">Δ</span></span><span class="alectryon-token"> <span class="bp">⊢</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Δ</var><b>: </b><span>List Type</span></span></div></blockquote></div></small></div><span class="nv">Δ</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>get</var><b>: </b><span>{α : Type 1} → (as : List α) → Fin (List.length as) → α</span></span></div></blockquote></div></small></div>get</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>failed to pretty print expression (use 'set_option pp.rawOnError true' for raw representation)</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token">) : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt</var><b>: </b><span>(Type → Type u) → Type → List Type → List Type → Bool → Bool → Type → Type (max 1 u)</span></span></div></blockquote></div></small></div><span class="nv">Stmt</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>Type → Type u</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ω</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">ω</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Γ</var><b>: </b><span>List Type</span></span></div></blockquote></div></small></div><span class="nv">Γ</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Δ</var><b>: </b><span>List Type</span></span></div></blockquote></div></small></div><span class="nv">Δ</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>c</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div><span class="nv">c</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Unit</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Unit</span><span class="alectryon-token">  <span class="c1">-- x := e</span>
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ite</var><b>: </b><span>{m : Type → Type u} →
  {ω : Type} →
    {Γ Δ : List Type} →
      {b c : Bool} →
        {α : Type} → (Assg Γ → Assg Δ → Bool) → Stmt m ω Γ Δ b c α → Stmt m ω Γ Δ b c α → Stmt m ω Γ Δ b c α</span></span></div></blockquote></div></small></div>ite</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>Assg Γ → Assg Δ → Bool</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Γ</var><b>: </b><span>List Type</span></span></div></blockquote></div></small></div><span class="nv">Γ</span></span><span class="alectryon-token"> <span class="bp">⊢</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Δ</var><b>: </b><span>List Type</span></span></div></blockquote></div></small></div><span class="nv">Δ</span></span><span class="alectryon-token"> <span class="bp">⊢</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Bool</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Bool</span><span class="alectryon-token">) (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s₁</var><b>: </b><span>Stmt m ω Γ Δ b c α</span></span></div></blockquote></div></small></div><span class="nv">s₁</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s₂</var><b>: </b><span>Stmt m ω Γ Δ b c α</span></span></div></blockquote></div></small></div><span class="nv">s₂</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt</var><b>: </b><span>(Type → Type u) → Type → List Type → List Type → Bool → Bool → Type → Type (max 1 u)</span></span></div></blockquote></div></small></div><span class="nv">Stmt</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>Type → Type u</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ω</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">ω</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Γ</var><b>: </b><span>List Type</span></span></div></blockquote></div></small></div><span class="nv">Γ</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Δ</var><b>: </b><span>List Type</span></span></div></blockquote></div></small></div><span class="nv">Δ</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>c</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div><span class="nv">c</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token">) : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt</var><b>: </b><span>(Type → Type u) → Type → List Type → List Type → Bool → Bool → Type → Type (max 1 u)</span></span></div></blockquote></div></small></div><span class="nv">Stmt</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>Type → Type u</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ω</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">ω</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Γ</var><b>: </b><span>List Type</span></span></div></blockquote></div></small></div><span class="nv">Γ</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Δ</var><b>: </b><span>List Type</span></span></div></blockquote></div></small></div><span class="nv">Δ</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>c</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div><span class="nv">c</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token">  <span class="c1">-- if e then s₁ else s₂</span>
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ret</var><b>: </b><span>{m : Type → Type u} →
  {ω : Type} → {Γ Δ : List Type} → {b c : Bool} → {α : Type} → (Assg Γ → Assg Δ → ω) → Stmt m ω Γ Δ b c α</span></span></div></blockquote></div></small></div>ret</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>Assg Γ → Assg Δ → ω</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Γ</var><b>: </b><span>List Type</span></span></div></blockquote></div></small></div><span class="nv">Γ</span></span><span class="alectryon-token"> <span class="bp">⊢</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Δ</var><b>: </b><span>List Type</span></span></div></blockquote></div></small></div><span class="nv">Δ</span></span><span class="alectryon-token"> <span class="bp">⊢</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ω</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">ω</span></span><span class="alectryon-token">) : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt</var><b>: </b><span>(Type → Type u) → Type → List Type → List Type → Bool → Bool → Type → Type (max 1 u)</span></span></div></blockquote></div></small></div><span class="nv">Stmt</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>Type → Type u</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ω</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">ω</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Γ</var><b>: </b><span>List Type</span></span></div></blockquote></div></small></div><span class="nv">Γ</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Δ</var><b>: </b><span>List Type</span></span></div></blockquote></div></small></div><span class="nv">Δ</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>c</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div><span class="nv">c</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token">   <span class="c1">-- return e</span>
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>sfor</var><b>: </b><span>{m : Type → Type u} →
  {ω : Type} →
    {Γ Δ : List Type} →
      {α : Type} →
        {b c : Bool} → (Assg Γ → Assg Δ → List α) → Stmt m ω (α :: Γ) Δ true true Unit → Stmt m ω Γ Δ b c Unit</span></span></div></blockquote></div></small></div>sfor</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>Assg Γ → Assg Δ → List α</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Γ</var><b>: </b><span>List Type</span></span></div></blockquote></div></small></div><span class="nv">Γ</span></span><span class="alectryon-token"> <span class="bp">⊢</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Δ</var><b>: </b><span>List Type</span></span></div></blockquote></div></small></div><span class="nv">Δ</span></span><span class="alectryon-token"> <span class="bp">⊢</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>List</var><b>: </b><span>Type → Type</span></span></div></blockquote></div></small></div>List</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token">) (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>Stmt m ω (α :: Γ) Δ true true Unit</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt</var><b>: </b><span>(Type → Type u) → Type → List Type → List Type → Bool → Bool → Type → Type (max 1 u)</span></span></div></blockquote></div></small></div><span class="nv">Stmt</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>Type → Type u</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ω</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">ω</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token"> :: </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Γ</var><b>: </b><span>List Type</span></span></div></blockquote></div></small></div><span class="nv">Γ</span></span><span class="alectryon-token">) </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Δ</var><b>: </b><span>List Type</span></span></div></blockquote></div></small></div><span class="nv">Δ</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>true</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div>true</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>true</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div>true</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Unit</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Unit</span><span class="alectryon-token">) : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt</var><b>: </b><span>(Type → Type u) → Type → List Type → List Type → Bool → Bool → Type → Type (max 1 u)</span></span></div></blockquote></div></small></div><span class="nv">Stmt</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>Type → Type u</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ω</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">ω</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Γ</var><b>: </b><span>List Type</span></span></div></blockquote></div></small></div><span class="nv">Γ</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Δ</var><b>: </b><span>List Type</span></span></div></blockquote></div></small></div><span class="nv">Δ</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>c</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div><span class="nv">c</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Unit</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Unit</span><span class="alectryon-token">  <span class="c1">-- for _ in e do s</span>
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>sbreak</var><b>: </b><span>{m : Type → Type u} → {ω : Type} → {Γ Δ : List Type} → {c : Bool} → {α : Type} → Stmt m ω Γ Δ true c α</span></span></div></blockquote></div></small></div>sbreak</span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt</var><b>: </b><span>(Type → Type u) → Type → List Type → List Type → Bool → Bool → Type → Type (max 1 u)</span></span></div></blockquote></div></small></div><span class="nv">Stmt</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>Type → Type u</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ω</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">ω</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Γ</var><b>: </b><span>List Type</span></span></div></blockquote></div></small></div><span class="nv">Γ</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Δ</var><b>: </b><span>List Type</span></span></div></blockquote></div></small></div><span class="nv">Δ</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>true</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div>true</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>c</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div><span class="nv">c</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token">  <span class="c1">-- break</span>
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>scont</var><b>: </b><span>{m : Type → Type u} → {ω : Type} → {Γ Δ : List Type} → {b : Bool} → {α : Type} → Stmt m ω Γ Δ b true α</span></span></div></blockquote></div></small></div>scont</span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt</var><b>: </b><span>(Type → Type u) → Type → List Type → List Type → Bool → Bool → Type → Type (max 1 u)</span></span></div></blockquote></div></small></div><span class="nv">Stmt</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>Type → Type u</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ω</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">ω</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Γ</var><b>: </b><span>List Type</span></span></div></blockquote></div></small></div><span class="nv">Γ</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Δ</var><b>: </b><span>List Type</span></span></div></blockquote></div></small></div><span class="nv">Δ</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>true</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div>true</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token">  <span class="c1">-- continue</span></span></span></pre>
<p>Neutral statements are a restriction of the above type.</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">inductive</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Neut</var><b>: </b><span>Type → Type → Bool → Bool → Type</span></span></div></blockquote></div></small></div><span class="nv">Neut</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ω</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">ω</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Type</var><b>: </b><span>Type 1</span></span></div></blockquote></div></small></div><span class="kt">Type</span></span><span class="alectryon-token">) : (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>c</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div><span class="nv">c</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Bool</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Bool</span><span class="alectryon-token">) <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Type _</var><b>: </b><span>Type 1</span></span></div></blockquote></div></small></div><span class="kt">Type</span> _</span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">where</span></span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>val</var><b>: </b><span>{ω α : Type} → {b c : Bool} → α → Neut ω α b c</span></span></div></blockquote></div></small></div>val</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token">) : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Neut</var><b>: </b><span>Type → Type → Bool → Bool → Type</span></span></div></blockquote></div></small></div><span class="nv">Neut</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ω</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">ω</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>c</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div><span class="nv">c</span></span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ret</var><b>: </b><span>{ω α : Type} → {b c : Bool} → ω → Neut ω α b c</span></span></div></blockquote></div></small></div>ret</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>o</var><b>: </b><span>ω</span></span></div></blockquote></div></small></div><span class="nv">o</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ω</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">ω</span></span><span class="alectryon-token">) : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Neut</var><b>: </b><span>Type → Type → Bool → Bool → Type</span></span></div></blockquote></div></small></div><span class="nv">Neut</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ω</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">ω</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>c</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div><span class="nv">c</span></span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>rbreak</var><b>: </b><span>{ω α : Type} → {c : Bool} → Neut ω α true c</span></span></div></blockquote></div></small></div>rbreak</span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Neut</var><b>: </b><span>Type → Type → Bool → Bool → Type</span></span></div></blockquote></div></small></div><span class="nv">Neut</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ω</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">ω</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>true</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div>true</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>c</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div><span class="nv">c</span></span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>rcont</var><b>: </b><span>{ω α : Type} → {b : Bool} → Neut ω α b true</span></span></div></blockquote></div></small></div>rcont</span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Neut</var><b>: </b><span>Type → Type → Bool → Bool → Type</span></span></div></blockquote></div></small></div><span class="nv">Neut</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ω</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">ω</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>true</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div>true</span><span class="alectryon-token"></span></span></pre>
<p>We elide <code>Neut.val</code> where unambiguous.</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>instance</var><b>: </b><span>{α ω : Type} → {b c : Bool} → Coe α (Neut ω α b c)</span></span></div></blockquote></div></small></div><span class="kd">instance</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Coe</var><b>: </b><span>Type → Type → Type</span></span></div></blockquote></div></small></div>Coe</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Neut</var><b>: </b><span>Type → Type → Bool → Bool → Type</span></span></div></blockquote></div></small></div>Neut</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ω</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">ω</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>c</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div><span class="nv">c</span></span><span class="alectryon-token">) := ⟨</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Neut.val</var><b>: </b><span>{ω α : Type} → {b c : Bool} → α → Neut ω α b c</span></span></div></blockquote></div></small></div>Neut.val</span><span class="alectryon-token">⟩
</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>instance</var><b>: </b><span>{α ω : Type} → {b c : Bool} → Coe (Id α) (Neut ω α b c)</span></span></div></blockquote></div></small></div><span class="kd">instance</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Coe</var><b>: </b><span>Type → Type → Type</span></span></div></blockquote></div></small></div>Coe</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Id</var><b>: </b><span>Type → Type</span></span></div></blockquote></div></small></div>Id</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token">) (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Neut</var><b>: </b><span>Type → Type → Bool → Bool → Type</span></span></div></blockquote></div></small></div>Neut</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ω</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">ω</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>c</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div><span class="nv">c</span></span><span class="alectryon-token">) := ⟨</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Neut.val</var><b>: </b><span>{ω α : Type} → {b c : Bool} → α → Neut ω α b c</span></span></div></blockquote></div></small></div>Neut.val</span><span class="alectryon-token">⟩</span></span></pre>
<p>We write <code>e[ρ][σ]</code> for the substitution of both contexts in <code>e</code>, a simple application in this encoding.
<code>σ[x ↦ v]</code> updates <code>σ</code> at <code>v</code> (a de Bruijn index).</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="k">macro</span></span><span class="alectryon-token">:</span><span class="alectryon-token"><span class="k">max</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><span class="k">priority</span></span><span class="alectryon-token"> := </span><span class="alectryon-token"><span class="k">high</span></span><span class="alectryon-token">) </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>Lean.TSyntax `term</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token">:term:</span><span class="alectryon-token"><span class="k">max</span></span><span class="alectryon-token"> noWs <span class="s2">&quot;[&quot;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ρ</var><b>: </b><span>Lean.TSyntax `term</span></span></div></blockquote></div></small></div><span class="nv">ρ</span></span><span class="alectryon-token">:term <span class="s2">&quot;]&quot;</span> <span class="s2">&quot;[&quot;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>σ</var><b>: </b><span>Lean.TSyntax `term</span></span></div></blockquote></div></small></div><span class="nv">σ</span></span><span class="alectryon-token">:term <span class="s2">&quot;]&quot;</span> : term <span class="bp">=&gt;</span> <span class="bp">`</span>(<span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>Lean.TSyntax `term</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token"> <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ρ</var><b>: </b><span>Lean.TSyntax `term</span></span></div></blockquote></div></small></div><span class="nv">ρ</span></span><span class="alectryon-token"> <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>σ</var><b>: </b><span>Lean.TSyntax `term</span></span></div></blockquote></div></small></div><span class="nv">σ</span></span><span class="alectryon-token">)</span><span class="alectryon-token">
</span><span class="alectryon-token"><span class="k">macro</span></span><span class="alectryon-token">:</span><span class="alectryon-token"><span class="k">max</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><span class="k">priority</span></span><span class="alectryon-token"> := </span><span class="alectryon-token"><span class="k">high</span></span><span class="alectryon-token">) </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>σ</var><b>: </b><span>Lean.TSyntax `term</span></span></div></blockquote></div></small></div><span class="nv">σ</span></span><span class="alectryon-token">:term:</span><span class="alectryon-token"><span class="k">max</span></span><span class="alectryon-token"> noWs <span class="s2">&quot;[&quot;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>Lean.TSyntax `term</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token">:term <span class="s2">&quot; ↦ &quot;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>v</var><b>: </b><span>Lean.TSyntax `term</span></span></div></blockquote></div></small></div><span class="nv">v</span></span><span class="alectryon-token">:term <span class="s2">&quot;]&quot;</span> : term <span class="bp">=&gt;</span> <span class="bp">`</span>(HList.set <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>σ</var><b>: </b><span>Lean.TSyntax `term</span></span></div></blockquote></div></small></div><span class="nv">σ</span></span><span class="alectryon-token"> <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>Lean.TSyntax `term</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>v</var><b>: </b><span>Lean.TSyntax `term</span></span></div></blockquote></div></small></div><span class="nv">v</span></span><span class="alectryon-token">)</span><span class="alectryon-token"></span></span></pre>
<h2 id="dynamic-evaluation-function"><a class="header" href="#dynamic-evaluation-function">Dynamic Evaluation Function</a></h2>
<p>A direct encoding of the paper's operational semantics as a denotational function,
generalized over an arbitrary monad.
Note that the immutable context <code>ρ</code> is accumulated (<code>v :: ρ</code>) and passed explicitly instead of immutable
bindings being substituted immediately as that is a better match for the above definition of <code>Stmt</code>.
Iteration over the values of the given list in the <code>for</code> case introduces a nested, mutually recursive helper
function, with termination of the mutual bundle following from a size argument over the statement primarily
and the length of the list in the <code>for</code> case secondarily.</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="bp">@</span>[</span><span class="alectryon-token"><span class="k">simp</span></span><span class="alectryon-token">] </span><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt.eval</var><b>: </b><span>{m : Type → Type u_1} →
  {Γ : List Type} →
    {ω : Type} →
      {Δ : List Type} →
        {b c : Bool} → {α : Type} → [inst : Monad m] → Assg Γ → Stmt m ω Γ Δ b c α → Assg Δ → m (Neut ω α b c × Assg Δ)</span></span></div></blockquote></div></small></div><span class="nv">Stmt.eval</span></span><span class="alectryon-token"> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Monad</var><b>: </b><span>(Type ?u.21808 → Type ?u.21807) → Type (max (?u.21808 + 1) ?u.21807)</span></span></div></blockquote></div></small></div>Monad</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>Type → Type u_1</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token">] (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ρ</var><b>: </b><span>Assg Γ</span></span></div></blockquote></div></small></div><span class="nv">ρ</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Assg</var><b>: </b><span>List Type → Type</span></span></div></blockquote></div></small></div>Assg</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Γ</var><b>: </b><span>List Type</span></span></div></blockquote></div></small></div><span class="nv">Γ</span></span><span class="alectryon-token">) : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt</var><b>: </b><span>(Type → Type u_1) → Type → List Type → List Type → Bool → Bool → Type → Type (max 1 u_1)</span></span></div></blockquote></div></small></div>Stmt</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>Type → Type u_1</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ω</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">ω</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Γ</var><b>: </b><span>List Type</span></span></div></blockquote></div></small></div><span class="nv">Γ</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Δ</var><b>: </b><span>List Type</span></span></div></blockquote></div></small></div><span class="nv">Δ</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>c</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div><span class="nv">c</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Assg</var><b>: </b><span>List Type → Type</span></span></div></blockquote></div></small></div>Assg</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Δ</var><b>: </b><span>List Type</span></span></div></blockquote></div></small></div><span class="nv">Δ</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>Type → Type u_1</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Neut</var><b>: </b><span>Type → Type → Bool → Bool → Type</span></span></div></blockquote></div></small></div>Neut</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ω</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">ω</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>c</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div><span class="nv">c</span></span><span class="alectryon-token"> <span class="bp">×</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Assg</var><b>: </b><span>List Type → Type</span></span></div></blockquote></div></small></div>Assg</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Δ</var><b>: </b><span>List Type</span></span></div></blockquote></div></small></div><span class="nv">Δ</span></span><span class="alectryon-token">)
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>expr</var><b>: </b><span>{m : Type → Type ?u.32858} →
  {ω : Type} → {Γ Δ : List Type} → {α : Type} → {b c : Bool} → (Assg Γ → Assg Δ → m α) → Stmt m ω Γ Δ b c α</span></span></div></blockquote></div></small></div>expr</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>Assg Γ → Assg Δ → m α</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>σ</var><b>: </b><span>Assg Δ</span></span></div></blockquote></div></small></div><span class="nv">σ</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>Assg Γ → Assg Δ → m α</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token">[</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ρ</var><b>: </b><span>Assg Γ</span></span></div></blockquote></div></small></div><span class="nv">ρ</span></span><span class="alectryon-token">][</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>σ</var><b>: </b><span>Assg Δ</span></span></div></blockquote></div></small></div><span class="nv">σ</span></span><span class="alectryon-token">] <span class="bp">&gt;&gt;=</span> </span><span class="alectryon-token"><span class="k">fun</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>v</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">v</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>pure</var><b>: </b><span>{f : Type → Type u_1} → [self : Pure f] → {α : Type} → α → f α</span></span></div></blockquote></div></small></div>pure</span><span class="alectryon-token"> ⟨</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>v</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">v</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>σ</var><b>: </b><span>Assg Δ</span></span></div></blockquote></div></small></div><span class="nv">σ</span></span><span class="alectryon-token">⟩
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>bind</var><b>: </b><span>{m : Type → Type ?u.33084} →
  {ω : Type} →
    {Γ Δ : List Type} →
      {b c : Bool} → {α β : Type} → Stmt m ω Γ Δ b c α → Stmt m ω (α :: Γ) Δ b c β → Stmt m ω Γ Δ b c β</span></span></div></blockquote></div></small></div>bind</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>Stmt m ω Γ Δ b c α✝</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s'</var><b>: </b><span>Stmt m ω (α✝ :: Γ) Δ b c α</span></span></div></blockquote></div></small></div><span class="nv">s&#39;</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>σ</var><b>: </b><span>Assg Δ</span></span></div></blockquote></div></small></div><span class="nv">σ</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span>
    <span class="c1">-- defining this part as a separate definition helps Lean with the termination proof</span>
    </span><span class="alectryon-token"><span class="k">let</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">rec</span></span><span class="alectryon-token"> <span class="bp">@</span>[</span><span class="alectryon-token"><span class="k">simp</span></span><span class="alectryon-token">] </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>cont</var><b>: </b><span>(α✝ → Assg Δ → m (Neut ω α b c × Assg Δ)) → Neut ω α✝ b c × Assg Δ → m (Neut ω α b c × Assg Δ)</span></span></div></blockquote></div></small></div><span class="nv">cont</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>val</var><b>: </b><span>α✝ → Assg Δ → m (Neut ω α b c × Assg Δ)</span></span></div></blockquote></div></small></div><span class="nv">val</span></span><span class="alectryon-token">
      <span class="bp">|</span> ⟨</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Neut.val</var><b>: </b><span>{ω α : Type} → {b c : Bool} → α → Neut ω α b c</span></span></div></blockquote></div></small></div>Neut.val</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>v</var><b>: </b><span>α✝</span></span></div></blockquote></div></small></div><span class="nv">v</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>σ'</var><b>: </b><span>Assg Δ</span></span></div></blockquote></div></small></div><span class="nv">σ&#39;</span></span><span class="alectryon-token">⟩ <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>val</var><b>: </b><span>α✝ → Assg Δ → m (Neut ω α b c × Assg Δ)</span></span></div></blockquote></div></small></div><span class="nv">val</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>v</var><b>: </b><span>α✝</span></span></div></blockquote></div></small></div><span class="nv">v</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>σ'</var><b>: </b><span>Assg Δ</span></span></div></blockquote></div></small></div><span class="nv">σ&#39;</span></span><span class="alectryon-token">
      <span class="c1">-- the `Neut` type family forces us to repeat these cases as the LHS/RHS indices are not identical</span>
      <span class="bp">|</span> ⟨</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Neut.ret</var><b>: </b><span>{ω α : Type} → {b c : Bool} → ω → Neut ω α b c</span></span></div></blockquote></div></small></div>Neut.ret</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>o</var><b>: </b><span>ω</span></span></div></blockquote></div></small></div><span class="nv">o</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>σ'</var><b>: </b><span>Assg Δ</span></span></div></blockquote></div></small></div><span class="nv">σ&#39;</span></span><span class="alectryon-token">⟩ <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>pure</var><b>: </b><span>{f : Type → Type u_1} → [self : Pure f] → {α : Type} → α → f α</span></span></div></blockquote></div></small></div>pure</span><span class="alectryon-token"> ⟨</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Neut.ret</var><b>: </b><span>{ω α : Type} → {b c : Bool} → ω → Neut ω α b c</span></span></div></blockquote></div></small></div>Neut.ret</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>o</var><b>: </b><span>ω</span></span></div></blockquote></div></small></div><span class="nv">o</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>σ'</var><b>: </b><span>Assg Δ</span></span></div></blockquote></div></small></div><span class="nv">σ&#39;</span></span><span class="alectryon-token">⟩
      <span class="bp">|</span> ⟨</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Neut.rbreak</var><b>: </b><span>{ω α : Type} → {c : Bool} → Neut ω α true c</span></span></div></blockquote></div></small></div>Neut.rbreak</span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>σ'</var><b>: </b><span>Assg Δ</span></span></div></blockquote></div></small></div><span class="nv">σ&#39;</span></span><span class="alectryon-token">⟩ <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>pure</var><b>: </b><span>{f : Type → Type u_1} → [self : Pure f] → {α : Type} → α → f α</span></span></div></blockquote></div></small></div>pure</span><span class="alectryon-token"> ⟨</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Neut.rbreak</var><b>: </b><span>{ω α : Type} → {c : Bool} → Neut ω α true c</span></span></div></blockquote></div></small></div>Neut.rbreak</span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>σ'</var><b>: </b><span>Assg Δ</span></span></div></blockquote></div></small></div><span class="nv">σ&#39;</span></span><span class="alectryon-token">⟩
      <span class="bp">|</span> ⟨</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Neut.rcont</var><b>: </b><span>{ω α : Type} → {b : Bool} → Neut ω α b true</span></span></div></blockquote></div></small></div>Neut.rcont</span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>σ'</var><b>: </b><span>Assg Δ</span></span></div></blockquote></div></small></div><span class="nv">σ&#39;</span></span><span class="alectryon-token">⟩ <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>pure</var><b>: </b><span>{f : Type → Type u_1} → [self : Pure f] → {α : Type} → α → f α</span></span></div></blockquote></div></small></div>pure</span><span class="alectryon-token"> ⟨</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Neut.rcont</var><b>: </b><span>{ω α : Type} → {b : Bool} → Neut ω α b true</span></span></div></blockquote></div></small></div>Neut.rcont</span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>σ'</var><b>: </b><span>Assg Δ</span></span></div></blockquote></div></small></div><span class="nv">σ&#39;</span></span><span class="alectryon-token">⟩
    </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>Stmt m ω Γ Δ b c α✝</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>eval</var><b>: </b><span>{m : Type → Type u_1} →
  {Γ : List Type} →
    {ω : Type} →
      {Δ : List Type} →
        {b c : Bool} → {α : Type} → [inst : Monad m] → Assg Γ → Stmt m ω Γ Δ b c α → Assg Δ → m (Neut ω α b c × Assg Δ)</span></span></div></blockquote></div></small></div><span class="nv">eval</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ρ</var><b>: </b><span>Assg Γ</span></span></div></blockquote></div></small></div><span class="nv">ρ</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>σ</var><b>: </b><span>Assg Δ</span></span></div></blockquote></div></small></div><span class="nv">σ</span></span><span class="alectryon-token"> <span class="bp">&gt;&gt;=</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>cont</var><b>: </b><span>(α✝ → Assg Δ → m (Neut ω α b c × Assg Δ)) → Neut ω α✝ b c × Assg Δ → m (Neut ω α b c × Assg Δ)</span></span></div></blockquote></div></small></div><span class="nv">cont</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><span class="k">fun</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>v</var><b>: </b><span>α✝</span></span></div></blockquote></div></small></div><span class="nv">v</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>σ'</var><b>: </b><span>Assg Δ</span></span></div></blockquote></div></small></div><span class="nv">σ&#39;</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s'</var><b>: </b><span>Stmt m ω (α✝ :: Γ) Δ b c α</span></span></div></blockquote></div></small></div><span class="nv">s&#39;</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>eval</var><b>: </b><span>{m : Type → Type u_1} →
  {Γ : List Type} →
    {ω : Type} →
      {Δ : List Type} →
        {b c : Bool} → {α : Type} → [inst : Monad m] → Assg Γ → Stmt m ω Γ Δ b c α → Assg Δ → m (Neut ω α b c × Assg Δ)</span></span></div></blockquote></div></small></div><span class="nv">eval</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>v</var><b>: </b><span>α✝</span></span></div></blockquote></div></small></div><span class="nv">v</span></span><span class="alectryon-token"> :: </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ρ</var><b>: </b><span>Assg Γ</span></span></div></blockquote></div></small></div><span class="nv">ρ</span></span><span class="alectryon-token">) </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>σ'</var><b>: </b><span>Assg Δ</span></span></div></blockquote></div></small></div><span class="nv">σ&#39;</span></span><span class="alectryon-token">)
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>letmut</var><b>: </b><span>{m : Type → Type ?u.33463} →
  {ω : Type} →
    {Γ Δ : List Type} →
      {α : Type} → {b c : Bool} → {β : Type} → (Assg Γ → Assg Δ → α) → Stmt m ω Γ (α :: Δ) b c β → Stmt m ω Γ Δ b c β</span></span></div></blockquote></div></small></div>letmut</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>Assg Γ → Assg Δ → α✝</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>Stmt m ω Γ (α✝ :: Δ) b c α</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>σ</var><b>: </b><span>Assg Δ</span></span></div></blockquote></div></small></div><span class="nv">σ</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span>
    </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>Stmt m ω Γ (α✝ :: Δ) b c α</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>eval</var><b>: </b><span>{m : Type → Type u_1} →
  {Γ : List Type} →
    {ω : Type} →
      {Δ : List Type} →
        {b c : Bool} → {α : Type} → [inst : Monad m] → Assg Γ → Stmt m ω Γ Δ b c α → Assg Δ → m (Neut ω α b c × Assg Δ)</span></span></div></blockquote></div></small></div><span class="nv">eval</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ρ</var><b>: </b><span>Assg Γ</span></span></div></blockquote></div></small></div><span class="nv">ρ</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>Assg Γ → Assg Δ → α✝</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token">[</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ρ</var><b>: </b><span>Assg Γ</span></span></div></blockquote></div></small></div><span class="nv">ρ</span></span><span class="alectryon-token">][</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>σ</var><b>: </b><span>Assg Δ</span></span></div></blockquote></div></small></div><span class="nv">σ</span></span><span class="alectryon-token">], </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>σ</var><b>: </b><span>Assg Δ</span></span></div></blockquote></div></small></div><span class="nv">σ</span></span><span class="alectryon-token">) <span class="bp">&gt;&gt;=</span> </span><span class="alectryon-token"><span class="k">fun</span></span><span class="alectryon-token"> ⟨</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>r</var><b>: </b><span>Neut ω α b c</span></span></div></blockquote></div></small></div><span class="nv">r</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>σ'</var><b>: </b><span>Assg (α✝ :: Δ)</span></span></div></blockquote></div></small></div><span class="nv">σ&#39;</span></span><span class="alectryon-token">⟩ <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>pure</var><b>: </b><span>{f : Type → Type u_1} → [self : Pure f] → {α : Type} → α → f α</span></span></div></blockquote></div></small></div>pure</span><span class="alectryon-token"> ⟨</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>r</var><b>: </b><span>Neut ω α b c</span></span></div></blockquote></div></small></div><span class="nv">r</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>σ'</var><b>: </b><span>Assg (α✝ :: Δ)</span></span></div></blockquote></div></small></div><span class="nv">σ&#39;</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>drop</var><b>: </b><span>{α : Type} → {Γ : List Type} → Assg (α :: Γ) → Assg Γ</span></span></div></blockquote></div></small></div>drop</span><span class="alectryon-token">⟩
  <span class="c1">-- `x` is a valid de Bruijn index into `σ` by definition of `assg`</span>
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>assg</var><b>: </b><span>{m : Type → Type ?u.35837} →
  {ω : Type} →
    {Γ Δ : List Type} →
      {b c : Bool} → (x : Fin (List.length Δ)) → (Assg Γ → Assg Δ → List.get Δ x) → Stmt m ω Γ Δ b c Unit</span></span></div></blockquote></div></small></div>assg</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>Fin (List.length Δ)</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>Assg Γ → Assg Δ → List.get Δ x</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>σ</var><b>: </b><span>Assg Δ</span></span></div></blockquote></div></small></div><span class="nv">σ</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>pure</var><b>: </b><span>{f : Type → Type u_1} → [self : Pure f] → {α : Type} → α → f α</span></span></div></blockquote></div></small></div>pure</span><span class="alectryon-token"> ⟨</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>()</var><b>: </b><span>Unit</span></span></div></blockquote></div></small></div>()</span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>σ</var><b>: </b><span>Assg Δ</span></span></div></blockquote></div></small></div><span class="nv">σ</span></span><span class="alectryon-token">[</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>Fin (List.length Δ)</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> <span class="bp">↦</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>Assg Γ → Assg Δ → List.get Δ x</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token">[</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ρ</var><b>: </b><span>Assg Γ</span></span></div></blockquote></div></small></div><span class="nv">ρ</span></span><span class="alectryon-token">][</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>σ</var><b>: </b><span>Assg Δ</span></span></div></blockquote></div></small></div><span class="nv">σ</span></span><span class="alectryon-token">]]⟩
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ite</var><b>: </b><span>{m : Type → Type ?u.36112} →
  {ω : Type} →
    {Γ Δ : List Type} →
      {b c : Bool} →
        {α : Type} → (Assg Γ → Assg Δ → Bool) → Stmt m ω Γ Δ b c α → Stmt m ω Γ Δ b c α → Stmt m ω Γ Δ b c α</span></span></div></blockquote></div></small></div>ite</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>Assg Γ → Assg Δ → Bool</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s₁</var><b>: </b><span>Stmt m ω Γ Δ b c α</span></span></div></blockquote></div></small></div><span class="nv">s₁</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s₂</var><b>: </b><span>Stmt m ω Γ Δ b c α</span></span></div></blockquote></div></small></div><span class="nv">s₂</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>σ</var><b>: </b><span>Assg Δ</span></span></div></blockquote></div></small></div><span class="nv">σ</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><span class="k">if</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>Assg Γ → Assg Δ → Bool</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token">[</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ρ</var><b>: </b><span>Assg Γ</span></span></div></blockquote></div></small></div><span class="nv">ρ</span></span><span class="alectryon-token">][</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>σ</var><b>: </b><span>Assg Δ</span></span></div></blockquote></div></small></div><span class="nv">σ</span></span><span class="alectryon-token">] </span><span class="alectryon-token"><span class="k">then</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s₁</var><b>: </b><span>Stmt m ω Γ Δ b c α</span></span></div></blockquote></div></small></div><span class="nv">s₁</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>eval</var><b>: </b><span>{m : Type → Type u_1} →
  {Γ : List Type} →
    {ω : Type} →
      {Δ : List Type} →
        {b c : Bool} → {α : Type} → [inst : Monad m] → Assg Γ → Stmt m ω Γ Δ b c α → Assg Δ → m (Neut ω α b c × Assg Δ)</span></span></div></blockquote></div></small></div><span class="nv">eval</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ρ</var><b>: </b><span>Assg Γ</span></span></div></blockquote></div></small></div><span class="nv">ρ</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>σ</var><b>: </b><span>Assg Δ</span></span></div></blockquote></div></small></div><span class="nv">σ</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">else</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s₂</var><b>: </b><span>Stmt m ω Γ Δ b c α</span></span></div></blockquote></div></small></div><span class="nv">s₂</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>eval</var><b>: </b><span>{m : Type → Type u_1} →
  {Γ : List Type} →
    {ω : Type} →
      {Δ : List Type} →
        {b c : Bool} → {α : Type} → [inst : Monad m] → Assg Γ → Stmt m ω Γ Δ b c α → Assg Δ → m (Neut ω α b c × Assg Δ)</span></span></div></blockquote></div></small></div><span class="nv">eval</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ρ</var><b>: </b><span>Assg Γ</span></span></div></blockquote></div></small></div><span class="nv">ρ</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>σ</var><b>: </b><span>Assg Δ</span></span></div></blockquote></div></small></div><span class="nv">σ</span></span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ret</var><b>: </b><span>{m : Type → Type ?u.36353} →
  {ω : Type} → {Γ Δ : List Type} → {b c : Bool} → {α : Type} → (Assg Γ → Assg Δ → ω) → Stmt m ω Γ Δ b c α</span></span></div></blockquote></div></small></div>ret</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>Assg Γ → Assg Δ → ω</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>σ</var><b>: </b><span>Assg Δ</span></span></div></blockquote></div></small></div><span class="nv">σ</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>pure</var><b>: </b><span>{f : Type → Type u_1} → [self : Pure f] → {α : Type} → α → f α</span></span></div></blockquote></div></small></div>pure</span><span class="alectryon-token"> ⟨</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Neut.ret</var><b>: </b><span>{ω α : Type} → {b c : Bool} → ω → Neut ω α b c</span></span></div></blockquote></div></small></div>Neut.ret</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>Assg Γ → Assg Δ → ω</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token">[</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ρ</var><b>: </b><span>Assg Γ</span></span></div></blockquote></div></small></div><span class="nv">ρ</span></span><span class="alectryon-token">][</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>σ</var><b>: </b><span>Assg Δ</span></span></div></blockquote></div></small></div><span class="nv">σ</span></span><span class="alectryon-token">], </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>σ</var><b>: </b><span>Assg Δ</span></span></div></blockquote></div></small></div><span class="nv">σ</span></span><span class="alectryon-token">⟩
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>sfor</var><b>: </b><span>{m : Type → Type ?u.36472} →
  {ω : Type} →
    {Γ Δ : List Type} →
      {α : Type} →
        {b c : Bool} → (Assg Γ → Assg Δ → List α) → Stmt m ω (α :: Γ) Δ true true Unit → Stmt m ω Γ Δ b c Unit</span></span></div></blockquote></div></small></div>sfor</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>Assg Γ → Assg Δ → List α✝</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>Stmt m ω (α✝ :: Γ) Δ true true Unit</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>σ</var><b>: </b><span>Assg Δ</span></span></div></blockquote></div></small></div><span class="nv">σ</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span>
    </span><span class="alectryon-token"><span class="k">let</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">rec</span></span><span class="alectryon-token"> <span class="bp">@</span>[</span><span class="alectryon-token"><span class="k">simp</span></span><span class="alectryon-token">] </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>go</var><b>: </b><span>Assg Δ → List α✝ → m (Neut ω Unit b c × Assg Δ)</span></span></div></blockquote></div></small></div><span class="nv">go</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>σ</var><b>: </b><span>Assg Δ</span></span></div></blockquote></div></small></div><span class="nv">σ</span></span><span class="alectryon-token">
      <span class="bp">|</span> [] <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>pure</var><b>: </b><span>{f : Type → Type u_1} → [self : Pure f] → {α : Type} → α → f α</span></span></div></blockquote></div></small></div>pure</span><span class="alectryon-token"> ⟨</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>()</var><b>: </b><span>Unit</span></span></div></blockquote></div></small></div>()</span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>σ</var><b>: </b><span>Assg Δ</span></span></div></blockquote></div></small></div><span class="nv">σ</span></span><span class="alectryon-token">⟩
      <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>α✝</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token">::</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>as</var><b>: </b><span>List α✝</span></span></div></blockquote></div></small></div><span class="nv">as</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span>
        </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>Stmt m ω (α✝ :: Γ) Δ true true Unit</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>eval</var><b>: </b><span>{m : Type → Type u_1} →
  {Γ : List Type} →
    {ω : Type} →
      {Δ : List Type} →
        {b c : Bool} → {α : Type} → [inst : Monad m] → Assg Γ → Stmt m ω Γ Δ b c α → Assg Δ → m (Neut ω α b c × Assg Δ)</span></span></div></blockquote></div></small></div><span class="nv">eval</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>α✝</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"> :: </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ρ</var><b>: </b><span>Assg Γ</span></span></div></blockquote></div></small></div><span class="nv">ρ</span></span><span class="alectryon-token">) </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>σ</var><b>: </b><span>Assg Δ</span></span></div></blockquote></div></small></div><span class="nv">σ</span></span><span class="alectryon-token"> <span class="bp">&gt;&gt;=</span> </span><span class="alectryon-token"><span class="k">fun</span></span><span class="alectryon-token">
        <span class="bp">|</span> ⟨(), </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>σ'</var><b>: </b><span>Assg Δ</span></span></div></blockquote></div></small></div><span class="nv">σ&#39;</span></span><span class="alectryon-token">⟩ <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>go</var><b>: </b><span>Assg Δ → List α✝ → m (Neut ω Unit b c × Assg Δ)</span></span></div></blockquote></div></small></div><span class="nv">go</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>σ'</var><b>: </b><span>Assg Δ</span></span></div></blockquote></div></small></div><span class="nv">σ&#39;</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>as</var><b>: </b><span>List α✝</span></span></div></blockquote></div></small></div><span class="nv">as</span></span><span class="alectryon-token">
        <span class="bp">|</span> ⟨</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Neut.rcont</var><b>: </b><span>{ω α : Type} → {b : Bool} → Neut ω α b true</span></span></div></blockquote></div></small></div>Neut.rcont</span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>σ'</var><b>: </b><span>Assg Δ</span></span></div></blockquote></div></small></div><span class="nv">σ&#39;</span></span><span class="alectryon-token">⟩ <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>go</var><b>: </b><span>Assg Δ → List α✝ → m (Neut ω Unit b c × Assg Δ)</span></span></div></blockquote></div></small></div><span class="nv">go</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>σ'</var><b>: </b><span>Assg Δ</span></span></div></blockquote></div></small></div><span class="nv">σ&#39;</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>as</var><b>: </b><span>List α✝</span></span></div></blockquote></div></small></div><span class="nv">as</span></span><span class="alectryon-token">
        <span class="bp">|</span> ⟨</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Neut.rbreak</var><b>: </b><span>{ω α : Type} → {c : Bool} → Neut ω α true c</span></span></div></blockquote></div></small></div>Neut.rbreak</span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>σ'</var><b>: </b><span>Assg Δ</span></span></div></blockquote></div></small></div><span class="nv">σ&#39;</span></span><span class="alectryon-token">⟩ <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>pure</var><b>: </b><span>{f : Type → Type u_1} → [self : Pure f] → {α : Type} → α → f α</span></span></div></blockquote></div></small></div>pure</span><span class="alectryon-token"> ⟨</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>()</var><b>: </b><span>Unit</span></span></div></blockquote></div></small></div>()</span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>σ'</var><b>: </b><span>Assg Δ</span></span></div></blockquote></div></small></div><span class="nv">σ&#39;</span></span><span class="alectryon-token">⟩
        <span class="bp">|</span> ⟨</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Neut.ret</var><b>: </b><span>{ω α : Type} → {b c : Bool} → ω → Neut ω α b c</span></span></div></blockquote></div></small></div>Neut.ret</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>o</var><b>: </b><span>ω</span></span></div></blockquote></div></small></div><span class="nv">o</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>σ'</var><b>: </b><span>Assg Δ</span></span></div></blockquote></div></small></div><span class="nv">σ&#39;</span></span><span class="alectryon-token">⟩ <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>pure</var><b>: </b><span>{f : Type → Type u_1} → [self : Pure f] → {α : Type} → α → f α</span></span></div></blockquote></div></small></div>pure</span><span class="alectryon-token"> ⟨</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Neut.ret</var><b>: </b><span>{ω α : Type} → {b c : Bool} → ω → Neut ω α b c</span></span></div></blockquote></div></small></div>Neut.ret</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>o</var><b>: </b><span>ω</span></span></div></blockquote></div></small></div><span class="nv">o</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>σ'</var><b>: </b><span>Assg Δ</span></span></div></blockquote></div></small></div><span class="nv">σ&#39;</span></span><span class="alectryon-token">⟩
    </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>go</var><b>: </b><span>Assg Δ → List α✝ → m (Neut ω Unit b c × Assg Δ)</span></span></div></blockquote></div></small></div><span class="nv">go</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>σ</var><b>: </b><span>Assg Δ</span></span></div></blockquote></div></small></div><span class="nv">σ</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>Assg Γ → Assg Δ → List α✝</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token">[</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ρ</var><b>: </b><span>Assg Γ</span></span></div></blockquote></div></small></div><span class="nv">ρ</span></span><span class="alectryon-token">][</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>σ</var><b>: </b><span>Assg Δ</span></span></div></blockquote></div></small></div><span class="nv">σ</span></span><span class="alectryon-token">]
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>sbreak</var><b>: </b><span>{m : Type → Type ?u.36610} → {ω : Type} → {Γ Δ : List Type} → {c : Bool} → {α : Type} → Stmt m ω Γ Δ true c α</span></span></div></blockquote></div></small></div>sbreak</span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>σ</var><b>: </b><span>Assg Δ</span></span></div></blockquote></div></small></div><span class="nv">σ</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>pure</var><b>: </b><span>{f : Type → Type u_1} → [self : Pure f] → {α : Type} → α → f α</span></span></div></blockquote></div></small></div>pure</span><span class="alectryon-token"> ⟨</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Neut.rbreak</var><b>: </b><span>{ω α : Type} → {c : Bool} → Neut ω α true c</span></span></div></blockquote></div></small></div>Neut.rbreak</span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>σ</var><b>: </b><span>Assg Δ</span></span></div></blockquote></div></small></div><span class="nv">σ</span></span><span class="alectryon-token">⟩
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>scont</var><b>: </b><span>{m : Type → Type ?u.36721} → {ω : Type} → {Γ Δ : List Type} → {b : Bool} → {α : Type} → Stmt m ω Γ Δ b true α</span></span></div></blockquote></div></small></div>scont</span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>σ</var><b>: </b><span>Assg Δ</span></span></div></blockquote></div></small></div><span class="nv">σ</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>pure</var><b>: </b><span>{f : Type → Type u_1} → [self : Pure f] → {α : Type} → α → f α</span></span></div></blockquote></div></small></div>pure</span><span class="alectryon-token"> ⟨</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Neut.rcont</var><b>: </b><span>{ω α : Type} → {b : Bool} → Neut ω α b true</span></span></div></blockquote></div></small></div>Neut.rcont</span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>σ</var><b>: </b><span>Assg Δ</span></span></div></blockquote></div></small></div><span class="nv">σ</span></span><span class="alectryon-token">⟩
</span><span class="alectryon-token"><span class="k">termination_by</span></span><span class="alectryon-token">
  eval s _ <span class="bp">=&gt;</span> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>sizeOf</var><b>: </b><span>{α : Type (max 1 u_1)} → [self : SizeOf α] → α → Nat</span></span></div></blockquote></div></small></div>sizeOf</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>Stmt m ω Γ Δ b c α</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>0</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">0</span></span><span class="alectryon-token">)
  eval.go as <span class="bp">=&gt;</span> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>sizeOf</var><b>: </b><span>{α : Type (max 1 u_1)} → [self : SizeOf α] → α → Nat</span></span></div></blockquote></div></small></div>sizeOf</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>Stmt m ω (α✝ :: Γ) Δ true true Unit</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>as</var><b>: </b><span>List α✝</span></span></div></blockquote></div></small></div><span class="nv">as</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>length</var><b>: </b><span>{α : Type} → List α → Nat</span></span></div></blockquote></div></small></div>length</span><span class="alectryon-token">)</span></span></pre>
<p>At the top-level statement, the contexts are empty, no loop control flow statements are allowed, and the return and result type are identical.</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="k">abbrev</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Do</var><b>: </b><span>(Type → Type u_1) → Type → Type (max 1 u_1)</span></span></div></blockquote></div></small></div><span class="nv">Do</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>Type → Type u_1</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token"> := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt</var><b>: </b><span>(Type → Type u_1) → Type → List Type → List Type → Bool → Bool → Type → Type (max 1 u_1)</span></span></div></blockquote></div></small></div>Stmt</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>Type → Type u_1</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>∅</var><b>: </b><span>List Type</span></span></div></blockquote></div></small></div><span class="bp">∅</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>∅</var><b>: </b><span>List Type</span></span></div></blockquote></div></small></div><span class="bp">∅</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>false</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div>false</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>false</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div>false</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token">

</span><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Do.eval</var><b>: </b><span>{m : Type → Type u_1} → {α : Type} → [inst : Monad m] → Do m α → m α</span></span></div></blockquote></div></small></div><span class="nv">Do.eval</span></span><span class="alectryon-token"> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Monad</var><b>: </b><span>(Type → Type u_1) → Type (max 1 u_1)</span></span></div></blockquote></div></small></div>Monad</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>Type → Type u_1</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token">] (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>Do m α</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Do</var><b>: </b><span>(Type → Type u_1) → Type → Type (max 1 u_1)</span></span></div></blockquote></div></small></div>Do</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>Type → Type u_1</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token">) : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>Type → Type u_1</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token"> :=  <span class="c1">-- corresponds to the reduction rule `do s ⇒ v` in the paper</span>
  </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt.eval</var><b>: </b><span>{m : Type → Type u_1} →
  {Γ : List Type} →
    {ω : Type} →
      {Δ : List Type} →
        {b c : Bool} → {α : Type} → [inst : Monad m] → Assg Γ → Stmt m ω Γ Δ b c α → Assg Δ → m (Neut ω α b c × Assg Δ)</span></span></div></blockquote></div></small></div>Stmt.eval</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>∅</var><b>: </b><span>Assg ∅</span></span></div></blockquote></div></small></div><span class="bp">∅</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>Do m α</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>∅</var><b>: </b><span>Assg ∅</span></span></div></blockquote></div></small></div><span class="bp">∅</span></span><span class="alectryon-token"> <span class="bp">&gt;&gt;=</span> </span><span class="alectryon-token"><span class="k">fun</span></span><span class="alectryon-token">
    <span class="bp">|</span> ⟨</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Neut.val</var><b>: </b><span>{ω α : Type} → {b c : Bool} → α → Neut ω α b c</span></span></div></blockquote></div></small></div>Neut.val</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token">, _⟩ <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>pure</var><b>: </b><span>{f : Type → Type u_1} → [self : Pure f] → {α : Type} → α → f α</span></span></div></blockquote></div></small></div>pure</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token">
    <span class="bp">|</span> ⟨</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Neut.ret</var><b>: </b><span>{ω α : Type} → {b c : Bool} → ω → Neut ω α b c</span></span></div></blockquote></div></small></div>Neut.ret</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>o</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">o</span></span><span class="alectryon-token">, _⟩ <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>pure</var><b>: </b><span>{f : Type → Type u_1} → [self : Pure f] → {α : Type} → α → f α</span></span></div></blockquote></div></small></div>pure</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>o</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">o</span></span><span class="alectryon-token">

</span><span class="alectryon-token"><span class="kd">notation</span></span><span class="alectryon-token"> <span class="s2">&quot;⟦&quot;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>Lean.TSyntax `term</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token"> <span class="s2">&quot;⟧&quot;</span> <span class="bp">=&gt;</span> Do.eval </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>Lean.TSyntax `term</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token"></span></span></pre>
<h2 id="translation-functions"><a class="header" href="#translation-functions">Translation Functions</a></h2>
<p>We adjust the immutable context where necessary.
The mutable context does not have to be adjusted.</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="bp">@</span>[</span><span class="alectryon-token"><span class="k">simp</span></span><span class="alectryon-token">] </span><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt.mapAssg</var><b>: </b><span>(_x :
    (Γ' : List Type) ×'
      (Γ : List Type) ×'
        (m : Type → Type u_1) ×'
          (ω : Type) ×'
            (Δ : List Type) ×' (b : Bool) ×' (c : Bool) ×' (β : Type) ×' (_ : Assg Γ' → Assg Γ) ×' Stmt m ω Γ Δ b c β) →
  Stmt _x.2.2.1 _x.2.2.2.1 _x.1 _x.2.2.2.2.1 _x.2.2.2.2.2.1 _x.2.2.2.2.2.2.1 _x.2.2.2.2.2.2.2.1</span></span></div></blockquote></div></small></div><span class="nv">Stmt.mapAssg</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>Assg Γ' → Assg Γ</span></span></div></blockquote></div></small></div><span class="nv">f</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Assg</var><b>: </b><span>List Type → Type</span></span></div></blockquote></div></small></div>Assg</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Γ'</var><b>: </b><span>List Type</span></span></div></blockquote></div></small></div><span class="nv">Γ&#39;</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Assg</var><b>: </b><span>List (Type ?u.111841) → Type ?u.111841</span></span></div></blockquote></div></small></div>Assg</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Γ</var><b>: </b><span>List Type</span></span></div></blockquote></div></small></div><span class="nv">Γ</span></span><span class="alectryon-token">) : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt</var><b>: </b><span>(Type → Type u_1) → Type → List Type → List Type → Bool → Bool → Type → Type (max 1 u_1)</span></span></div></blockquote></div></small></div>Stmt</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>Type → Type u_1</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ω</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">ω</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Γ</var><b>: </b><span>List Type</span></span></div></blockquote></div></small></div><span class="nv">Γ</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Δ</var><b>: </b><span>List Type</span></span></div></blockquote></div></small></div><span class="nv">Δ</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>c</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div><span class="nv">c</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>β</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">β</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt</var><b>: </b><span>(Type → Type u_1) → Type → List Type → List Type → Bool → Bool → Type → Type (max 1 u_1)</span></span></div></blockquote></div></small></div>Stmt</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>Type → Type u_1</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ω</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">ω</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Γ'</var><b>: </b><span>List Type</span></span></div></blockquote></div></small></div><span class="nv">Γ&#39;</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Δ</var><b>: </b><span>List Type</span></span></div></blockquote></div></small></div><span class="nv">Δ</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>c</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div><span class="nv">c</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>β</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">β</span></span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>expr</var><b>: </b><span>{m : Type → Type ?u.116778} →
  {ω : Type} → {Γ Δ : List Type} → {α : Type} → {b c : Bool} → (Assg Γ → Assg Δ → m α) → Stmt m ω Γ Δ b c α</span></span></div></blockquote></div></small></div>expr</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>Assg Γ → Assg Δ → m β</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>expr</var><b>: </b><span>{m : Type → Type u_1} →
  {ω : Type} → {Γ Δ : List Type} → {α : Type} → {b c : Bool} → (Assg Γ → Assg Δ → m α) → Stmt m ω Γ Δ b c α</span></span></div></blockquote></div></small></div>expr</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>Assg Γ → Assg Δ → m β</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token"> <span class="bp">∘</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>Assg Γ' → Assg Γ</span></span></div></blockquote></div></small></div><span class="nv">f</span></span><span class="alectryon-token">)
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>bind</var><b>: </b><span>{m : Type → Type ?u.116872} →
  {ω : Type} →
    {Γ Δ : List Type} →
      {b c : Bool} → {α β : Type} → Stmt m ω Γ Δ b c α → Stmt m ω (α :: Γ) Δ b c β → Stmt m ω Γ Δ b c β</span></span></div></blockquote></div></small></div>bind</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s₁</var><b>: </b><span>Stmt m ω Γ Δ b c α✝</span></span></div></blockquote></div></small></div><span class="nv">s₁</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s₂</var><b>: </b><span>Stmt m ω (α✝ :: Γ) Δ b c β</span></span></div></blockquote></div></small></div><span class="nv">s₂</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>bind</var><b>: </b><span>{m : Type → Type u_1} →
  {ω : Type} →
    {Γ Δ : List Type} →
      {b c : Bool} → {α β : Type} → Stmt m ω Γ Δ b c α → Stmt m ω (α :: Γ) Δ b c β → Stmt m ω Γ Δ b c β</span></span></div></blockquote></div></small></div>bind</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s₁</var><b>: </b><span>Stmt m ω Γ Δ b c α✝</span></span></div></blockquote></div></small></div><span class="nv">s₁</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>mapAssg</var><b>: </b><span>{Γ' Γ : List Type} →
  {m : Type → Type u_1} →
    {ω : Type} →
      {Δ : List Type} → {b c : Bool} → {β : Type} → (Assg Γ' → Assg Γ) → Stmt m ω Γ Δ b c β → Stmt m ω Γ' Δ b c β</span></span></div></blockquote></div></small></div><span class="nv">mapAssg</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>Assg Γ' → Assg Γ</span></span></div></blockquote></div></small></div><span class="nv">f</span></span><span class="alectryon-token">) (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s₂</var><b>: </b><span>Stmt m ω (α✝ :: Γ) Δ b c β</span></span></div></blockquote></div></small></div><span class="nv">s₂</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>mapAssg</var><b>: </b><span>{Γ' Γ : List Type} →
  {m : Type → Type u_1} →
    {ω : Type} →
      {Δ : List Type} → {b c : Bool} → {β : Type} → (Assg Γ' → Assg Γ) → Stmt m ω Γ Δ b c β → Stmt m ω Γ' Δ b c β</span></span></div></blockquote></div></small></div><span class="nv">mapAssg</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><span class="k">fun</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>α✝</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"> :: </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>as</var><b>: </b><span>HList Γ'</span></span></div></blockquote></div></small></div><span class="nv">as</span></span><span class="alectryon-token">) <span class="bp">=&gt;</span> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>α✝</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"> :: </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>Assg Γ' → Assg Γ</span></span></div></blockquote></div></small></div><span class="nv">f</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>as</var><b>: </b><span>HList Γ'</span></span></div></blockquote></div></small></div><span class="nv">as</span></span><span class="alectryon-token">)))
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>letmut</var><b>: </b><span>{m : Type → Type ?u.117466} →
  {ω : Type} →
    {Γ Δ : List Type} →
      {α : Type} → {b c : Bool} → {β : Type} → (Assg Γ → Assg Δ → α) → Stmt m ω Γ (α :: Δ) b c β → Stmt m ω Γ Δ b c β</span></span></div></blockquote></div></small></div>letmut</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>Assg Γ → Assg Δ → α✝</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>Stmt m ω Γ (α✝ :: Δ) b c β</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>letmut</var><b>: </b><span>{m : Type → Type u_1} →
  {ω : Type} →
    {Γ Δ : List Type} →
      {α : Type} → {b c : Bool} → {β : Type} → (Assg Γ → Assg Δ → α) → Stmt m ω Γ (α :: Δ) b c β → Stmt m ω Γ Δ b c β</span></span></div></blockquote></div></small></div>letmut</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>Assg Γ → Assg Δ → α✝</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token"> <span class="bp">∘</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>Assg Γ' → Assg Γ</span></span></div></blockquote></div></small></div><span class="nv">f</span></span><span class="alectryon-token">) (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>Stmt m ω Γ (α✝ :: Δ) b c β</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>mapAssg</var><b>: </b><span>{Γ' Γ : List Type} →
  {m : Type → Type u_1} →
    {ω : Type} →
      {Δ : List Type} → {b c : Bool} → {β : Type} → (Assg Γ' → Assg Γ) → Stmt m ω Γ Δ b c β → Stmt m ω Γ' Δ b c β</span></span></div></blockquote></div></small></div><span class="nv">mapAssg</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>Assg Γ' → Assg Γ</span></span></div></blockquote></div></small></div><span class="nv">f</span></span><span class="alectryon-token">)
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>assg</var><b>: </b><span>{m : Type → Type ?u.117619} →
  {ω : Type} →
    {Γ Δ : List Type} →
      {b c : Bool} → (x : Fin (List.length Δ)) → (Assg Γ → Assg Δ → List.get Δ x) → Stmt m ω Γ Δ b c Unit</span></span></div></blockquote></div></small></div>assg</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>Fin (List.length Δ)</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>Assg Γ → Assg Δ → List.get Δ x</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>assg</var><b>: </b><span>{m : Type → Type u_1} →
  {ω : Type} →
    {Γ Δ : List Type} →
      {b c : Bool} → (x : Fin (List.length Δ)) → (Assg Γ → Assg Δ → List.get Δ x) → Stmt m ω Γ Δ b c Unit</span></span></div></blockquote></div></small></div>assg</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>Fin (List.length Δ)</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>Assg Γ → Assg Δ → List.get Δ x</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token"> <span class="bp">∘</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>Assg Γ' → Assg Γ</span></span></div></blockquote></div></small></div><span class="nv">f</span></span><span class="alectryon-token">)
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ite</var><b>: </b><span>{m : Type → Type ?u.117739} →
  {ω : Type} →
    {Γ Δ : List Type} →
      {b c : Bool} →
        {α : Type} → (Assg Γ → Assg Δ → Bool) → Stmt m ω Γ Δ b c α → Stmt m ω Γ Δ b c α → Stmt m ω Γ Δ b c α</span></span></div></blockquote></div></small></div>ite</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>Assg Γ → Assg Δ → Bool</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s₁</var><b>: </b><span>Stmt m ω Γ Δ b c β</span></span></div></blockquote></div></small></div><span class="nv">s₁</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s₂</var><b>: </b><span>Stmt m ω Γ Δ b c β</span></span></div></blockquote></div></small></div><span class="nv">s₂</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ite</var><b>: </b><span>{m : Type → Type u_1} →
  {ω : Type} →
    {Γ Δ : List Type} →
      {b c : Bool} →
        {α : Type} → (Assg Γ → Assg Δ → Bool) → Stmt m ω Γ Δ b c α → Stmt m ω Γ Δ b c α → Stmt m ω Γ Δ b c α</span></span></div></blockquote></div></small></div>ite</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>Assg Γ → Assg Δ → Bool</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token"> <span class="bp">∘</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>Assg Γ' → Assg Γ</span></span></div></blockquote></div></small></div><span class="nv">f</span></span><span class="alectryon-token">) (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s₁</var><b>: </b><span>Stmt m ω Γ Δ b c β</span></span></div></blockquote></div></small></div><span class="nv">s₁</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>mapAssg</var><b>: </b><span>{Γ' Γ : List Type} →
  {m : Type → Type u_1} →
    {ω : Type} →
      {Δ : List Type} → {b c : Bool} → {β : Type} → (Assg Γ' → Assg Γ) → Stmt m ω Γ Δ b c β → Stmt m ω Γ' Δ b c β</span></span></div></blockquote></div></small></div><span class="nv">mapAssg</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>Assg Γ' → Assg Γ</span></span></div></blockquote></div></small></div><span class="nv">f</span></span><span class="alectryon-token">) (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s₂</var><b>: </b><span>Stmt m ω Γ Δ b c β</span></span></div></blockquote></div></small></div><span class="nv">s₂</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>mapAssg</var><b>: </b><span>{Γ' Γ : List Type} →
  {m : Type → Type u_1} →
    {ω : Type} →
      {Δ : List Type} → {b c : Bool} → {β : Type} → (Assg Γ' → Assg Γ) → Stmt m ω Γ Δ b c β → Stmt m ω Γ' Δ b c β</span></span></div></blockquote></div></small></div><span class="nv">mapAssg</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>Assg Γ' → Assg Γ</span></span></div></blockquote></div></small></div><span class="nv">f</span></span><span class="alectryon-token">)
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ret</var><b>: </b><span>{m : Type → Type ?u.117891} →
  {ω : Type} → {Γ Δ : List Type} → {b c : Bool} → {α : Type} → (Assg Γ → Assg Δ → ω) → Stmt m ω Γ Δ b c α</span></span></div></blockquote></div></small></div>ret</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>Assg Γ → Assg Δ → ω</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ret</var><b>: </b><span>{m : Type → Type u_1} →
  {ω : Type} → {Γ Δ : List Type} → {b c : Bool} → {α : Type} → (Assg Γ → Assg Δ → ω) → Stmt m ω Γ Δ b c α</span></span></div></blockquote></div></small></div>ret</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>Assg Γ → Assg Δ → ω</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token"> <span class="bp">∘</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>Assg Γ' → Assg Γ</span></span></div></blockquote></div></small></div><span class="nv">f</span></span><span class="alectryon-token">)
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>sfor</var><b>: </b><span>{m : Type → Type ?u.117980} →
  {ω : Type} →
    {Γ Δ : List Type} →
      {α : Type} →
        {b c : Bool} → (Assg Γ → Assg Δ → List α) → Stmt m ω (α :: Γ) Δ true true Unit → Stmt m ω Γ Δ b c Unit</span></span></div></blockquote></div></small></div>sfor</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>Assg Γ → Assg Δ → List α✝</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>Stmt m ω (α✝ :: Γ) Δ true true Unit</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>sfor</var><b>: </b><span>{m : Type → Type u_1} →
  {ω : Type} →
    {Γ Δ : List Type} →
      {α : Type} →
        {b c : Bool} → (Assg Γ → Assg Δ → List α) → Stmt m ω (α :: Γ) Δ true true Unit → Stmt m ω Γ Δ b c Unit</span></span></div></blockquote></div></small></div>sfor</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>Assg Γ → Assg Δ → List α✝</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token"> <span class="bp">∘</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>Assg Γ' → Assg Γ</span></span></div></blockquote></div></small></div><span class="nv">f</span></span><span class="alectryon-token">) (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>Stmt m ω (α✝ :: Γ) Δ true true Unit</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>mapAssg</var><b>: </b><span>{Γ' Γ : List Type} →
  {m : Type → Type u_1} →
    {ω : Type} →
      {Δ : List Type} → {b c : Bool} → {β : Type} → (Assg Γ' → Assg Γ) → Stmt m ω Γ Δ b c β → Stmt m ω Γ' Δ b c β</span></span></div></blockquote></div></small></div><span class="nv">mapAssg</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><span class="k">fun</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>α✝</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"> :: </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>as</var><b>: </b><span>HList Γ'</span></span></div></blockquote></div></small></div><span class="nv">as</span></span><span class="alectryon-token">) <span class="bp">=&gt;</span> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>α✝</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"> :: </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>Assg Γ' → Assg Γ</span></span></div></blockquote></div></small></div><span class="nv">f</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>as</var><b>: </b><span>HList Γ'</span></span></div></blockquote></div></small></div><span class="nv">as</span></span><span class="alectryon-token">)))
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>sbreak</var><b>: </b><span>{m : Type → Type ?u.118585} → {ω : Type} → {Γ Δ : List Type} → {c : Bool} → {α : Type} → Stmt m ω Γ Δ true c α</span></span></div></blockquote></div></small></div>sbreak</span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>sbreak</var><b>: </b><span>{m : Type → Type u_1} → {ω : Type} → {Γ Δ : List Type} → {c : Bool} → {α : Type} → Stmt m ω Γ Δ true c α</span></span></div></blockquote></div></small></div>sbreak</span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>scont</var><b>: </b><span>{m : Type → Type ?u.118632} → {ω : Type} → {Γ Δ : List Type} → {b : Bool} → {α : Type} → Stmt m ω Γ Δ b true α</span></span></div></blockquote></div></small></div>scont</span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>scont</var><b>: </b><span>{m : Type → Type u_1} → {ω : Type} → {Γ Δ : List Type} → {b : Bool} → {α : Type} → Stmt m ω Γ Δ b true α</span></span></div></blockquote></div></small></div>scont</span><span class="alectryon-token"></span></span></pre>
<p>Let us write <code>f ∘ₑ e</code> for the composition of <code>f : α → β</code> with <code>e : Γ ⊢ Δ ⊢ α</code>, which we will use to rewrite embedded terms.</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">infixr</span></span><span class="alectryon-token">:<span class="mi">90</span> <span class="s2">&quot; ∘ₑ &quot;</span>  <span class="bp">=&gt;</span> </span><span class="alectryon-token"><span class="k">fun</span></span><span class="alectryon-token"> f e <span class="bp">=&gt;</span> </span><span class="alectryon-token"><span class="k">fun</span></span><span class="alectryon-token"> ρ σ <span class="bp">=&gt;</span> f e[ρ][σ]</span></span></pre>
<p>The formalization of <code>S</code> creates some technical hurdles. Because it operates on the outer-most mutable binding,
we have to operate on that context from the right, from which we lose some helpful definitional equalities and
have to rewrite types using nested proofs instead.</p>
<p>The helper function <code>shadowSnd</code> is particularly interesting because it shows how the shadowing in
translation rules (S2) and (S9) is expressed in our de Bruijn encoding: The context <code>α :: β :: α :: Γ</code>
corresponds, in this order, to the <code>y</code> that has just been bound to the value of <code>get</code>, then <code>x</code> from the
respective rule, followed by the <code>y</code> of the outer scope. We encode the shadowing of <code>y</code> by dropping the
third element from the context as well as the assignment. We are in fact forced to do so because the corresponding
branches of <code>S</code> would not otherwise typecheck. The only mistake we could still make is to drop the wrong <code>α</code> value
from the assignment, which (speaking from experience) would eventually be caught by the correctness proof.</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="bp">@</span>[</span><span class="alectryon-token"><span class="k">simp</span></span><span class="alectryon-token">] </span><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>S</var><b>: </b><span>{m : Type → Type} →
  {ω : Type} →
    {Γ Δ : List Type} →
      {α : Type} →
        {b c : Bool} →
          {β : Type} → [inst : Monad m] → Stmt m ω Γ (List.append Δ [α]) b c β → Stmt (StateT α m) ω (α :: Γ) Δ b c β</span></span></div></blockquote></div></small></div><span class="nv">S</span></span><span class="alectryon-token"> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Monad</var><b>: </b><span>(Type ?u.178851 → Type ?u.178850) → Type (max (?u.178851 + 1) ?u.178850)</span></span></div></blockquote></div></small></div>Monad</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>Type → Type</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token">] : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt</var><b>: </b><span>(Type → Type) → Type → List Type → List Type → Bool → Bool → Type → Type 1</span></span></div></blockquote></div></small></div>Stmt</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>Type → Type</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ω</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">ω</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Γ</var><b>: </b><span>List Type</span></span></div></blockquote></div></small></div><span class="nv">Γ</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Δ</var><b>: </b><span>List Type</span></span></div></blockquote></div></small></div><span class="nv">Δ</span></span><span class="alectryon-token"> <span class="bp">++</span> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token">]) </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>c</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div><span class="nv">c</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>β</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">β</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt</var><b>: </b><span>(Type → Type) → Type → List Type → List Type → Bool → Bool → Type → Type 1</span></span></div></blockquote></div></small></div>Stmt</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>StateT</var><b>: </b><span>Type → (Type → Type) → Type → Type</span></span></div></blockquote></div></small></div>StateT</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>Type → Type</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token">) </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ω</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">ω</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token"> :: </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Γ</var><b>: </b><span>List Type</span></span></div></blockquote></div></small></div><span class="nv">Γ</span></span><span class="alectryon-token">) </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Δ</var><b>: </b><span>List Type</span></span></div></blockquote></div></small></div><span class="nv">Δ</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>c</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div><span class="nv">c</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>β</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">β</span></span><span class="alectryon-token">
<span class="c">/-</span><span class="cm">(S1)-/</span> <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt.expr</var><b>: </b><span>{m : Type → Type ?u.189083} →
  {ω : Type} → {Γ Δ : List Type} → {α : Type} → {b c : Bool} → (Assg Γ → Assg Δ → m α) → Stmt m ω Γ Δ b c α</span></span></div></blockquote></div></small></div>Stmt.expr</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>Assg Γ → Assg (List.append Δ [α]) → m β</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt.expr</var><b>: </b><span>{m : Type → Type} →
  {ω : Type} → {Γ Δ : List Type} → {α : Type} → {b c : Bool} → (Assg Γ → Assg Δ → m α) → Stmt m ω Γ Δ b c α</span></span></div></blockquote></div></small></div>Stmt.expr</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>StateT.lift</var><b>: </b><span>{σ : Type} → {m : Type → Type} → [inst : Monad m] → {α : Type} → m α → StateT σ m α</span></span></div></blockquote></div></small></div>StateT.lift</span><span class="alectryon-token"> <span class="bp">∘ₑ</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>unmut</var><b>: </b><span>{β : Type} → (Assg Γ → Assg (List.append Δ [α]) → β) → Assg (α :: Γ) → Assg Δ → β</span></span></div></blockquote></div></small></div><span class="nv">unmut</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>Assg Γ → Assg (List.append Δ [α]) → m β</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token">)
<span class="c">/-</span><span class="cm">(S2)-/</span> <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt.bind</var><b>: </b><span>{m : Type → Type ?u.189320} →
  {ω : Type} →
    {Γ Δ : List Type} →
      {b c : Bool} → {α β : Type} → Stmt m ω Γ Δ b c α → Stmt m ω (α :: Γ) Δ b c β → Stmt m ω Γ Δ b c β</span></span></div></blockquote></div></small></div>Stmt.bind</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s₁</var><b>: </b><span>Stmt m ω Γ (List.append Δ [α]) b c α✝</span></span></div></blockquote></div></small></div><span class="nv">s₁</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s₂</var><b>: </b><span>Stmt m ω (α✝ :: Γ) (List.append Δ [α]) b c β</span></span></div></blockquote></div></small></div><span class="nv">s₂</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt.bind</var><b>: </b><span>{m : Type → Type} →
  {ω : Type} →
    {Γ Δ : List Type} →
      {b c : Bool} → {α β : Type} → Stmt m ω Γ Δ b c α → Stmt m ω (α :: Γ) Δ b c β → Stmt m ω Γ Δ b c β</span></span></div></blockquote></div></small></div>Stmt.bind</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>S</var><b>: </b><span>{m : Type → Type} →
  {ω : Type} →
    {Γ Δ : List Type} →
      {α : Type} →
        {b c : Bool} →
          {β : Type} → [inst : Monad m] → Stmt m ω Γ (List.append Δ [α]) b c β → Stmt (StateT α m) ω (α :: Γ) Δ b c β</span></span></div></blockquote></div></small></div><span class="nv">S</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s₁</var><b>: </b><span>Stmt m ω Γ (List.append Δ [α]) b c α✝</span></span></div></blockquote></div></small></div><span class="nv">s₁</span></span><span class="alectryon-token">) (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt.bind</var><b>: </b><span>{m : Type → Type} →
  {ω : Type} →
    {Γ Δ : List Type} →
      {b c : Bool} → {α β : Type} → Stmt m ω Γ Δ b c α → Stmt m ω (α :: Γ) Δ b c β → Stmt m ω Γ Δ b c β</span></span></div></blockquote></div></small></div>Stmt.bind</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt.expr</var><b>: </b><span>{m : Type → Type} →
  {ω : Type} → {Γ Δ : List Type} → {α : Type} → {b c : Bool} → (Assg Γ → Assg Δ → m α) → Stmt m ω Γ Δ b c α</span></span></div></blockquote></div></small></div>Stmt.expr</span><span class="alectryon-token"> (</span><span class="alectryon-token"><span class="k">fun</span></span><span class="alectryon-token"> _ _ <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>get</var><b>: </b><span>{σ : Type} → {m : Type → Type} → [self : MonadState σ m] → m σ</span></span></div></blockquote></div></small></div>get</span><span class="alectryon-token">)) (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt.mapAssg</var><b>: </b><span>{Γ' Γ : List Type} →
  {m : Type → Type} →
    {ω : Type} →
      {Δ : List Type} → {b c : Bool} → {β : Type} → (Assg Γ' → Assg Γ) → Stmt m ω Γ Δ b c β → Stmt m ω Γ' Δ b c β</span></span></div></blockquote></div></small></div>Stmt.mapAssg</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>shadowSnd</var><b>: </b><span>{β : Type} → Assg (α :: β :: α :: Γ) → Assg (α :: β :: Γ)</span></span></div></blockquote></div></small></div><span class="nv">shadowSnd</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>S</var><b>: </b><span>{m : Type → Type} →
  {ω : Type} →
    {Γ Δ : List Type} →
      {α : Type} →
        {b c : Bool} →
          {β : Type} → [inst : Monad m] → Stmt m ω Γ (List.append Δ [α]) b c β → Stmt (StateT α m) ω (α :: Γ) Δ b c β</span></span></div></blockquote></div></small></div><span class="nv">S</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s₂</var><b>: </b><span>Stmt m ω (α✝ :: Γ) (List.append Δ [α]) b c β</span></span></div></blockquote></div></small></div><span class="nv">s₂</span></span><span class="alectryon-token">)))
<span class="c">/-</span><span class="cm">(S3)-/</span> <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt.letmut</var><b>: </b><span>{m : Type → Type ?u.189575} →
  {ω : Type} →
    {Γ Δ : List Type} →
      {α : Type} → {b c : Bool} → {β : Type} → (Assg Γ → Assg Δ → α) → Stmt m ω Γ (α :: Δ) b c β → Stmt m ω Γ Δ b c β</span></span></div></blockquote></div></small></div>Stmt.letmut</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>Assg Γ → Assg (List.append Δ [α]) → α✝</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>Stmt m ω Γ (α✝ :: List.append Δ [α]) b c β</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt.letmut</var><b>: </b><span>{m : Type → Type} →
  {ω : Type} →
    {Γ Δ : List Type} →
      {α : Type} → {b c : Bool} → {β : Type} → (Assg Γ → Assg Δ → α) → Stmt m ω Γ (α :: Δ) b c β → Stmt m ω Γ Δ b c β</span></span></div></blockquote></div></small></div>Stmt.letmut</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>unmut</var><b>: </b><span>{β : Type} → (Assg Γ → Assg (List.append Δ [α]) → β) → Assg (α :: Γ) → Assg Δ → β</span></span></div></blockquote></div></small></div><span class="nv">unmut</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>Assg Γ → Assg (List.append Δ [α]) → α✝</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token">) (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>S</var><b>: </b><span>{m : Type → Type} →
  {ω : Type} →
    {Γ Δ : List Type} →
      {α : Type} →
        {b c : Bool} →
          {β : Type} → [inst : Monad m] → Stmt m ω Γ (List.append Δ [α]) b c β → Stmt (StateT α m) ω (α :: Γ) Δ b c β</span></span></div></blockquote></div></small></div><span class="nv">S</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>Stmt m ω Γ (α✝ :: List.append Δ [α]) b c β</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token">)
         <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt.assg</var><b>: </b><span>{m : Type → Type ?u.189691} →
  {ω : Type} →
    {Γ Δ : List Type} →
      {b c : Bool} → (x : Fin (List.length Δ)) → (Assg Γ → Assg Δ → List.get Δ x) → Stmt m ω Γ Δ b c Unit</span></span></div></blockquote></div></small></div>Stmt.assg</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>Fin (List.length (List.append Δ [α]))</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>Assg Γ → Assg (List.append Δ [α]) → List.get (List.append Δ [α]) x</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span>
           </span><span class="alectryon-token"><span class="k">if</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>h</var><b>: </b><span>¬x.val &lt; List.length Δ</span></span></div></blockquote></div></small></div><span class="nv">h</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>Fin (List.length (List.append Δ [α]))</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> <span class="bp">&lt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Δ</var><b>: </b><span>List Type</span></span></div></blockquote></div></small></div><span class="nv">Δ</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>length</var><b>: </b><span>{α : Type 1} → List α → Nat</span></span></div></blockquote></div></small></div>length</span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">then</span></span><span class="alectryon-token">
<span class="c">/-</span><span class="cm">(S4)-/</span>     </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt.assg</var><b>: </b><span>{m : Type → Type} →
  {ω : Type} →
    {Γ Δ : List Type} →
      {b c : Bool} → (x : Fin (List.length Δ)) → (Assg Γ → Assg Δ → List.get Δ x) → Stmt m ω Γ Δ b c Unit</span></span></div></blockquote></div></small></div>Stmt.assg</span><span class="alectryon-token"> ⟨</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>Fin (List.length (List.append Δ [α]))</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>h</var><b>: </b><span>x.val &lt; List.length Δ</span></span></div></blockquote></div></small></div><span class="nv">h</span></span><span class="alectryon-token">⟩ (</span><span class="alectryon-token"><span class="k">fun</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>y</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">y</span></span><span class="alectryon-token"> :: </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ρ</var><b>: </b><span>HList Γ</span></span></div></blockquote></div></small></div><span class="nv">ρ</span></span><span class="alectryon-token">) </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>σ</var><b>: </b><span>Assg Δ</span></span></div></blockquote></div></small></div><span class="nv">σ</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>List.get_append_left</var><b>: </b><span>∀ {α : Type 1} {i : Nat} (as bs : List α) (h : i &lt; List.length as) {h' : i &lt; List.length (as ++ bs)},
  List.get (as ++ bs) { val := i, isLt := h' } = List.get as { val := i, isLt := h }</span></span></div></blockquote></div></small></div>List.get_append_left</span><span class="alectryon-token"> <span class="bp">..</span> <span class="bp">▸</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>Assg Γ → Assg (List.append Δ [α]) → List.get (List.append Δ [α]) x</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ρ</var><b>: </b><span>HList Γ</span></span></div></blockquote></div></small></div><span class="nv">ρ</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Assg.extendBot</var><b>: </b><span>{α : Type} → α → {Γ : List Type} → Assg Γ → Assg (List.append Γ [α])</span></span></div></blockquote></div></small></div>Assg.extendBot</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>y</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">y</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>σ</var><b>: </b><span>Assg Δ</span></span></div></blockquote></div></small></div><span class="nv">σ</span></span><span class="alectryon-token">))
           </span><span class="alectryon-token"><span class="k">else</span></span><span class="alectryon-token">
<span class="c">/-</span><span class="cm">(S5)-/</span>     </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt.expr</var><b>: </b><span>{m : Type → Type} →
  {ω : Type} → {Γ Δ : List Type} → {α : Type} → {b c : Bool} → (Assg Γ → Assg Δ → m α) → Stmt m ω Γ Δ b c α</span></span></div></blockquote></div></small></div>Stmt.expr</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>set</var><b>: </b><span>{σ : Type} → {m : Type → Type} → [self : MonadStateOf σ m] → σ → m PUnit</span></span></div></blockquote></div></small></div>set</span><span class="alectryon-token"> (σ := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token">) <span class="bp">∘ₑ</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>cast</var><b>: </b><span>{α β : Type} → α = β → α → β</span></span></div></blockquote></div></small></div>cast</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>List.get_last</var><b>: </b><span>∀ {α : Type 1} {a : α} {as : List α} {i : Fin (List.length (as ++ [a]))},
  ¬i.val &lt; List.length as → List.get (as ++ [a]) i = a</span></span></div></blockquote></div></small></div>List.get_last</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>h</var><b>: </b><span>¬x.val &lt; List.length Δ</span></span></div></blockquote></div></small></div><span class="nv">h</span></span><span class="alectryon-token">) <span class="bp">∘ₑ</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>unmut</var><b>: </b><span>{β : Type} → (Assg Γ → Assg (List.append Δ [α]) → β) → Assg (α :: Γ) → Assg Δ → β</span></span></div></blockquote></div></small></div><span class="nv">unmut</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>Assg Γ → Assg (List.append Δ [α]) → List.get (List.append Δ [α]) x</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token">)
<span class="c">/-</span><span class="cm">(S6)-/</span> <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt.ite</var><b>: </b><span>{m : Type → Type ?u.190593} →
  {ω : Type} →
    {Γ Δ : List Type} →
      {b c : Bool} →
        {α : Type} → (Assg Γ → Assg Δ → Bool) → Stmt m ω Γ Δ b c α → Stmt m ω Γ Δ b c α → Stmt m ω Γ Δ b c α</span></span></div></blockquote></div></small></div>Stmt.ite</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>Assg Γ → Assg (List.append Δ [α]) → Bool</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s₁</var><b>: </b><span>Stmt m ω Γ (List.append Δ [α]) b c β</span></span></div></blockquote></div></small></div><span class="nv">s₁</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s₂</var><b>: </b><span>Stmt m ω Γ (List.append Δ [α]) b c β</span></span></div></blockquote></div></small></div><span class="nv">s₂</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt.ite</var><b>: </b><span>{m : Type → Type} →
  {ω : Type} →
    {Γ Δ : List Type} →
      {b c : Bool} →
        {α : Type} → (Assg Γ → Assg Δ → Bool) → Stmt m ω Γ Δ b c α → Stmt m ω Γ Δ b c α → Stmt m ω Γ Δ b c α</span></span></div></blockquote></div></small></div>Stmt.ite</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>unmut</var><b>: </b><span>{β : Type} → (Assg Γ → Assg (List.append Δ [α]) → β) → Assg (α :: Γ) → Assg Δ → β</span></span></div></blockquote></div></small></div><span class="nv">unmut</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>Assg Γ → Assg (List.append Δ [α]) → Bool</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token">) (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>S</var><b>: </b><span>{m : Type → Type} →
  {ω : Type} →
    {Γ Δ : List Type} →
      {α : Type} →
        {b c : Bool} →
          {β : Type} → [inst : Monad m] → Stmt m ω Γ (List.append Δ [α]) b c β → Stmt (StateT α m) ω (α :: Γ) Δ b c β</span></span></div></blockquote></div></small></div><span class="nv">S</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s₁</var><b>: </b><span>Stmt m ω Γ (List.append Δ [α]) b c β</span></span></div></blockquote></div></small></div><span class="nv">s₁</span></span><span class="alectryon-token">) (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>S</var><b>: </b><span>{m : Type → Type} →
  {ω : Type} →
    {Γ Δ : List Type} →
      {α : Type} →
        {b c : Bool} →
          {β : Type} → [inst : Monad m] → Stmt m ω Γ (List.append Δ [α]) b c β → Stmt (StateT α m) ω (α :: Γ) Δ b c β</span></span></div></blockquote></div></small></div><span class="nv">S</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s₂</var><b>: </b><span>Stmt m ω Γ (List.append Δ [α]) b c β</span></span></div></blockquote></div></small></div><span class="nv">s₂</span></span><span class="alectryon-token">)
         <span class="c1">-- unreachable case; could be eliminated by a more precise specification of `ω`, but the benefit would be minimal</span>
         <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt.ret</var><b>: </b><span>{m : Type → Type ?u.190711} →
  {ω : Type} → {Γ Δ : List Type} → {b c : Bool} → {α : Type} → (Assg Γ → Assg Δ → ω) → Stmt m ω Γ Δ b c α</span></span></div></blockquote></div></small></div>Stmt.ret</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>Assg Γ → Assg (List.append Δ [α]) → ω</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt.ret</var><b>: </b><span>{m : Type → Type} →
  {ω : Type} → {Γ Δ : List Type} → {b c : Bool} → {α : Type} → (Assg Γ → Assg Δ → ω) → Stmt m ω Γ Δ b c α</span></span></div></blockquote></div></small></div>Stmt.ret</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>unmut</var><b>: </b><span>{β : Type} → (Assg Γ → Assg (List.append Δ [α]) → β) → Assg (α :: Γ) → Assg Δ → β</span></span></div></blockquote></div></small></div><span class="nv">unmut</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>Assg Γ → Assg (List.append Δ [α]) → ω</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token">)
<span class="c">/-</span><span class="cm">(S7)-/</span> <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt.sbreak</var><b>: </b><span>{m : Type → Type ?u.190795} → {ω : Type} → {Γ Δ : List Type} → {c : Bool} → {α : Type} → Stmt m ω Γ Δ true c α</span></span></div></blockquote></div></small></div>Stmt.sbreak</span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt.sbreak</var><b>: </b><span>{m : Type → Type} → {ω : Type} → {Γ Δ : List Type} → {c : Bool} → {α : Type} → Stmt m ω Γ Δ true c α</span></span></div></blockquote></div></small></div>Stmt.sbreak</span><span class="alectryon-token">
<span class="c">/-</span><span class="cm">(S8)-/</span> <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt.scont</var><b>: </b><span>{m : Type → Type ?u.190845} → {ω : Type} → {Γ Δ : List Type} → {b : Bool} → {α : Type} → Stmt m ω Γ Δ b true α</span></span></div></blockquote></div></small></div>Stmt.scont</span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt.scont</var><b>: </b><span>{m : Type → Type} → {ω : Type} → {Γ Δ : List Type} → {b : Bool} → {α : Type} → Stmt m ω Γ Δ b true α</span></span></div></blockquote></div></small></div>Stmt.scont</span><span class="alectryon-token">
<span class="c">/-</span><span class="cm">(S9)-/</span> <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt.sfor</var><b>: </b><span>{m : Type → Type ?u.190894} →
  {ω : Type} →
    {Γ Δ : List Type} →
      {α : Type} →
        {b c : Bool} → (Assg Γ → Assg Δ → List α) → Stmt m ω (α :: Γ) Δ true true Unit → Stmt m ω Γ Δ b c Unit</span></span></div></blockquote></div></small></div>Stmt.sfor</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>Assg Γ → Assg (List.append Δ [α]) → List α✝</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>Stmt m ω (α✝ :: Γ) (List.append Δ [α]) true true Unit</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt.sfor</var><b>: </b><span>{m : Type → Type} →
  {ω : Type} →
    {Γ Δ : List Type} →
      {α : Type} →
        {b c : Bool} → (Assg Γ → Assg Δ → List α) → Stmt m ω (α :: Γ) Δ true true Unit → Stmt m ω Γ Δ b c Unit</span></span></div></blockquote></div></small></div>Stmt.sfor</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>unmut</var><b>: </b><span>{β : Type} → (Assg Γ → Assg (List.append Δ [α]) → β) → Assg (α :: Γ) → Assg Δ → β</span></span></div></blockquote></div></small></div><span class="nv">unmut</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>Assg Γ → Assg (List.append Δ [α]) → List α✝</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token">) (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt.bind</var><b>: </b><span>{m : Type → Type} →
  {ω : Type} →
    {Γ Δ : List Type} →
      {b c : Bool} → {α β : Type} → Stmt m ω Γ Δ b c α → Stmt m ω (α :: Γ) Δ b c β → Stmt m ω Γ Δ b c β</span></span></div></blockquote></div></small></div>Stmt.bind</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt.expr</var><b>: </b><span>{m : Type → Type} →
  {ω : Type} → {Γ Δ : List Type} → {α : Type} → {b c : Bool} → (Assg Γ → Assg Δ → m α) → Stmt m ω Γ Δ b c α</span></span></div></blockquote></div></small></div>Stmt.expr</span><span class="alectryon-token"> (</span><span class="alectryon-token"><span class="k">fun</span></span><span class="alectryon-token"> _ _ <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>get</var><b>: </b><span>{σ : Type} → {m : Type → Type} → [self : MonadState σ m] → m σ</span></span></div></blockquote></div></small></div>get</span><span class="alectryon-token">)) (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt.mapAssg</var><b>: </b><span>{Γ' Γ : List Type} →
  {m : Type → Type} →
    {ω : Type} →
      {Δ : List Type} → {b c : Bool} → {β : Type} → (Assg Γ' → Assg Γ) → Stmt m ω Γ Δ b c β → Stmt m ω Γ' Δ b c β</span></span></div></blockquote></div></small></div>Stmt.mapAssg</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>shadowSnd</var><b>: </b><span>{β : Type} → Assg (α :: β :: α :: Γ) → Assg (α :: β :: Γ)</span></span></div></blockquote></div></small></div><span class="nv">shadowSnd</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>S</var><b>: </b><span>{m : Type → Type} →
  {ω : Type} →
    {Γ Δ : List Type} →
      {α : Type} →
        {b c : Bool} →
          {β : Type} → [inst : Monad m] → Stmt m ω Γ (List.append Δ [α]) b c β → Stmt (StateT α m) ω (α :: Γ) Δ b c β</span></span></div></blockquote></div></small></div><span class="nv">S</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>Stmt m ω (α✝ :: Γ) (List.append Δ [α]) true true Unit</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token">)))
</span><span class="alectryon-token"><span class="k">where</span></span><span class="alectryon-token">
  <span class="bp">@</span>[</span><span class="alectryon-token"><span class="k">simp</span></span><span class="alectryon-token">] </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>unmut</var><b>: </b><span>{β : Type} → (Assg Γ → Assg (List.append Δ [α]) → β) → Assg (α :: Γ) → Assg Δ → β</span></span></div></blockquote></div></small></div><span class="nv">unmut</span></span><span class="alectryon-token"> {</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>β</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">β</span></span><span class="alectryon-token">} (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>Assg Γ → Assg (List.append Δ [α]) → β</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Γ</var><b>: </b><span>List Type</span></span></div></blockquote></div></small></div><span class="nv">Γ</span></span><span class="alectryon-token"> <span class="bp">⊢</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Δ</var><b>: </b><span>List Type</span></span></div></blockquote></div></small></div><span class="nv">Δ</span></span><span class="alectryon-token"> <span class="bp">++</span> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token">] <span class="bp">⊢</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>β</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">β</span></span><span class="alectryon-token">) : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token"> :: </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Γ</var><b>: </b><span>List Type</span></span></div></blockquote></div></small></div><span class="nv">Γ</span></span><span class="alectryon-token"> <span class="bp">⊢</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Δ</var><b>: </b><span>List Type</span></span></div></blockquote></div></small></div><span class="nv">Δ</span></span><span class="alectryon-token"> <span class="bp">⊢</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>β</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">β</span></span><span class="alectryon-token">
    <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>y</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">y</span></span><span class="alectryon-token"> :: </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ρ</var><b>: </b><span>HList Γ</span></span></div></blockquote></div></small></div><span class="nv">ρ</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>σ</var><b>: </b><span>Assg Δ</span></span></div></blockquote></div></small></div><span class="nv">σ</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>Assg Γ → Assg (List.append Δ [α]) → β</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ρ</var><b>: </b><span>HList Γ</span></span></div></blockquote></div></small></div><span class="nv">ρ</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Assg.extendBot</var><b>: </b><span>{α : Type} → α → {Γ : List Type} → Assg Γ → Assg (List.append Γ [α])</span></span></div></blockquote></div></small></div>Assg.extendBot</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>y</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">y</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>σ</var><b>: </b><span>Assg Δ</span></span></div></blockquote></div></small></div><span class="nv">σ</span></span><span class="alectryon-token">)
  <span class="bp">@</span>[</span><span class="alectryon-token"><span class="k">simp</span></span><span class="alectryon-token">] </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>shadowSnd</var><b>: </b><span>{Γ : List Type} → {α β : Type} → Assg (α :: β :: α :: Γ) → Assg (α :: β :: Γ)</span></span></div></blockquote></div></small></div><span class="nv">shadowSnd</span></span><span class="alectryon-token"> {</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>β</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">β</span></span><span class="alectryon-token">} : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Assg</var><b>: </b><span>List Type → Type</span></span></div></blockquote></div></small></div>Assg</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token"> :: </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>β</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">β</span></span><span class="alectryon-token"> :: </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token"> :: </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Γ</var><b>: </b><span>List Type</span></span></div></blockquote></div></small></div><span class="nv">Γ</span></span><span class="alectryon-token">) <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Assg</var><b>: </b><span>List Type → Type</span></span></div></blockquote></div></small></div>Assg</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token"> :: </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>β</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">β</span></span><span class="alectryon-token"> :: </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Γ</var><b>: </b><span>List Type</span></span></div></blockquote></div></small></div><span class="nv">Γ</span></span><span class="alectryon-token">)
    <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a'</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">a&#39;</span></span><span class="alectryon-token"> :: </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>β</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token"> :: _ :: </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ρ</var><b>: </b><span>HList Γ</span></span></div></blockquote></div></small></div><span class="nv">ρ</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a'</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">a&#39;</span></span><span class="alectryon-token"> :: </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>β</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token"> :: </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ρ</var><b>: </b><span>HList Γ</span></span></div></blockquote></div></small></div><span class="nv">ρ</span></span><span class="alectryon-token">

<span class="bp">@</span>[</span><span class="alectryon-token"><span class="k">simp</span></span><span class="alectryon-token">] </span><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>R</var><b>: </b><span>{m : Type → Type u_1} →
  {ω : Type} →
    {Γ Δ : List Type} →
      {b c : Bool} → {α : Type} → [inst : Monad m] → Stmt m ω Γ Δ b c α → Stmt (ExceptT ω m) Empty Γ Δ b c α</span></span></div></blockquote></div></small></div><span class="nv">R</span></span><span class="alectryon-token"> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Monad</var><b>: </b><span>(Type ?u.239464 → Type ?u.239463) → Type (max (?u.239464 + 1) ?u.239463)</span></span></div></blockquote></div></small></div>Monad</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>Type → Type u_1</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token">] : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt</var><b>: </b><span>(Type → Type u_1) → Type → List Type → List Type → Bool → Bool → Type → Type (max 1 u_1)</span></span></div></blockquote></div></small></div>Stmt</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>Type → Type u_1</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ω</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">ω</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Γ</var><b>: </b><span>List Type</span></span></div></blockquote></div></small></div><span class="nv">Γ</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Δ</var><b>: </b><span>List Type</span></span></div></blockquote></div></small></div><span class="nv">Δ</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>c</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div><span class="nv">c</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt</var><b>: </b><span>(Type → Type u_1) → Type → List Type → List Type → Bool → Bool → Type → Type (max 1 u_1)</span></span></div></blockquote></div></small></div>Stmt</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ExceptT</var><b>: </b><span>Type → (Type → Type u_1) → Type → Type u_1</span></span></div></blockquote></div></small></div>ExceptT</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ω</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">ω</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>Type → Type u_1</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token">) </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Empty</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Empty</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Γ</var><b>: </b><span>List Type</span></span></div></blockquote></div></small></div><span class="nv">Γ</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Δ</var><b>: </b><span>List Type</span></span></div></blockquote></div></small></div><span class="nv">Δ</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>c</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div><span class="nv">c</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token">
<span class="c">/-</span><span class="cm">(R1)-/</span> <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt.ret</var><b>: </b><span>{m : Type → Type ?u.242023} →
  {ω : Type} → {Γ Δ : List Type} → {b c : Bool} → {α : Type} → (Assg Γ → Assg Δ → ω) → Stmt m ω Γ Δ b c α</span></span></div></blockquote></div></small></div>Stmt.ret</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>Assg Γ → Assg Δ → ω</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt.expr</var><b>: </b><span>{m : Type → Type u_1} →
  {ω : Type} → {Γ Δ : List Type} → {α : Type} → {b c : Bool} → (Assg Γ → Assg Δ → m α) → Stmt m ω Γ Δ b c α</span></span></div></blockquote></div></small></div>Stmt.expr</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>throw</var><b>: </b><span>{ε : Type} → {m : Type → Type u_1} → [self : MonadExcept ε m] → {α : Type} → ε → m α</span></span></div></blockquote></div></small></div>throw</span><span class="alectryon-token"> <span class="bp">∘ₑ</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>Assg Γ → Assg Δ → ω</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token">)
<span class="c">/-</span><span class="cm">(R2)-/</span> <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt.expr</var><b>: </b><span>{m : Type → Type ?u.242193} →
  {ω : Type} → {Γ Δ : List Type} → {α : Type} → {b c : Bool} → (Assg Γ → Assg Δ → m α) → Stmt m ω Γ Δ b c α</span></span></div></blockquote></div></small></div>Stmt.expr</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>Assg Γ → Assg Δ → m α</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt.expr</var><b>: </b><span>{m : Type → Type u_1} →
  {ω : Type} → {Γ Δ : List Type} → {α : Type} → {b c : Bool} → (Assg Γ → Assg Δ → m α) → Stmt m ω Γ Δ b c α</span></span></div></blockquote></div></small></div>Stmt.expr</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ExceptT.lift</var><b>: </b><span>{ε : Type} → {m : Type → Type u_1} → [inst : Monad m] → {α : Type} → m α → ExceptT ε m α</span></span></div></blockquote></div></small></div>ExceptT.lift</span><span class="alectryon-token"> <span class="bp">∘ₑ</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>Assg Γ → Assg Δ → m α</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token">)
<span class="c">/-</span><span class="cm">(R3)-/</span> <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt.bind</var><b>: </b><span>{m : Type → Type ?u.242398} →
  {ω : Type} →
    {Γ Δ : List Type} →
      {b c : Bool} → {α β : Type} → Stmt m ω Γ Δ b c α → Stmt m ω (α :: Γ) Δ b c β → Stmt m ω Γ Δ b c β</span></span></div></blockquote></div></small></div>Stmt.bind</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>Stmt m ω Γ Δ b c α✝</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s'</var><b>: </b><span>Stmt m ω (α✝ :: Γ) Δ b c α</span></span></div></blockquote></div></small></div><span class="nv">s&#39;</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt.bind</var><b>: </b><span>{m : Type → Type u_1} →
  {ω : Type} →
    {Γ Δ : List Type} →
      {b c : Bool} → {α β : Type} → Stmt m ω Γ Δ b c α → Stmt m ω (α :: Γ) Δ b c β → Stmt m ω Γ Δ b c β</span></span></div></blockquote></div></small></div>Stmt.bind</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>R</var><b>: </b><span>{m : Type → Type u_1} →
  {ω : Type} →
    {Γ Δ : List Type} →
      {b c : Bool} → {α : Type} → [inst : Monad m] → Stmt m ω Γ Δ b c α → Stmt (ExceptT ω m) Empty Γ Δ b c α</span></span></div></blockquote></div></small></div><span class="nv">R</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>Stmt m ω Γ Δ b c α✝</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token">) (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>R</var><b>: </b><span>{m : Type → Type u_1} →
  {ω : Type} →
    {Γ Δ : List Type} →
      {b c : Bool} → {α : Type} → [inst : Monad m] → Stmt m ω Γ Δ b c α → Stmt (ExceptT ω m) Empty Γ Δ b c α</span></span></div></blockquote></div></small></div><span class="nv">R</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s'</var><b>: </b><span>Stmt m ω (α✝ :: Γ) Δ b c α</span></span></div></blockquote></div></small></div><span class="nv">s&#39;</span></span><span class="alectryon-token">)
<span class="c">/-</span><span class="cm">(R4)-/</span> <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt.letmut</var><b>: </b><span>{m : Type → Type ?u.242495} →
  {ω : Type} →
    {Γ Δ : List Type} →
      {α : Type} → {b c : Bool} → {β : Type} → (Assg Γ → Assg Δ → α) → Stmt m ω Γ (α :: Δ) b c β → Stmt m ω Γ Δ b c β</span></span></div></blockquote></div></small></div>Stmt.letmut</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>Assg Γ → Assg Δ → α✝</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>Stmt m ω Γ (α✝ :: Δ) b c α</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt.letmut</var><b>: </b><span>{m : Type → Type u_1} →
  {ω : Type} →
    {Γ Δ : List Type} →
      {α : Type} → {b c : Bool} → {β : Type} → (Assg Γ → Assg Δ → α) → Stmt m ω Γ (α :: Δ) b c β → Stmt m ω Γ Δ b c β</span></span></div></blockquote></div></small></div>Stmt.letmut</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>Assg Γ → Assg Δ → α✝</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>R</var><b>: </b><span>{m : Type → Type u_1} →
  {ω : Type} →
    {Γ Δ : List Type} →
      {b c : Bool} → {α : Type} → [inst : Monad m] → Stmt m ω Γ Δ b c α → Stmt (ExceptT ω m) Empty Γ Δ b c α</span></span></div></blockquote></div></small></div><span class="nv">R</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>Stmt m ω Γ (α✝ :: Δ) b c α</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token">)
<span class="c">/-</span><span class="cm">(R5)-/</span> <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt.assg</var><b>: </b><span>{m : Type → Type ?u.242597} →
  {ω : Type} →
    {Γ Δ : List Type} →
      {b c : Bool} → (x : Fin (List.length Δ)) → (Assg Γ → Assg Δ → List.get Δ x) → Stmt m ω Γ Δ b c Unit</span></span></div></blockquote></div></small></div>Stmt.assg</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>Fin (List.length Δ)</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>Assg Γ → Assg Δ → List.get Δ x</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt.assg</var><b>: </b><span>{m : Type → Type u_1} →
  {ω : Type} →
    {Γ Δ : List Type} →
      {b c : Bool} → (x : Fin (List.length Δ)) → (Assg Γ → Assg Δ → List.get Δ x) → Stmt m ω Γ Δ b c Unit</span></span></div></blockquote></div></small></div>Stmt.assg</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>Fin (List.length Δ)</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>Assg Γ → Assg Δ → List.get Δ x</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token">
<span class="c">/-</span><span class="cm">(R6)-/</span> <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt.ite</var><b>: </b><span>{m : Type → Type ?u.242681} →
  {ω : Type} →
    {Γ Δ : List Type} →
      {b c : Bool} →
        {α : Type} → (Assg Γ → Assg Δ → Bool) → Stmt m ω Γ Δ b c α → Stmt m ω Γ Δ b c α → Stmt m ω Γ Δ b c α</span></span></div></blockquote></div></small></div>Stmt.ite</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>Assg Γ → Assg Δ → Bool</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s₁</var><b>: </b><span>Stmt m ω Γ Δ b c α</span></span></div></blockquote></div></small></div><span class="nv">s₁</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s₂</var><b>: </b><span>Stmt m ω Γ Δ b c α</span></span></div></blockquote></div></small></div><span class="nv">s₂</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt.ite</var><b>: </b><span>{m : Type → Type u_1} →
  {ω : Type} →
    {Γ Δ : List Type} →
      {b c : Bool} →
        {α : Type} → (Assg Γ → Assg Δ → Bool) → Stmt m ω Γ Δ b c α → Stmt m ω Γ Δ b c α → Stmt m ω Γ Δ b c α</span></span></div></blockquote></div></small></div>Stmt.ite</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>Assg Γ → Assg Δ → Bool</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>R</var><b>: </b><span>{m : Type → Type u_1} →
  {ω : Type} →
    {Γ Δ : List Type} →
      {b c : Bool} → {α : Type} → [inst : Monad m] → Stmt m ω Γ Δ b c α → Stmt (ExceptT ω m) Empty Γ Δ b c α</span></span></div></blockquote></div></small></div><span class="nv">R</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s₁</var><b>: </b><span>Stmt m ω Γ Δ b c α</span></span></div></blockquote></div></small></div><span class="nv">s₁</span></span><span class="alectryon-token">) (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>R</var><b>: </b><span>{m : Type → Type u_1} →
  {ω : Type} →
    {Γ Δ : List Type} →
      {b c : Bool} → {α : Type} → [inst : Monad m] → Stmt m ω Γ Δ b c α → Stmt (ExceptT ω m) Empty Γ Δ b c α</span></span></div></blockquote></div></small></div><span class="nv">R</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s₂</var><b>: </b><span>Stmt m ω Γ Δ b c α</span></span></div></blockquote></div></small></div><span class="nv">s₂</span></span><span class="alectryon-token">)
<span class="c">/-</span><span class="cm">(R7)-/</span> <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt.sbreak</var><b>: </b><span>{m : Type → Type ?u.242784} → {ω : Type} → {Γ Δ : List Type} → {c : Bool} → {α : Type} → Stmt m ω Γ Δ true c α</span></span></div></blockquote></div></small></div>Stmt.sbreak</span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt.sbreak</var><b>: </b><span>{m : Type → Type u_1} → {ω : Type} → {Γ Δ : List Type} → {c : Bool} → {α : Type} → Stmt m ω Γ Δ true c α</span></span></div></blockquote></div></small></div>Stmt.sbreak</span><span class="alectryon-token">
<span class="c">/-</span><span class="cm">(R8)-/</span> <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt.scont</var><b>: </b><span>{m : Type → Type ?u.242831} → {ω : Type} → {Γ Δ : List Type} → {b : Bool} → {α : Type} → Stmt m ω Γ Δ b true α</span></span></div></blockquote></div></small></div>Stmt.scont</span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt.scont</var><b>: </b><span>{m : Type → Type u_1} → {ω : Type} → {Γ Δ : List Type} → {b : Bool} → {α : Type} → Stmt m ω Γ Δ b true α</span></span></div></blockquote></div></small></div>Stmt.scont</span><span class="alectryon-token">
<span class="c">/-</span><span class="cm">(R9)-/</span> <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt.sfor</var><b>: </b><span>{m : Type → Type ?u.242877} →
  {ω : Type} →
    {Γ Δ : List Type} →
      {α : Type} →
        {b c : Bool} → (Assg Γ → Assg Δ → List α) → Stmt m ω (α :: Γ) Δ true true Unit → Stmt m ω Γ Δ b c Unit</span></span></div></blockquote></div></small></div>Stmt.sfor</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>Assg Γ → Assg Δ → List α✝</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>Stmt m ω (α✝ :: Γ) Δ true true Unit</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt.sfor</var><b>: </b><span>{m : Type → Type u_1} →
  {ω : Type} →
    {Γ Δ : List Type} →
      {α : Type} →
        {b c : Bool} → (Assg Γ → Assg Δ → List α) → Stmt m ω (α :: Γ) Δ true true Unit → Stmt m ω Γ Δ b c Unit</span></span></div></blockquote></div></small></div>Stmt.sfor</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>Assg Γ → Assg Δ → List α✝</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>R</var><b>: </b><span>{m : Type → Type u_1} →
  {ω : Type} →
    {Γ Δ : List Type} →
      {b c : Bool} → {α : Type} → [inst : Monad m] → Stmt m ω Γ Δ b c α → Stmt (ExceptT ω m) Empty Γ Δ b c α</span></span></div></blockquote></div></small></div><span class="nv">R</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>Stmt m ω (α✝ :: Γ) Δ true true Unit</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token">)

<span class="bp">@</span>[</span><span class="alectryon-token"><span class="k">simp</span></span><span class="alectryon-token">] </span><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>L</var><b>: </b><span>{m : Type → Type u_1} →
  {ω : Type} →
    {Γ Δ : List Type} →
      {b c : Bool} → {α : Type} → [inst : Monad m] → Stmt m ω Γ Δ b c α → Stmt (ExceptT Unit m) ω Γ Δ b c α</span></span></div></blockquote></div></small></div><span class="nv">L</span></span><span class="alectryon-token"> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Monad</var><b>: </b><span>(Type ?u.255179 → Type ?u.255178) → Type (max (?u.255179 + 1) ?u.255178)</span></span></div></blockquote></div></small></div>Monad</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>Type → Type u_1</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token">] : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt</var><b>: </b><span>(Type → Type u_1) → Type → List Type → List Type → Bool → Bool → Type → Type (max 1 u_1)</span></span></div></blockquote></div></small></div>Stmt</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>Type → Type u_1</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ω</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">ω</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Γ</var><b>: </b><span>List Type</span></span></div></blockquote></div></small></div><span class="nv">Γ</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Δ</var><b>: </b><span>List Type</span></span></div></blockquote></div></small></div><span class="nv">Δ</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>c</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div><span class="nv">c</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt</var><b>: </b><span>(Type → Type u_1) → Type → List Type → List Type → Bool → Bool → Type → Type (max 1 u_1)</span></span></div></blockquote></div></small></div>Stmt</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ExceptT</var><b>: </b><span>Type → (Type → Type u_1) → Type → Type u_1</span></span></div></blockquote></div></small></div>ExceptT</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Unit</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Unit</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>Type → Type u_1</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token">) </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ω</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">ω</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Γ</var><b>: </b><span>List Type</span></span></div></blockquote></div></small></div><span class="nv">Γ</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Δ</var><b>: </b><span>List Type</span></span></div></blockquote></div></small></div><span class="nv">Δ</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>c</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div><span class="nv">c</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token">
<span class="c">/-</span><span class="cm">(L1)-/</span> <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt.sbreak</var><b>: </b><span>{m : Type → Type ?u.256306} → {ω : Type} → {Γ Δ : List Type} → {c : Bool} → {α : Type} → Stmt m ω Γ Δ true c α</span></span></div></blockquote></div></small></div>Stmt.sbreak</span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt.sbreak</var><b>: </b><span>{m : Type → Type u_1} → {ω : Type} → {Γ Δ : List Type} → {c : Bool} → {α : Type} → Stmt m ω Γ Δ true c α</span></span></div></blockquote></div></small></div>Stmt.sbreak</span><span class="alectryon-token">
<span class="c">/-</span><span class="cm">(L2)-/</span> <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt.scont</var><b>: </b><span>{m : Type → Type ?u.256353} → {ω : Type} → {Γ Δ : List Type} → {b : Bool} → {α : Type} → Stmt m ω Γ Δ b true α</span></span></div></blockquote></div></small></div>Stmt.scont</span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt.scont</var><b>: </b><span>{m : Type → Type u_1} → {ω : Type} → {Γ Δ : List Type} → {b : Bool} → {α : Type} → Stmt m ω Γ Δ b true α</span></span></div></blockquote></div></small></div>Stmt.scont</span><span class="alectryon-token">
<span class="c">/-</span><span class="cm">(L3)-/</span> <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt.expr</var><b>: </b><span>{m : Type → Type ?u.256399} →
  {ω : Type} → {Γ Δ : List Type} → {α : Type} → {b c : Bool} → (Assg Γ → Assg Δ → m α) → Stmt m ω Γ Δ b c α</span></span></div></blockquote></div></small></div>Stmt.expr</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>Assg Γ → Assg Δ → m α</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt.expr</var><b>: </b><span>{m : Type → Type u_1} →
  {ω : Type} → {Γ Δ : List Type} → {α : Type} → {b c : Bool} → (Assg Γ → Assg Δ → m α) → Stmt m ω Γ Δ b c α</span></span></div></blockquote></div></small></div>Stmt.expr</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ExceptT.lift</var><b>: </b><span>{ε : Type} → {m : Type → Type u_1} → [inst : Monad m] → {α : Type} → m α → ExceptT ε m α</span></span></div></blockquote></div></small></div>ExceptT.lift</span><span class="alectryon-token"> <span class="bp">∘ₑ</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>Assg Γ → Assg Δ → m α</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token">)
<span class="c">/-</span><span class="cm">(L4)-/</span> <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt.bind</var><b>: </b><span>{m : Type → Type ?u.256604} →
  {ω : Type} →
    {Γ Δ : List Type} →
      {b c : Bool} → {α β : Type} → Stmt m ω Γ Δ b c α → Stmt m ω (α :: Γ) Δ b c β → Stmt m ω Γ Δ b c β</span></span></div></blockquote></div></small></div>Stmt.bind</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>Stmt m ω Γ Δ b c α✝</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s'</var><b>: </b><span>Stmt m ω (α✝ :: Γ) Δ b c α</span></span></div></blockquote></div></small></div><span class="nv">s&#39;</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt.bind</var><b>: </b><span>{m : Type → Type u_1} →
  {ω : Type} →
    {Γ Δ : List Type} →
      {b c : Bool} → {α β : Type} → Stmt m ω Γ Δ b c α → Stmt m ω (α :: Γ) Δ b c β → Stmt m ω Γ Δ b c β</span></span></div></blockquote></div></small></div>Stmt.bind</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>L</var><b>: </b><span>{m : Type → Type u_1} →
  {ω : Type} →
    {Γ Δ : List Type} →
      {b c : Bool} → {α : Type} → [inst : Monad m] → Stmt m ω Γ Δ b c α → Stmt (ExceptT Unit m) ω Γ Δ b c α</span></span></div></blockquote></div></small></div><span class="nv">L</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>Stmt m ω Γ Δ b c α✝</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token">) (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>L</var><b>: </b><span>{m : Type → Type u_1} →
  {ω : Type} →
    {Γ Δ : List Type} →
      {b c : Bool} → {α : Type} → [inst : Monad m] → Stmt m ω Γ Δ b c α → Stmt (ExceptT Unit m) ω Γ Δ b c α</span></span></div></blockquote></div></small></div><span class="nv">L</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s'</var><b>: </b><span>Stmt m ω (α✝ :: Γ) Δ b c α</span></span></div></blockquote></div></small></div><span class="nv">s&#39;</span></span><span class="alectryon-token">)
<span class="c">/-</span><span class="cm">(L5)-/</span> <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt.letmut</var><b>: </b><span>{m : Type → Type ?u.256701} →
  {ω : Type} →
    {Γ Δ : List Type} →
      {α : Type} → {b c : Bool} → {β : Type} → (Assg Γ → Assg Δ → α) → Stmt m ω Γ (α :: Δ) b c β → Stmt m ω Γ Δ b c β</span></span></div></blockquote></div></small></div>Stmt.letmut</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>Assg Γ → Assg Δ → α✝</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>Stmt m ω Γ (α✝ :: Δ) b c α</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt.letmut</var><b>: </b><span>{m : Type → Type u_1} →
  {ω : Type} →
    {Γ Δ : List Type} →
      {α : Type} → {b c : Bool} → {β : Type} → (Assg Γ → Assg Δ → α) → Stmt m ω Γ (α :: Δ) b c β → Stmt m ω Γ Δ b c β</span></span></div></blockquote></div></small></div>Stmt.letmut</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>Assg Γ → Assg Δ → α✝</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>L</var><b>: </b><span>{m : Type → Type u_1} →
  {ω : Type} →
    {Γ Δ : List Type} →
      {b c : Bool} → {α : Type} → [inst : Monad m] → Stmt m ω Γ Δ b c α → Stmt (ExceptT Unit m) ω Γ Δ b c α</span></span></div></blockquote></div></small></div><span class="nv">L</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>Stmt m ω Γ (α✝ :: Δ) b c α</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token">)
<span class="c">/-</span><span class="cm">(L6)-/</span> <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt.assg</var><b>: </b><span>{m : Type → Type ?u.256803} →
  {ω : Type} →
    {Γ Δ : List Type} →
      {b c : Bool} → (x : Fin (List.length Δ)) → (Assg Γ → Assg Δ → List.get Δ x) → Stmt m ω Γ Δ b c Unit</span></span></div></blockquote></div></small></div>Stmt.assg</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>Fin (List.length Δ)</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>Assg Γ → Assg Δ → List.get Δ x</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt.assg</var><b>: </b><span>{m : Type → Type u_1} →
  {ω : Type} →
    {Γ Δ : List Type} →
      {b c : Bool} → (x : Fin (List.length Δ)) → (Assg Γ → Assg Δ → List.get Δ x) → Stmt m ω Γ Δ b c Unit</span></span></div></blockquote></div></small></div>Stmt.assg</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>Fin (List.length Δ)</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>Assg Γ → Assg Δ → List.get Δ x</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token">
<span class="c">/-</span><span class="cm">(L7)-/</span> <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt.ite</var><b>: </b><span>{m : Type → Type ?u.256899} →
  {ω : Type} →
    {Γ Δ : List Type} →
      {b c : Bool} →
        {α : Type} → (Assg Γ → Assg Δ → Bool) → Stmt m ω Γ Δ b c α → Stmt m ω Γ Δ b c α → Stmt m ω Γ Δ b c α</span></span></div></blockquote></div></small></div>Stmt.ite</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>Assg Γ → Assg Δ → Bool</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s₁</var><b>: </b><span>Stmt m ω Γ Δ b c α</span></span></div></blockquote></div></small></div><span class="nv">s₁</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s₂</var><b>: </b><span>Stmt m ω Γ Δ b c α</span></span></div></blockquote></div></small></div><span class="nv">s₂</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt.ite</var><b>: </b><span>{m : Type → Type u_1} →
  {ω : Type} →
    {Γ Δ : List Type} →
      {b c : Bool} →
        {α : Type} → (Assg Γ → Assg Δ → Bool) → Stmt m ω Γ Δ b c α → Stmt m ω Γ Δ b c α → Stmt m ω Γ Δ b c α</span></span></div></blockquote></div></small></div>Stmt.ite</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>Assg Γ → Assg Δ → Bool</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>L</var><b>: </b><span>{m : Type → Type u_1} →
  {ω : Type} →
    {Γ Δ : List Type} →
      {b c : Bool} → {α : Type} → [inst : Monad m] → Stmt m ω Γ Δ b c α → Stmt (ExceptT Unit m) ω Γ Δ b c α</span></span></div></blockquote></div></small></div><span class="nv">L</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s₁</var><b>: </b><span>Stmt m ω Γ Δ b c α</span></span></div></blockquote></div></small></div><span class="nv">s₁</span></span><span class="alectryon-token">) (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>L</var><b>: </b><span>{m : Type → Type u_1} →
  {ω : Type} →
    {Γ Δ : List Type} →
      {b c : Bool} → {α : Type} → [inst : Monad m] → Stmt m ω Γ Δ b c α → Stmt (ExceptT Unit m) ω Γ Δ b c α</span></span></div></blockquote></div></small></div><span class="nv">L</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s₂</var><b>: </b><span>Stmt m ω Γ Δ b c α</span></span></div></blockquote></div></small></div><span class="nv">s₂</span></span><span class="alectryon-token">)
         <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt.ret</var><b>: </b><span>{m : Type → Type ?u.257003} →
  {ω : Type} → {Γ Δ : List Type} → {b c : Bool} → {α : Type} → (Assg Γ → Assg Δ → ω) → Stmt m ω Γ Δ b c α</span></span></div></blockquote></div></small></div>Stmt.ret</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>Assg Γ → Assg Δ → ω</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt.ret</var><b>: </b><span>{m : Type → Type u_1} →
  {ω : Type} → {Γ Δ : List Type} → {b c : Bool} → {α : Type} → (Assg Γ → Assg Δ → ω) → Stmt m ω Γ Δ b c α</span></span></div></blockquote></div></small></div>Stmt.ret</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>Assg Γ → Assg Δ → ω</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token">
<span class="c">/-</span><span class="cm">(L8)-/</span> <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt.sfor</var><b>: </b><span>{m : Type → Type ?u.257074} →
  {ω : Type} →
    {Γ Δ : List Type} →
      {α : Type} →
        {b c : Bool} → (Assg Γ → Assg Δ → List α) → Stmt m ω (α :: Γ) Δ true true Unit → Stmt m ω Γ Δ b c Unit</span></span></div></blockquote></div></small></div>Stmt.sfor</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>Assg Γ → Assg Δ → List α✝</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>Stmt m ω (α✝ :: Γ) Δ true true Unit</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt.sfor</var><b>: </b><span>{m : Type → Type u_1} →
  {ω : Type} →
    {Γ Δ : List Type} →
      {α : Type} →
        {b c : Bool} → (Assg Γ → Assg Δ → List α) → Stmt m ω (α :: Γ) Δ true true Unit → Stmt m ω Γ Δ b c Unit</span></span></div></blockquote></div></small></div>Stmt.sfor</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>Assg Γ → Assg Δ → List α✝</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>L</var><b>: </b><span>{m : Type → Type u_1} →
  {ω : Type} →
    {Γ Δ : List Type} →
      {b c : Bool} → {α : Type} → [inst : Monad m] → Stmt m ω Γ Δ b c α → Stmt (ExceptT Unit m) ω Γ Δ b c α</span></span></div></blockquote></div></small></div><span class="nv">L</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>Stmt m ω (α✝ :: Γ) Δ true true Unit</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token">)

<span class="bp">@</span>[</span><span class="alectryon-token"><span class="k">simp</span></span><span class="alectryon-token">] </span><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>B</var><b>: </b><span>{m : Type → Type u_1} →
  {ω : Type} →
    {Γ Δ : List Type} →
      {b c : Bool} → {α : Type} → [inst : Monad m] → Stmt m ω Γ Δ b c α → Stmt (ExceptT Unit m) ω Γ Δ false c α</span></span></div></blockquote></div></small></div><span class="nv">B</span></span><span class="alectryon-token"> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Monad</var><b>: </b><span>(Type ?u.268935 → Type ?u.268934) → Type (max (?u.268935 + 1) ?u.268934)</span></span></div></blockquote></div></small></div>Monad</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>Type → Type u_1</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token">] : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt</var><b>: </b><span>(Type → Type u_1) → Type → List Type → List Type → Bool → Bool → Type → Type (max 1 u_1)</span></span></div></blockquote></div></small></div>Stmt</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>Type → Type u_1</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ω</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">ω</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Γ</var><b>: </b><span>List Type</span></span></div></blockquote></div></small></div><span class="nv">Γ</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Δ</var><b>: </b><span>List Type</span></span></div></blockquote></div></small></div><span class="nv">Δ</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>c</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div><span class="nv">c</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt</var><b>: </b><span>(Type → Type u_1) → Type → List Type → List Type → Bool → Bool → Type → Type (max 1 u_1)</span></span></div></blockquote></div></small></div>Stmt</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ExceptT</var><b>: </b><span>Type → (Type → Type u_1) → Type → Type u_1</span></span></div></blockquote></div></small></div>ExceptT</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Unit</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Unit</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>Type → Type u_1</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token">) </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ω</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">ω</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Γ</var><b>: </b><span>List Type</span></span></div></blockquote></div></small></div><span class="nv">Γ</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Δ</var><b>: </b><span>List Type</span></span></div></blockquote></div></small></div><span class="nv">Δ</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>false</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div>false</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>c</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div><span class="nv">c</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token">
<span class="c">/-</span><span class="cm">(B1)-/</span> <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt.sbreak</var><b>: </b><span>{m : Type → Type ?u.270257} → {ω : Type} → {Γ Δ : List Type} → {c : Bool} → {α : Type} → Stmt m ω Γ Δ true c α</span></span></div></blockquote></div></small></div>Stmt.sbreak</span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt.expr</var><b>: </b><span>{m : Type → Type u_1} →
  {ω : Type} → {Γ Δ : List Type} → {α : Type} → {b c : Bool} → (Assg Γ → Assg Δ → m α) → Stmt m ω Γ Δ b c α</span></span></div></blockquote></div></small></div>Stmt.expr</span><span class="alectryon-token"> (</span><span class="alectryon-token"><span class="k">fun</span></span><span class="alectryon-token"> _ _ <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>throw</var><b>: </b><span>{ε : Type} → {m : Type → Type u_1} → [self : MonadExcept ε m] → {α : Type} → ε → m α</span></span></div></blockquote></div></small></div>throw</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>()</var><b>: </b><span>Unit</span></span></div></blockquote></div></small></div>()</span><span class="alectryon-token">)
<span class="c">/-</span><span class="cm">(B2)-/</span> <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt.scont</var><b>: </b><span>{m : Type → Type ?u.270390} → {ω : Type} → {Γ Δ : List Type} → {b : Bool} → {α : Type} → Stmt m ω Γ Δ b true α</span></span></div></blockquote></div></small></div>Stmt.scont</span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt.scont</var><b>: </b><span>{m : Type → Type u_1} → {ω : Type} → {Γ Δ : List Type} → {b : Bool} → {α : Type} → Stmt m ω Γ Δ b true α</span></span></div></blockquote></div></small></div>Stmt.scont</span><span class="alectryon-token">
<span class="c">/-</span><span class="cm">(B3)-/</span> <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt.expr</var><b>: </b><span>{m : Type → Type ?u.270436} →
  {ω : Type} → {Γ Δ : List Type} → {α : Type} → {b c : Bool} → (Assg Γ → Assg Δ → m α) → Stmt m ω Γ Δ b c α</span></span></div></blockquote></div></small></div>Stmt.expr</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>Assg Γ → Assg Δ → m α</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt.expr</var><b>: </b><span>{m : Type → Type u_1} →
  {ω : Type} → {Γ Δ : List Type} → {α : Type} → {b c : Bool} → (Assg Γ → Assg Δ → m α) → Stmt m ω Γ Δ b c α</span></span></div></blockquote></div></small></div>Stmt.expr</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ExceptT.lift</var><b>: </b><span>{ε : Type} → {m : Type → Type u_1} → [inst : Monad m] → {α : Type} → m α → ExceptT ε m α</span></span></div></blockquote></div></small></div>ExceptT.lift</span><span class="alectryon-token"> <span class="bp">∘ₑ</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>Assg Γ → Assg Δ → m α</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token">)
<span class="c">/-</span><span class="cm">(B4)-/</span> <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt.bind</var><b>: </b><span>{m : Type → Type ?u.270641} →
  {ω : Type} →
    {Γ Δ : List Type} →
      {b c : Bool} → {α β : Type} → Stmt m ω Γ Δ b c α → Stmt m ω (α :: Γ) Δ b c β → Stmt m ω Γ Δ b c β</span></span></div></blockquote></div></small></div>Stmt.bind</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>Stmt m ω Γ Δ b c α✝</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s'</var><b>: </b><span>Stmt m ω (α✝ :: Γ) Δ b c α</span></span></div></blockquote></div></small></div><span class="nv">s&#39;</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt.bind</var><b>: </b><span>{m : Type → Type u_1} →
  {ω : Type} →
    {Γ Δ : List Type} →
      {b c : Bool} → {α β : Type} → Stmt m ω Γ Δ b c α → Stmt m ω (α :: Γ) Δ b c β → Stmt m ω Γ Δ b c β</span></span></div></blockquote></div></small></div>Stmt.bind</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>B</var><b>: </b><span>{m : Type → Type u_1} →
  {ω : Type} →
    {Γ Δ : List Type} →
      {b c : Bool} → {α : Type} → [inst : Monad m] → Stmt m ω Γ Δ b c α → Stmt (ExceptT Unit m) ω Γ Δ false c α</span></span></div></blockquote></div></small></div><span class="nv">B</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>Stmt m ω Γ Δ b c α✝</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token">) (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>B</var><b>: </b><span>{m : Type → Type u_1} →
  {ω : Type} →
    {Γ Δ : List Type} →
      {b c : Bool} → {α : Type} → [inst : Monad m] → Stmt m ω Γ Δ b c α → Stmt (ExceptT Unit m) ω Γ Δ false c α</span></span></div></blockquote></div></small></div><span class="nv">B</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s'</var><b>: </b><span>Stmt m ω (α✝ :: Γ) Δ b c α</span></span></div></blockquote></div></small></div><span class="nv">s&#39;</span></span><span class="alectryon-token">)
<span class="c">/-</span><span class="cm">(B5)-/</span> <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt.letmut</var><b>: </b><span>{m : Type → Type ?u.270738} →
  {ω : Type} →
    {Γ Δ : List Type} →
      {α : Type} → {b c : Bool} → {β : Type} → (Assg Γ → Assg Δ → α) → Stmt m ω Γ (α :: Δ) b c β → Stmt m ω Γ Δ b c β</span></span></div></blockquote></div></small></div>Stmt.letmut</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>Assg Γ → Assg Δ → α✝</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>Stmt m ω Γ (α✝ :: Δ) b c α</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt.letmut</var><b>: </b><span>{m : Type → Type u_1} →
  {ω : Type} →
    {Γ Δ : List Type} →
      {α : Type} → {b c : Bool} → {β : Type} → (Assg Γ → Assg Δ → α) → Stmt m ω Γ (α :: Δ) b c β → Stmt m ω Γ Δ b c β</span></span></div></blockquote></div></small></div>Stmt.letmut</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>Assg Γ → Assg Δ → α✝</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>B</var><b>: </b><span>{m : Type → Type u_1} →
  {ω : Type} →
    {Γ Δ : List Type} →
      {b c : Bool} → {α : Type} → [inst : Monad m] → Stmt m ω Γ Δ b c α → Stmt (ExceptT Unit m) ω Γ Δ false c α</span></span></div></blockquote></div></small></div><span class="nv">B</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>Stmt m ω Γ (α✝ :: Δ) b c α</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token">)
<span class="c">/-</span><span class="cm">(B6)-/</span> <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt.assg</var><b>: </b><span>{m : Type → Type ?u.270840} →
  {ω : Type} →
    {Γ Δ : List Type} →
      {b c : Bool} → (x : Fin (List.length Δ)) → (Assg Γ → Assg Δ → List.get Δ x) → Stmt m ω Γ Δ b c Unit</span></span></div></blockquote></div></small></div>Stmt.assg</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>Fin (List.length Δ)</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>Assg Γ → Assg Δ → List.get Δ x</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt.assg</var><b>: </b><span>{m : Type → Type u_1} →
  {ω : Type} →
    {Γ Δ : List Type} →
      {b c : Bool} → (x : Fin (List.length Δ)) → (Assg Γ → Assg Δ → List.get Δ x) → Stmt m ω Γ Δ b c Unit</span></span></div></blockquote></div></small></div>Stmt.assg</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>Fin (List.length Δ)</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>Assg Γ → Assg Δ → List.get Δ x</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token">
<span class="c">/-</span><span class="cm">(B7)-/</span> <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt.ite</var><b>: </b><span>{m : Type → Type ?u.270936} →
  {ω : Type} →
    {Γ Δ : List Type} →
      {b c : Bool} →
        {α : Type} → (Assg Γ → Assg Δ → Bool) → Stmt m ω Γ Δ b c α → Stmt m ω Γ Δ b c α → Stmt m ω Γ Δ b c α</span></span></div></blockquote></div></small></div>Stmt.ite</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>Assg Γ → Assg Δ → Bool</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s₁</var><b>: </b><span>Stmt m ω Γ Δ b c α</span></span></div></blockquote></div></small></div><span class="nv">s₁</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s₂</var><b>: </b><span>Stmt m ω Γ Δ b c α</span></span></div></blockquote></div></small></div><span class="nv">s₂</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt.ite</var><b>: </b><span>{m : Type → Type u_1} →
  {ω : Type} →
    {Γ Δ : List Type} →
      {b c : Bool} →
        {α : Type} → (Assg Γ → Assg Δ → Bool) → Stmt m ω Γ Δ b c α → Stmt m ω Γ Δ b c α → Stmt m ω Γ Δ b c α</span></span></div></blockquote></div></small></div>Stmt.ite</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>Assg Γ → Assg Δ → Bool</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>B</var><b>: </b><span>{m : Type → Type u_1} →
  {ω : Type} →
    {Γ Δ : List Type} →
      {b c : Bool} → {α : Type} → [inst : Monad m] → Stmt m ω Γ Δ b c α → Stmt (ExceptT Unit m) ω Γ Δ false c α</span></span></div></blockquote></div></small></div><span class="nv">B</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s₁</var><b>: </b><span>Stmt m ω Γ Δ b c α</span></span></div></blockquote></div></small></div><span class="nv">s₁</span></span><span class="alectryon-token">) (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>B</var><b>: </b><span>{m : Type → Type u_1} →
  {ω : Type} →
    {Γ Δ : List Type} →
      {b c : Bool} → {α : Type} → [inst : Monad m] → Stmt m ω Γ Δ b c α → Stmt (ExceptT Unit m) ω Γ Δ false c α</span></span></div></blockquote></div></small></div><span class="nv">B</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s₂</var><b>: </b><span>Stmt m ω Γ Δ b c α</span></span></div></blockquote></div></small></div><span class="nv">s₂</span></span><span class="alectryon-token">)
         <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt.ret</var><b>: </b><span>{m : Type → Type ?u.271040} →
  {ω : Type} → {Γ Δ : List Type} → {b c : Bool} → {α : Type} → (Assg Γ → Assg Δ → ω) → Stmt m ω Γ Δ b c α</span></span></div></blockquote></div></small></div>Stmt.ret</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>Assg Γ → Assg Δ → ω</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt.ret</var><b>: </b><span>{m : Type → Type u_1} →
  {ω : Type} → {Γ Δ : List Type} → {b c : Bool} → {α : Type} → (Assg Γ → Assg Δ → ω) → Stmt m ω Γ Δ b c α</span></span></div></blockquote></div></small></div>Stmt.ret</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>Assg Γ → Assg Δ → ω</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token">
<span class="c">/-</span><span class="cm">(B8)-/</span> <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt.sfor</var><b>: </b><span>{m : Type → Type ?u.271111} →
  {ω : Type} →
    {Γ Δ : List Type} →
      {α : Type} →
        {b c : Bool} → (Assg Γ → Assg Δ → List α) → Stmt m ω (α :: Γ) Δ true true Unit → Stmt m ω Γ Δ b c Unit</span></span></div></blockquote></div></small></div>Stmt.sfor</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>Assg Γ → Assg Δ → List α✝</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>Stmt m ω (α✝ :: Γ) Δ true true Unit</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt.sfor</var><b>: </b><span>{m : Type → Type u_1} →
  {ω : Type} →
    {Γ Δ : List Type} →
      {α : Type} →
        {b c : Bool} → (Assg Γ → Assg Δ → List α) → Stmt m ω (α :: Γ) Δ true true Unit → Stmt m ω Γ Δ b c Unit</span></span></div></blockquote></div></small></div>Stmt.sfor</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>Assg Γ → Assg Δ → List α✝</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>L</var><b>: </b><span>{m : Type → Type u_1} →
  {ω : Type} →
    {Γ Δ : List Type} →
      {b c : Bool} → {α : Type} → [inst : Monad m] → Stmt m ω Γ Δ b c α → Stmt (ExceptT Unit m) ω Γ Δ b c α</span></span></div></blockquote></div></small></div>L</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>Stmt m ω (α✝ :: Γ) Δ true true Unit</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token">)

<span class="c1">-- (elided in the paper)</span>
<span class="bp">@</span>[</span><span class="alectryon-token"><span class="k">simp</span></span><span class="alectryon-token">] </span><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>C</var><b>: </b><span>{m : Type → Type u_1} →
  {ω : Type} →
    {Γ Δ : List Type} →
      {c : Bool} → {α : Type} → [inst : Monad m] → Stmt m ω Γ Δ false c α → Stmt (ExceptT Unit m) ω Γ Δ false false α</span></span></div></blockquote></div></small></div><span class="nv">C</span></span><span class="alectryon-token"> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Monad</var><b>: </b><span>(Type ?u.277926 → Type ?u.277925) → Type (max (?u.277926 + 1) ?u.277925)</span></span></div></blockquote></div></small></div>Monad</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>Type → Type u_1</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token">] : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt</var><b>: </b><span>(Type → Type u_1) → Type → List Type → List Type → Bool → Bool → Type → Type (max 1 u_1)</span></span></div></blockquote></div></small></div>Stmt</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>Type → Type u_1</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ω</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">ω</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Γ</var><b>: </b><span>List Type</span></span></div></blockquote></div></small></div><span class="nv">Γ</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Δ</var><b>: </b><span>List Type</span></span></div></blockquote></div></small></div><span class="nv">Δ</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>false</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div>false</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>c</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div><span class="nv">c</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt</var><b>: </b><span>(Type → Type u_1) → Type → List Type → List Type → Bool → Bool → Type → Type (max 1 u_1)</span></span></div></blockquote></div></small></div>Stmt</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ExceptT</var><b>: </b><span>Type → (Type → Type u_1) → Type → Type u_1</span></span></div></blockquote></div></small></div>ExceptT</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Unit</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Unit</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>Type → Type u_1</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token">) </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ω</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">ω</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Γ</var><b>: </b><span>List Type</span></span></div></blockquote></div></small></div><span class="nv">Γ</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Δ</var><b>: </b><span>List Type</span></span></div></blockquote></div></small></div><span class="nv">Δ</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>false</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div>false</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>false</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div>false</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt.scont</var><b>: </b><span>{m : Type → Type ?u.278871} → {ω : Type} → {Γ Δ : List Type} → {b : Bool} → {α : Type} → Stmt m ω Γ Δ b true α</span></span></div></blockquote></div></small></div>Stmt.scont</span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt.expr</var><b>: </b><span>{m : Type → Type u_1} →
  {ω : Type} → {Γ Δ : List Type} → {α : Type} → {b c : Bool} → (Assg Γ → Assg Δ → m α) → Stmt m ω Γ Δ b c α</span></span></div></blockquote></div></small></div>Stmt.expr</span><span class="alectryon-token"> (</span><span class="alectryon-token"><span class="k">fun</span></span><span class="alectryon-token"> _ _ <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>throw</var><b>: </b><span>{ε : Type} → {m : Type → Type u_1} → [self : MonadExcept ε m] → {α : Type} → ε → m α</span></span></div></blockquote></div></small></div>throw</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>()</var><b>: </b><span>Unit</span></span></div></blockquote></div></small></div>()</span><span class="alectryon-token">)
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt.expr</var><b>: </b><span>{m : Type → Type ?u.278996} →
  {ω : Type} → {Γ Δ : List Type} → {α : Type} → {b c : Bool} → (Assg Γ → Assg Δ → m α) → Stmt m ω Γ Δ b c α</span></span></div></blockquote></div></small></div>Stmt.expr</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>Assg Γ → Assg Δ → m α</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt.expr</var><b>: </b><span>{m : Type → Type u_1} →
  {ω : Type} → {Γ Δ : List Type} → {α : Type} → {b c : Bool} → (Assg Γ → Assg Δ → m α) → Stmt m ω Γ Δ b c α</span></span></div></blockquote></div></small></div>Stmt.expr</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ExceptT.lift</var><b>: </b><span>{ε : Type} → {m : Type → Type u_1} → [inst : Monad m] → {α : Type} → m α → ExceptT ε m α</span></span></div></blockquote></div></small></div>ExceptT.lift</span><span class="alectryon-token"> <span class="bp">∘ₑ</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>Assg Γ → Assg Δ → m α</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token">)
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt.bind</var><b>: </b><span>{m : Type → Type ?u.279194} →
  {ω : Type} →
    {Γ Δ : List Type} →
      {b c : Bool} → {α β : Type} → Stmt m ω Γ Δ b c α → Stmt m ω (α :: Γ) Δ b c β → Stmt m ω Γ Δ b c β</span></span></div></blockquote></div></small></div>Stmt.bind</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>Stmt m ω Γ Δ false c α✝</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s'</var><b>: </b><span>Stmt m ω (α✝ :: Γ) Δ false c α</span></span></div></blockquote></div></small></div><span class="nv">s&#39;</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt.bind</var><b>: </b><span>{m : Type → Type u_1} →
  {ω : Type} →
    {Γ Δ : List Type} →
      {b c : Bool} → {α β : Type} → Stmt m ω Γ Δ b c α → Stmt m ω (α :: Γ) Δ b c β → Stmt m ω Γ Δ b c β</span></span></div></blockquote></div></small></div>Stmt.bind</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>C</var><b>: </b><span>{m : Type → Type u_1} →
  {ω : Type} →
    {Γ Δ : List Type} →
      {c : Bool} → {α : Type} → [inst : Monad m] → Stmt m ω Γ Δ false c α → Stmt (ExceptT Unit m) ω Γ Δ false false α</span></span></div></blockquote></div></small></div><span class="nv">C</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>Stmt m ω Γ Δ false c α✝</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token">) (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>C</var><b>: </b><span>{m : Type → Type u_1} →
  {ω : Type} →
    {Γ Δ : List Type} →
      {c : Bool} → {α : Type} → [inst : Monad m] → Stmt m ω Γ Δ false c α → Stmt (ExceptT Unit m) ω Γ Δ false false α</span></span></div></blockquote></div></small></div><span class="nv">C</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s'</var><b>: </b><span>Stmt m ω (α✝ :: Γ) Δ false c α</span></span></div></blockquote></div></small></div><span class="nv">s&#39;</span></span><span class="alectryon-token">)
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt.letmut</var><b>: </b><span>{m : Type → Type ?u.279281} →
  {ω : Type} →
    {Γ Δ : List Type} →
      {α : Type} → {b c : Bool} → {β : Type} → (Assg Γ → Assg Δ → α) → Stmt m ω Γ (α :: Δ) b c β → Stmt m ω Γ Δ b c β</span></span></div></blockquote></div></small></div>Stmt.letmut</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>Assg Γ → Assg Δ → α✝</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>Stmt m ω Γ (α✝ :: Δ) false c α</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt.letmut</var><b>: </b><span>{m : Type → Type u_1} →
  {ω : Type} →
    {Γ Δ : List Type} →
      {α : Type} → {b c : Bool} → {β : Type} → (Assg Γ → Assg Δ → α) → Stmt m ω Γ (α :: Δ) b c β → Stmt m ω Γ Δ b c β</span></span></div></blockquote></div></small></div>Stmt.letmut</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>Assg Γ → Assg Δ → α✝</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>C</var><b>: </b><span>{m : Type → Type u_1} →
  {ω : Type} →
    {Γ Δ : List Type} →
      {c : Bool} → {α : Type} → [inst : Monad m] → Stmt m ω Γ Δ false c α → Stmt (ExceptT Unit m) ω Γ Δ false false α</span></span></div></blockquote></div></small></div><span class="nv">C</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>Stmt m ω Γ (α✝ :: Δ) false c α</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token">)
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt.assg</var><b>: </b><span>{m : Type → Type ?u.279374} →
  {ω : Type} →
    {Γ Δ : List Type} →
      {b c : Bool} → (x : Fin (List.length Δ)) → (Assg Γ → Assg Δ → List.get Δ x) → Stmt m ω Γ Δ b c Unit</span></span></div></blockquote></div></small></div>Stmt.assg</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>Fin (List.length Δ)</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>Assg Γ → Assg Δ → List.get Δ x</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt.assg</var><b>: </b><span>{m : Type → Type u_1} →
  {ω : Type} →
    {Γ Δ : List Type} →
      {b c : Bool} → (x : Fin (List.length Δ)) → (Assg Γ → Assg Δ → List.get Δ x) → Stmt m ω Γ Δ b c Unit</span></span></div></blockquote></div></small></div>Stmt.assg</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>Fin (List.length Δ)</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>Assg Γ → Assg Δ → List.get Δ x</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt.ite</var><b>: </b><span>{m : Type → Type ?u.279463} →
  {ω : Type} →
    {Γ Δ : List Type} →
      {b c : Bool} →
        {α : Type} → (Assg Γ → Assg Δ → Bool) → Stmt m ω Γ Δ b c α → Stmt m ω Γ Δ b c α → Stmt m ω Γ Δ b c α</span></span></div></blockquote></div></small></div>Stmt.ite</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>Assg Γ → Assg Δ → Bool</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s₁</var><b>: </b><span>Stmt m ω Γ Δ false c α</span></span></div></blockquote></div></small></div><span class="nv">s₁</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s₂</var><b>: </b><span>Stmt m ω Γ Δ false c α</span></span></div></blockquote></div></small></div><span class="nv">s₂</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt.ite</var><b>: </b><span>{m : Type → Type u_1} →
  {ω : Type} →
    {Γ Δ : List Type} →
      {b c : Bool} →
        {α : Type} → (Assg Γ → Assg Δ → Bool) → Stmt m ω Γ Δ b c α → Stmt m ω Γ Δ b c α → Stmt m ω Γ Δ b c α</span></span></div></blockquote></div></small></div>Stmt.ite</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>Assg Γ → Assg Δ → Bool</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>C</var><b>: </b><span>{m : Type → Type u_1} →
  {ω : Type} →
    {Γ Δ : List Type} →
      {c : Bool} → {α : Type} → [inst : Monad m] → Stmt m ω Γ Δ false c α → Stmt (ExceptT Unit m) ω Γ Δ false false α</span></span></div></blockquote></div></small></div><span class="nv">C</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s₁</var><b>: </b><span>Stmt m ω Γ Δ false c α</span></span></div></blockquote></div></small></div><span class="nv">s₁</span></span><span class="alectryon-token">) (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>C</var><b>: </b><span>{m : Type → Type u_1} →
  {ω : Type} →
    {Γ Δ : List Type} →
      {c : Bool} → {α : Type} → [inst : Monad m] → Stmt m ω Γ Δ false c α → Stmt (ExceptT Unit m) ω Γ Δ false false α</span></span></div></blockquote></div></small></div><span class="nv">C</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s₂</var><b>: </b><span>Stmt m ω Γ Δ false c α</span></span></div></blockquote></div></small></div><span class="nv">s₂</span></span><span class="alectryon-token">)
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt.ret</var><b>: </b><span>{m : Type → Type ?u.279557} →
  {ω : Type} → {Γ Δ : List Type} → {b c : Bool} → {α : Type} → (Assg Γ → Assg Δ → ω) → Stmt m ω Γ Δ b c α</span></span></div></blockquote></div></small></div>Stmt.ret</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>Assg Γ → Assg Δ → ω</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt.ret</var><b>: </b><span>{m : Type → Type u_1} →
  {ω : Type} → {Γ Δ : List Type} → {b c : Bool} → {α : Type} → (Assg Γ → Assg Δ → ω) → Stmt m ω Γ Δ b c α</span></span></div></blockquote></div></small></div>Stmt.ret</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>Assg Γ → Assg Δ → ω</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt.sfor</var><b>: </b><span>{m : Type → Type ?u.279621} →
  {ω : Type} →
    {Γ Δ : List Type} →
      {α : Type} →
        {b c : Bool} → (Assg Γ → Assg Δ → List α) → Stmt m ω (α :: Γ) Δ true true Unit → Stmt m ω Γ Δ b c Unit</span></span></div></blockquote></div></small></div>Stmt.sfor</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>Assg Γ → Assg Δ → List α✝</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>Stmt m ω (α✝ :: Γ) Δ true true Unit</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt.sfor</var><b>: </b><span>{m : Type → Type u_1} →
  {ω : Type} →
    {Γ Δ : List Type} →
      {α : Type} →
        {b c : Bool} → (Assg Γ → Assg Δ → List α) → Stmt m ω (α :: Γ) Δ true true Unit → Stmt m ω Γ Δ b c Unit</span></span></div></blockquote></div></small></div>Stmt.sfor</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>Assg Γ → Assg Δ → List α✝</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>L</var><b>: </b><span>{m : Type → Type u_1} →
  {ω : Type} →
    {Γ Δ : List Type} →
      {b c : Bool} → {α : Type} → [inst : Monad m] → Stmt m ω Γ Δ b c α → Stmt (ExceptT Unit m) ω Γ Δ b c α</span></span></div></blockquote></div></small></div>L</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>Stmt m ω (α✝ :: Γ) Δ true true Unit</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token">)</span></span></pre>
<p>The remaining function to be translated is <code>D</code>, which is straightforward as well except for its termination proof,
as it recurses on the results of <code>S</code> (D3) and <code>C ∘ B</code> (D5). Because of rules (S2, S9) that introduce new bindings,
<code>S</code> may in fact increase the size of the input, and the same is true for <code>C</code> and <code>B</code> for the <code>sizeOf</code> function
automatically generated by Lean. Thus we introduce a new measure <code>numExts</code> that counts the number of special statements
on top of basic <code>do</code> notation and prove that all three functions do not increase the size according to that measure.
Because the rules (D3) and (D5) each eliminate such a special statement, it follows that <code>D</code> terminates because either
the number of special statements decreases in each case, or it remains the same and the total number of statements decreases.</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="bp">@</span>[</span><span class="alectryon-token"><span class="k">simp</span></span><span class="alectryon-token">] </span><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt.numExts</var><b>: </b><span>{m : Type → Type u_1} → {ω : Type} → {Γ Δ : List Type} → {b c : Bool} → {α : Type} → Stmt m ω Γ Δ b c α → Nat</span></span></div></blockquote></div></small></div><span class="nv">Stmt.numExts</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt</var><b>: </b><span>(Type → Type u_1) → Type → List Type → List Type → Bool → Bool → Type → Type (max 1 u_1)</span></span></div></blockquote></div></small></div>Stmt</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>Type → Type u_1</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ω</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">ω</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Γ</var><b>: </b><span>List Type</span></span></div></blockquote></div></small></div><span class="nv">Γ</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Δ</var><b>: </b><span>List Type</span></span></div></blockquote></div></small></div><span class="nv">Δ</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>c</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div><span class="nv">c</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Nat</span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>expr</var><b>: </b><span>{m : Type → Type ?u.314493} →
  {ω : Type} → {Γ Δ : List Type} → {α : Type} → {b c : Bool} → (Assg Γ → Assg Δ → m α) → Stmt m ω Γ Δ b c α</span></span></div></blockquote></div></small></div>expr</span><span class="alectryon-token"> _ <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>0</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">0</span></span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>bind</var><b>: </b><span>{m : Type → Type ?u.314556} →
  {ω : Type} →
    {Γ Δ : List Type} →
      {b c : Bool} → {α β : Type} → Stmt m ω Γ Δ b c α → Stmt m ω (α :: Γ) Δ b c β → Stmt m ω Γ Δ b c β</span></span></div></blockquote></div></small></div>bind</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s₁</var><b>: </b><span>Stmt m ω Γ Δ b c α✝</span></span></div></blockquote></div></small></div><span class="nv">s₁</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s₂</var><b>: </b><span>Stmt m ω (α✝ :: Γ) Δ b c α</span></span></div></blockquote></div></small></div><span class="nv">s₂</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s₁</var><b>: </b><span>Stmt m ω Γ Δ b c α✝</span></span></div></blockquote></div></small></div><span class="nv">s₁</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>numExts</var><b>: </b><span>{m : Type → Type u_1} → {ω : Type} → {Γ Δ : List Type} → {b c : Bool} → {α : Type} → Stmt m ω Γ Δ b c α → Nat</span></span></div></blockquote></div></small></div><span class="nv">numExts</span></span><span class="alectryon-token"> <span class="bp">+</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s₂</var><b>: </b><span>Stmt m ω (α✝ :: Γ) Δ b c α</span></span></div></blockquote></div></small></div><span class="nv">s₂</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>numExts</var><b>: </b><span>{m : Type → Type u_1} → {ω : Type} → {Γ Δ : List Type} → {b c : Bool} → {α : Type} → Stmt m ω Γ Δ b c α → Nat</span></span></div></blockquote></div></small></div><span class="nv">numExts</span></span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>letmut</var><b>: </b><span>{m : Type → Type ?u.314678} →
  {ω : Type} →
    {Γ Δ : List Type} →
      {α : Type} → {b c : Bool} → {β : Type} → (Assg Γ → Assg Δ → α) → Stmt m ω Γ (α :: Δ) b c β → Stmt m ω Γ Δ b c β</span></span></div></blockquote></div></small></div>letmut</span><span class="alectryon-token"> _ </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>Stmt m ω Γ (α✝ :: Δ) b c α</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>Stmt m ω Γ (α✝ :: Δ) b c α</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>numExts</var><b>: </b><span>{m : Type → Type u_1} → {ω : Type} → {Γ Δ : List Type} → {b c : Bool} → {α : Type} → Stmt m ω Γ Δ b c α → Nat</span></span></div></blockquote></div></small></div><span class="nv">numExts</span></span><span class="alectryon-token"> <span class="bp">+</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>1</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">1</span></span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>assg</var><b>: </b><span>{m : Type → Type ?u.314809} →
  {ω : Type} →
    {Γ Δ : List Type} →
      {b c : Bool} → (x : Fin (List.length Δ)) → (Assg Γ → Assg Δ → List.get Δ x) → Stmt m ω Γ Δ b c Unit</span></span></div></blockquote></div></small></div>assg</span><span class="alectryon-token"> _ _ <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>1</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">1</span></span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ite</var><b>: </b><span>{m : Type → Type ?u.314889} →
  {ω : Type} →
    {Γ Δ : List Type} →
      {b c : Bool} →
        {α : Type} → (Assg Γ → Assg Δ → Bool) → Stmt m ω Γ Δ b c α → Stmt m ω Γ Δ b c α → Stmt m ω Γ Δ b c α</span></span></div></blockquote></div></small></div>ite</span><span class="alectryon-token"> _ </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s₁</var><b>: </b><span>Stmt m ω Γ Δ b c α</span></span></div></blockquote></div></small></div><span class="nv">s₁</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s₂</var><b>: </b><span>Stmt m ω Γ Δ b c α</span></span></div></blockquote></div></small></div><span class="nv">s₂</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s₁</var><b>: </b><span>Stmt m ω Γ Δ b c α</span></span></div></blockquote></div></small></div><span class="nv">s₁</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>numExts</var><b>: </b><span>{m : Type → Type u_1} → {ω : Type} → {Γ Δ : List Type} → {b c : Bool} → {α : Type} → Stmt m ω Γ Δ b c α → Nat</span></span></div></blockquote></div></small></div><span class="nv">numExts</span></span><span class="alectryon-token"> <span class="bp">+</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s₂</var><b>: </b><span>Stmt m ω Γ Δ b c α</span></span></div></blockquote></div></small></div><span class="nv">s₂</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>numExts</var><b>: </b><span>{m : Type → Type u_1} → {ω : Type} → {Γ Δ : List Type} → {b c : Bool} → {α : Type} → Stmt m ω Γ Δ b c α → Nat</span></span></div></blockquote></div></small></div><span class="nv">numExts</span></span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ret</var><b>: </b><span>{m : Type → Type ?u.315027} →
  {ω : Type} → {Γ Δ : List Type} → {b c : Bool} → {α : Type} → (Assg Γ → Assg Δ → ω) → Stmt m ω Γ Δ b c α</span></span></div></blockquote></div></small></div>ret</span><span class="alectryon-token"> _ <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>1</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">1</span></span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>sfor</var><b>: </b><span>{m : Type → Type ?u.315088} →
  {ω : Type} →
    {Γ Δ : List Type} →
      {α : Type} →
        {b c : Bool} → (Assg Γ → Assg Δ → List α) → Stmt m ω (α :: Γ) Δ true true Unit → Stmt m ω Γ Δ b c Unit</span></span></div></blockquote></div></small></div>sfor</span><span class="alectryon-token"> _ </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>Stmt m ω (α✝ :: Γ) Δ true true Unit</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>Stmt m ω (α✝ :: Γ) Δ true true Unit</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>numExts</var><b>: </b><span>{m : Type → Type u_1} → {ω : Type} → {Γ Δ : List Type} → {b c : Bool} → {α : Type} → Stmt m ω Γ Δ b c α → Nat</span></span></div></blockquote></div></small></div><span class="nv">numExts</span></span><span class="alectryon-token"> <span class="bp">+</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>1</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">1</span></span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>sbreak</var><b>: </b><span>{m : Type → Type ?u.315212} → {ω : Type} → {Γ Δ : List Type} → {c : Bool} → {α : Type} → Stmt m ω Γ Δ true c α</span></span></div></blockquote></div></small></div>sbreak</span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>1</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">1</span></span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>scont</var><b>: </b><span>{m : Type → Type ?u.315254} → {ω : Type} → {Γ Δ : List Type} → {b : Bool} → {α : Type} → Stmt m ω Γ Δ b true α</span></span></div></blockquote></div></small></div>scont</span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>1</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">1</span></span><span class="alectryon-token">

<span class="bp">@</span>[</span><span class="alectryon-token"><span class="k">simp</span></span><span class="alectryon-token">] </span><span class="alectryon-token"><span class="kd">theorem</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt.numExts_mapAssg</var><b>: </b><span>∀ {Γ' Γ : List Type} {m : Type → Type u_1} {ω : Type} {Δ : List Type} {b c : Bool} {β : Type} (f : Assg Γ' → Assg Γ)
  (s : Stmt m ω Γ Δ b c β), numExts (mapAssg f s) = numExts s</span></span></div></blockquote></div></small></div><span class="nv">Stmt.numExts_mapAssg</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>Assg Γ' → Assg Γ</span></span></div></blockquote></div></small></div><span class="nv">f</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Assg</var><b>: </b><span>List Type → Type</span></span></div></blockquote></div></small></div>Assg</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Γ'</var><b>: </b><span>List Type</span></span></div></blockquote></div></small></div><span class="nv">Γ&#39;</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Assg</var><b>: </b><span>List Type → Type</span></span></div></blockquote></div></small></div>Assg</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Γ</var><b>: </b><span>List Type</span></span></div></blockquote></div></small></div><span class="nv">Γ</span></span><span class="alectryon-token">) (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>Stmt m ω Γ Δ b c β</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt</var><b>: </b><span>(Type → Type u_1) → Type → List Type → List Type → Bool → Bool → Type → Type (max 1 u_1)</span></span></div></blockquote></div></small></div>Stmt</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>Type → Type u_1</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ω</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">ω</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Γ</var><b>: </b><span>List Type</span></span></div></blockquote></div></small></div><span class="nv">Γ</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Δ</var><b>: </b><span>List Type</span></span></div></blockquote></div></small></div><span class="nv">Δ</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>c</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div><span class="nv">c</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>β</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">β</span></span><span class="alectryon-token">) : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>numExts</var><b>: </b><span>{m : Type → Type u_1} → {ω : Type} → {Γ Δ : List Type} → {b c : Bool} → {α : Type} → Stmt m ω Γ Δ b c α → Nat</span></span></div></blockquote></div></small></div>numExts</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>mapAssg</var><b>: </b><span>{Γ' Γ : List Type} →
  {m : Type → Type u_1} →
    {ω : Type} →
      {Δ : List Type} → {b c : Bool} → {β : Type} → (Assg Γ' → Assg Γ) → Stmt m ω Γ Δ b c β → Stmt m ω Γ' Δ b c β</span></span></div></blockquote></div></small></div>mapAssg</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>Assg Γ' → Assg Γ</span></span></div></blockquote></div></small></div><span class="nv">f</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>Stmt m ω Γ Δ b c β</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token">) <span class="bp">=</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>numExts</var><b>: </b><span>{m : Type → Type u_1} → {ω : Type} → {Γ Δ : List Type} → {b c : Bool} → {α : Type} → Stmt m ω Γ Δ b c α → Nat</span></span></div></blockquote></div></small></div>numExts</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>Stmt m ω Γ Δ b c β</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token"> := </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk0"><span class="alectryon-token"><span class="kd">by</span></span><span class="alectryon-token"></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Γ', Γ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>ω</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>b, c</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ&#39;</span> <span class="bp">→</span> Assg <span class="bp">Γ</span></span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>Stmt m ω <span class="bp">Γ</span> <span class="bp">Δ</span> b c β</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">numExts (mapAssg f s) <span class="bp">=</span> numExts s</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk1"><span class="alectryon-token"><span class="k">induction</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>Stmt m ω Γ Δ b c β</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">generalizing</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Γ'</var><b>: </b><span>List Type</span></span></div></blockquote></div></small></div><span class="nv">Γ&#39;</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Γ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>ω</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>b, c</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Γ✝, Δ✝</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>α✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b✝, c✝</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>e✝</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ✝</span> <span class="bp">→</span> Assg <span class="bp">Δ✝</span> <span class="bp">→</span> m α<span class="bp">✝</span></span></span></span><br><span><var>Γ'</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ&#39;</span> <span class="bp">→</span> Assg <span class="bp">Γ✝</span></span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">expr</span></span><div class="goal-conclusion">numExts (mapAssg f (expr e<span class="bp">✝</span>)) <span class="bp">=</span> numExts (expr e<span class="bp">✝</span>)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Formal-lean-chk2" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Γ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>ω</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>b, c</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Γ✝, Δ✝</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>b✝, c✝</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>α✝, β✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>s✝</var><span class="hyp-type"><b>: </b><span>Stmt m ω <span class="bp">Γ✝</span> <span class="bp">Δ✝</span> b<span class="bp">✝</span> c<span class="bp">✝</span> α<span class="bp">✝</span></span></span></span><br><span><var>s'✝</var><span class="hyp-type"><b>: </b><span>Stmt m ω (α<span class="bp">✝</span> :: <span class="bp">Γ✝</span>) <span class="bp">Δ✝</span> b<span class="bp">✝</span> c<span class="bp">✝</span> β<span class="bp">✝</span></span></span></span><br><span><var>Γ'</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ&#39;</span> <span class="bp">→</span> Assg <span class="bp">Γ✝</span></span></span></span><br></div><label class="goal-separator" for="Formal-lean-chk2"><hr><span class="goal-name">bind</span></label><div class="goal-conclusion">numExts (mapAssg f (bind s<span class="bp">✝</span> s&#39;<span class="bp">✝</span>)) <span class="bp">=</span> numExts (bind s<span class="bp">✝</span> s&#39;<span class="bp">✝</span>)</div></blockquote><input class="alectryon-extra-goal-toggle" id="Formal-lean-chk3" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Γ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>ω</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>b, c</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Γ✝, Δ✝</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>α✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b✝, c✝</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>β✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>e✝</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ✝</span> <span class="bp">→</span> Assg <span class="bp">Δ✝</span> <span class="bp">→</span> α<span class="bp">✝</span></span></span></span><br><span><var>s✝</var><span class="hyp-type"><b>: </b><span>Stmt m ω <span class="bp">Γ✝</span> (α<span class="bp">✝</span> :: <span class="bp">Δ✝</span>) b<span class="bp">✝</span> c<span class="bp">✝</span> β<span class="bp">✝</span></span></span></span><br><span><var>Γ'</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ&#39;</span> <span class="bp">→</span> Assg <span class="bp">Γ✝</span></span></span></span><br></div><label class="goal-separator" for="Formal-lean-chk3"><hr><span class="goal-name">letmut</span></label><div class="goal-conclusion">numExts (mapAssg f (letmut e<span class="bp">✝</span> s<span class="bp">✝</span>)) <span class="bp">=</span> numExts (letmut e<span class="bp">✝</span> s<span class="bp">✝</span>)</div></blockquote><input class="alectryon-extra-goal-toggle" id="Formal-lean-chk4" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Γ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>ω</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>b, c</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Γ✝, Δ✝</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>b✝, c✝</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>x✝</var><span class="hyp-type"><b>: </b><span>Fin (List.length <span class="bp">Δ✝</span>)</span></span></span><br><span><var>e✝</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ✝</span> <span class="bp">→</span> Assg <span class="bp">Δ✝</span> <span class="bp">→</span> List.get <span class="bp">Δ✝</span> x<span class="bp">✝</span></span></span></span><br><span><var>Γ'</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ&#39;</span> <span class="bp">→</span> Assg <span class="bp">Γ✝</span></span></span></span><br></div><label class="goal-separator" for="Formal-lean-chk4"><hr><span class="goal-name">assg</span></label><div class="goal-conclusion">numExts (mapAssg f (assg x<span class="bp">✝</span> e<span class="bp">✝</span>)) <span class="bp">=</span> numExts (assg x<span class="bp">✝</span> e<span class="bp">✝</span>)</div></blockquote><input class="alectryon-extra-goal-toggle" id="Formal-lean-chk5" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Γ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>ω</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>b, c</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Γ✝, Δ✝</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>b✝, c✝</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>α✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>e✝</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ✝</span> <span class="bp">→</span> Assg <span class="bp">Δ✝</span> <span class="bp">→</span> Bool</span></span></span><br><span><var>s₁✝, s₂✝</var><span class="hyp-type"><b>: </b><span>Stmt m ω <span class="bp">Γ✝</span> <span class="bp">Δ✝</span> b<span class="bp">✝</span> c<span class="bp">✝</span> α<span class="bp">✝</span></span></span></span><br><span><var>Γ'</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ&#39;</span> <span class="bp">→</span> Assg <span class="bp">Γ✝</span></span></span></span><br></div><label class="goal-separator" for="Formal-lean-chk5"><hr><span class="goal-name">ite</span></label><div class="goal-conclusion">numExts (mapAssg f (ite e<span class="bp">✝</span> s₁<span class="bp">✝</span> s₂<span class="bp">✝</span>)) <span class="bp">=</span> numExts (ite e<span class="bp">✝</span> s₁<span class="bp">✝</span> s₂<span class="bp">✝</span>)</div></blockquote><input class="alectryon-extra-goal-toggle" id="Formal-lean-chk6" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Γ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>ω</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>b, c</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Γ✝, Δ✝</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>b✝, c✝</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>α✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>e✝</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ✝</span> <span class="bp">→</span> Assg <span class="bp">Δ✝</span> <span class="bp">→</span> ω</span></span></span><br><span><var>Γ'</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ&#39;</span> <span class="bp">→</span> Assg <span class="bp">Γ✝</span></span></span></span><br></div><label class="goal-separator" for="Formal-lean-chk6"><hr><span class="goal-name">ret</span></label><div class="goal-conclusion">numExts (mapAssg f (ret e<span class="bp">✝</span>)) <span class="bp">=</span> numExts (ret e<span class="bp">✝</span>)</div></blockquote><input class="alectryon-extra-goal-toggle" id="Formal-lean-chk7" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Γ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>ω</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>b, c</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Γ✝, Δ✝</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>α✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b✝, c✝</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>e✝</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ✝</span> <span class="bp">→</span> Assg <span class="bp">Δ✝</span> <span class="bp">→</span> List α<span class="bp">✝</span></span></span></span><br><span><var>s✝</var><span class="hyp-type"><b>: </b><span>Stmt m ω (α<span class="bp">✝</span> :: <span class="bp">Γ✝</span>) <span class="bp">Δ✝</span> true true Unit</span></span></span><br><span><var>Γ'</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ&#39;</span> <span class="bp">→</span> Assg <span class="bp">Γ✝</span></span></span></span><br></div><label class="goal-separator" for="Formal-lean-chk7"><hr><span class="goal-name">sfor</span></label><div class="goal-conclusion">numExts (mapAssg f (sfor e<span class="bp">✝</span> s<span class="bp">✝</span>)) <span class="bp">=</span> numExts (sfor e<span class="bp">✝</span> s<span class="bp">✝</span>)</div></blockquote><input class="alectryon-extra-goal-toggle" id="Formal-lean-chk8" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Γ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>ω</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>b, c</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Γ✝, Δ✝</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>c✝</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>α✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Γ'</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ&#39;</span> <span class="bp">→</span> Assg <span class="bp">Γ✝</span></span></span></span><br></div><label class="goal-separator" for="Formal-lean-chk8"><hr><span class="goal-name">sbreak</span></label><div class="goal-conclusion">numExts (mapAssg f sbreak) <span class="bp">=</span> numExts sbreak</div></blockquote><input class="alectryon-extra-goal-toggle" id="Formal-lean-chk9" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Γ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>ω</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>b, c</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Γ✝, Δ✝</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>b✝</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>α✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Γ'</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ&#39;</span> <span class="bp">→</span> Assg <span class="bp">Γ✝</span></span></span></span><br></div><label class="goal-separator" for="Formal-lean-chk9"><hr><span class="goal-name">scont</span></label><div class="goal-conclusion">numExts (mapAssg f scont) <span class="bp">=</span> numExts scont</div></blockquote></div></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chka"><span class="alectryon-token"><span class="k">&lt;;&gt;</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Γ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>ω</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>b, c</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Γ✝, Δ✝</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>α✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b✝, c✝</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>e✝</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ✝</span> <span class="bp">→</span> Assg <span class="bp">Δ✝</span> <span class="bp">→</span> m α<span class="bp">✝</span></span></span></span><br><span><var>Γ'</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ&#39;</span> <span class="bp">→</span> Assg <span class="bp">Γ✝</span></span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">expr</span></span><div class="goal-conclusion">numExts (mapAssg f (expr e<span class="bp">✝</span>)) <span class="bp">=</span> numExts (expr e<span class="bp">✝</span>)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Formal-lean-chkb" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Γ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>ω</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>b, c</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Γ✝, Δ✝</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>b✝, c✝</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>α✝, β✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>s✝</var><span class="hyp-type"><b>: </b><span>Stmt m ω <span class="bp">Γ✝</span> <span class="bp">Δ✝</span> b<span class="bp">✝</span> c<span class="bp">✝</span> α<span class="bp">✝</span></span></span></span><br><span><var>s'✝</var><span class="hyp-type"><b>: </b><span>Stmt m ω (α<span class="bp">✝</span> :: <span class="bp">Γ✝</span>) <span class="bp">Δ✝</span> b<span class="bp">✝</span> c<span class="bp">✝</span> β<span class="bp">✝</span></span></span></span><br><span><var>Γ'</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ&#39;</span> <span class="bp">→</span> Assg <span class="bp">Γ✝</span></span></span></span><br></div><label class="goal-separator" for="Formal-lean-chkb"><hr><span class="goal-name">bind</span></label><div class="goal-conclusion">numExts (mapAssg f (bind s<span class="bp">✝</span> s&#39;<span class="bp">✝</span>)) <span class="bp">=</span> numExts (bind s<span class="bp">✝</span> s&#39;<span class="bp">✝</span>)</div></blockquote><input class="alectryon-extra-goal-toggle" id="Formal-lean-chkc" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Γ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>ω</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>b, c</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Γ✝, Δ✝</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>α✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b✝, c✝</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>β✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>e✝</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ✝</span> <span class="bp">→</span> Assg <span class="bp">Δ✝</span> <span class="bp">→</span> α<span class="bp">✝</span></span></span></span><br><span><var>s✝</var><span class="hyp-type"><b>: </b><span>Stmt m ω <span class="bp">Γ✝</span> (α<span class="bp">✝</span> :: <span class="bp">Δ✝</span>) b<span class="bp">✝</span> c<span class="bp">✝</span> β<span class="bp">✝</span></span></span></span><br><span><var>Γ'</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ&#39;</span> <span class="bp">→</span> Assg <span class="bp">Γ✝</span></span></span></span><br></div><label class="goal-separator" for="Formal-lean-chkc"><hr><span class="goal-name">letmut</span></label><div class="goal-conclusion">numExts (mapAssg f (letmut e<span class="bp">✝</span> s<span class="bp">✝</span>)) <span class="bp">=</span> numExts (letmut e<span class="bp">✝</span> s<span class="bp">✝</span>)</div></blockquote><input class="alectryon-extra-goal-toggle" id="Formal-lean-chkd" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Γ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>ω</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>b, c</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Γ✝, Δ✝</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>b✝, c✝</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>x✝</var><span class="hyp-type"><b>: </b><span>Fin (List.length <span class="bp">Δ✝</span>)</span></span></span><br><span><var>e✝</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ✝</span> <span class="bp">→</span> Assg <span class="bp">Δ✝</span> <span class="bp">→</span> List.get <span class="bp">Δ✝</span> x<span class="bp">✝</span></span></span></span><br><span><var>Γ'</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ&#39;</span> <span class="bp">→</span> Assg <span class="bp">Γ✝</span></span></span></span><br></div><label class="goal-separator" for="Formal-lean-chkd"><hr><span class="goal-name">assg</span></label><div class="goal-conclusion">numExts (mapAssg f (assg x<span class="bp">✝</span> e<span class="bp">✝</span>)) <span class="bp">=</span> numExts (assg x<span class="bp">✝</span> e<span class="bp">✝</span>)</div></blockquote><input class="alectryon-extra-goal-toggle" id="Formal-lean-chke" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Γ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>ω</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>b, c</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Γ✝, Δ✝</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>b✝, c✝</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>α✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>e✝</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ✝</span> <span class="bp">→</span> Assg <span class="bp">Δ✝</span> <span class="bp">→</span> Bool</span></span></span><br><span><var>s₁✝, s₂✝</var><span class="hyp-type"><b>: </b><span>Stmt m ω <span class="bp">Γ✝</span> <span class="bp">Δ✝</span> b<span class="bp">✝</span> c<span class="bp">✝</span> α<span class="bp">✝</span></span></span></span><br><span><var>Γ'</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ&#39;</span> <span class="bp">→</span> Assg <span class="bp">Γ✝</span></span></span></span><br></div><label class="goal-separator" for="Formal-lean-chke"><hr><span class="goal-name">ite</span></label><div class="goal-conclusion">numExts (mapAssg f (ite e<span class="bp">✝</span> s₁<span class="bp">✝</span> s₂<span class="bp">✝</span>)) <span class="bp">=</span> numExts (ite e<span class="bp">✝</span> s₁<span class="bp">✝</span> s₂<span class="bp">✝</span>)</div></blockquote><input class="alectryon-extra-goal-toggle" id="Formal-lean-chkf" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Γ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>ω</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>b, c</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Γ✝, Δ✝</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>b✝, c✝</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>α✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>e✝</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ✝</span> <span class="bp">→</span> Assg <span class="bp">Δ✝</span> <span class="bp">→</span> ω</span></span></span><br><span><var>Γ'</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ&#39;</span> <span class="bp">→</span> Assg <span class="bp">Γ✝</span></span></span></span><br></div><label class="goal-separator" for="Formal-lean-chkf"><hr><span class="goal-name">ret</span></label><div class="goal-conclusion">numExts (mapAssg f (ret e<span class="bp">✝</span>)) <span class="bp">=</span> numExts (ret e<span class="bp">✝</span>)</div></blockquote><input class="alectryon-extra-goal-toggle" id="Formal-lean-chk10" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Γ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>ω</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>b, c</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Γ✝, Δ✝</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>α✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b✝, c✝</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>e✝</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ✝</span> <span class="bp">→</span> Assg <span class="bp">Δ✝</span> <span class="bp">→</span> List α<span class="bp">✝</span></span></span></span><br><span><var>s✝</var><span class="hyp-type"><b>: </b><span>Stmt m ω (α<span class="bp">✝</span> :: <span class="bp">Γ✝</span>) <span class="bp">Δ✝</span> true true Unit</span></span></span><br><span><var>Γ'</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ&#39;</span> <span class="bp">→</span> Assg <span class="bp">Γ✝</span></span></span></span><br></div><label class="goal-separator" for="Formal-lean-chk10"><hr><span class="goal-name">sfor</span></label><div class="goal-conclusion">numExts (mapAssg f (sfor e<span class="bp">✝</span> s<span class="bp">✝</span>)) <span class="bp">=</span> numExts (sfor e<span class="bp">✝</span> s<span class="bp">✝</span>)</div></blockquote><input class="alectryon-extra-goal-toggle" id="Formal-lean-chk11" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Γ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>ω</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>b, c</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Γ✝, Δ✝</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>c✝</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>α✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Γ'</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ&#39;</span> <span class="bp">→</span> Assg <span class="bp">Γ✝</span></span></span></span><br></div><label class="goal-separator" for="Formal-lean-chk11"><hr><span class="goal-name">sbreak</span></label><div class="goal-conclusion">numExts (mapAssg f sbreak) <span class="bp">=</span> numExts sbreak</div></blockquote><input class="alectryon-extra-goal-toggle" id="Formal-lean-chk12" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Γ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>ω</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>b, c</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Γ✝, Δ✝</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>b✝</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>α✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Γ'</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ&#39;</span> <span class="bp">→</span> Assg <span class="bp">Γ✝</span></span></span></span><br></div><label class="goal-separator" for="Formal-lean-chk12"><hr><span class="goal-name">scont</span></label><div class="goal-conclusion">numExts (mapAssg f scont) <span class="bp">=</span> numExts scont</div></blockquote></div></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk13" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk13"><span class="alectryon-token"><span class="k">simp</span></span><span class="alectryon-token"> [<span class="bp">*</span>]</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">

</span><span class="alectryon-token"><span class="kd">theorem</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt.numExts_S</var><b>: </b><span>∀ {m : Type → Type} {ω : Type} {Γ Δ : List Type} {α : Type} {b c : Bool} {β : Type} [inst : Monad m]
  (s : Stmt m ω Γ (List.append Δ [α]) b c β), numExts (S s) ≤ numExts s</span></span></div></blockquote></div></small></div><span class="nv">Stmt.numExts_S</span></span><span class="alectryon-token"> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Monad</var><b>: </b><span>(Type ?u.330075 → Type ?u.330074) → Type (max (?u.330075 + 1) ?u.330074)</span></span></div></blockquote></div></small></div>Monad</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>Type → Type</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token">] (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>Stmt m ω Γ (List.append Δ [α]) b c β</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt</var><b>: </b><span>(Type → Type) → Type → List Type → List Type → Bool → Bool → Type → Type 1</span></span></div></blockquote></div></small></div>Stmt</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>Type → Type</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ω</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">ω</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Γ</var><b>: </b><span>List Type</span></span></div></blockquote></div></small></div><span class="nv">Γ</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Δ</var><b>: </b><span>List Type</span></span></div></blockquote></div></small></div><span class="nv">Δ</span></span><span class="alectryon-token"> <span class="bp">++</span> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token">]) </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>c</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div><span class="nv">c</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>β</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">β</span></span><span class="alectryon-token">) : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>numExts</var><b>: </b><span>{m : Type → Type} → {ω : Type} → {Γ Δ : List Type} → {b c : Bool} → {α : Type} → Stmt m ω Γ Δ b c α → Nat</span></span></div></blockquote></div></small></div>numExts</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>S</var><b>: </b><span>{m : Type → Type} →
  {ω : Type} →
    {Γ Δ : List Type} →
      {α : Type} →
        {b c : Bool} →
          {β : Type} → [inst : Monad m] → Stmt m ω Γ (List.append Δ [α]) b c β → Stmt (StateT α m) ω (α :: Γ) Δ b c β</span></span></div></blockquote></div></small></div>S</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>Stmt m ω Γ (List.append Δ [α]) b c β</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token">) <span class="bp">≤</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>numExts</var><b>: </b><span>{m : Type → Type} → {ω : Type} → {Γ Δ : List Type} → {b c : Bool} → {α : Type} → Stmt m ω Γ Δ b c α → Nat</span></span></div></blockquote></div></small></div>numExts</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>Stmt m ω Γ (List.append Δ [α]) b c β</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token"> := </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk14" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk14"><span class="alectryon-token"><span class="kd">by</span></span><span class="alectryon-token">
  <span class="c1">-- `induction` does not work with non-variable indices, so we first generalize `Δ ++ [α]` into an explicit equation</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span></span></span></span><br><span><var>ω</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Γ, Δ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b, c</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>Stmt m ω <span class="bp">Γ</span> (List.append <span class="bp">Δ</span> [α]) b c β</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">numExts (S s) <span class="bp">≤</span> numExts s</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk15" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk15"><span class="alectryon-token"><span class="k">revert</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>Stmt m ω Γ (List.append Δ [α]) b c β</span></span></div></blockquote></div></small></div><span class="nv">s</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span></span></span></span><br><span><var>ω</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Γ, Δ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b, c</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="bp">∀</span> (s : Stmt m ω <span class="bp">Γ</span> (List.append <span class="bp">Δ</span> [α]) b c β), numExts (S s) <span class="bp">≤</span> numExts s</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk16" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk16"><span class="alectryon-token"><span class="k">suffices</span></span><span class="alectryon-token"> {</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Δ'</var><b>: </b><span>List Type</span></span></div></blockquote></div></small></div><span class="nv">Δ&#39;</span></span><span class="alectryon-token">: </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>_</var><b>: </b><span>Type 1</span></span></div></blockquote></div></small></div>_</span><span class="alectryon-token"> } <span class="bp">→</span> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>Stmt m ω Γ Δ' b c β</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt</var><b>: </b><span>(Type → Type) → Type → List Type → List Type → Bool → Bool → Type → Type 1</span></span></div></blockquote></div></small></div>Stmt</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>Type → Type</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ω</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">ω</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Γ</var><b>: </b><span>List Type</span></span></div></blockquote></div></small></div><span class="nv">Γ</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Δ'</var><b>: </b><span>List Type</span></span></div></blockquote></div></small></div><span class="nv">Δ&#39;</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>c</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div><span class="nv">c</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>β</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">β</span></span><span class="alectryon-token">) <span class="bp">→</span> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>h</var><b>: </b><span>Δ' = List.append Δ [α]</span></span></div></blockquote></div></small></div><span class="nv">h</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Δ'</var><b>: </b><span>List Type</span></span></div></blockquote></div></small></div><span class="nv">Δ&#39;</span></span><span class="alectryon-token"> <span class="bp">=</span> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Δ</var><b>: </b><span>List Type</span></span></div></blockquote></div></small></div><span class="nv">Δ</span></span><span class="alectryon-token"> <span class="bp">++</span> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token">])) <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>numExts</var><b>: </b><span>{m : Type → Type} → {ω : Type} → {Γ Δ : List Type} → {b c : Bool} → {α : Type} → Stmt m ω Γ Δ b c α → Nat</span></span></div></blockquote></div></small></div>numExts</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>S</var><b>: </b><span>{m : Type → Type} →
  {ω : Type} →
    {Γ Δ : List Type} →
      {α : Type} →
        {b c : Bool} →
          {β : Type} → [inst : Monad m] → Stmt m ω Γ (List.append Δ [α]) b c β → Stmt (StateT α m) ω (α :: Γ) Δ b c β</span></span></div></blockquote></div></small></div>S</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>h</var><b>: </b><span>Δ' = List.append Δ [α]</span></span></div></blockquote></div></small></div><span class="nv">h</span></span><span class="alectryon-token"> <span class="bp">▸</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>Stmt m ω Γ Δ' b c β</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt</var><b>: </b><span>(Type → Type) → Type → List Type → List Type → Bool → Bool → Type → Type 1</span></span></div></blockquote></div></small></div>Stmt</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>Type → Type</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ω</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">ω</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Γ</var><b>: </b><span>List Type</span></span></div></blockquote></div></small></div><span class="nv">Γ</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Δ</var><b>: </b><span>List Type</span></span></div></blockquote></div></small></div><span class="nv">Δ</span></span><span class="alectryon-token"> <span class="bp">++</span> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token">]) </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>c</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div><span class="nv">c</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>β</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">β</span></span><span class="alectryon-token">)) <span class="bp">≤</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>numExts</var><b>: </b><span>{m : Type → Type} → {ω : Type} → {Γ Δ : List Type} → {b c : Bool} → {α : Type} → Stmt m ω Γ Δ b c α → Nat</span></span></div></blockquote></div></small></div>numExts</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>Stmt m ω Γ Δ' b c β</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token">
    </span><span class="alectryon-token"><span class="k">from</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">fun</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>Stmt m ω Γ (List.append Δ [α]) b c β</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>this</var><b>: </b><span>∀ {Δ' : List Type} (s : Stmt m ω Γ Δ' b c β) (h : Δ' = List.append Δ [α]), numExts (S (h ▸ s)) ≤ numExts s</span></span></div></blockquote></div></small></div><span class="k">this</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>Stmt m ω Γ (List.append Δ [α]) b c β</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>rfl</var><b>: </b><span>∀ {α : Type 1} {a : α}, a = a</span></span></div></blockquote></div></small></div>rfl</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span></span></span></span><br><span><var>ω</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Γ, Δ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b, c</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="bp">∀</span> {<span class="bp">Δ&#39;</span> : List <span class="kt">Type</span>} (s : Stmt m ω <span class="bp">Γ</span> <span class="bp">Δ&#39;</span> b c β) (h : <span class="bp">Δ&#39;</span> <span class="bp">=</span> List.append <span class="bp">Δ</span> [α]), numExts (S (h <span class="bp">▸</span> s)) <span class="bp">≤</span> numExts s</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk17" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk17"><span class="alectryon-token"><span class="k">intro</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Δ'</var><b>: </b><span>List Type</span></span></div></blockquote></div></small></div><span class="nv">Δ&#39;</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>Stmt m ω Γ Δ' b c β</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>h</var><b>: </b><span>Δ' = List.append Δ [α]</span></span></div></blockquote></div></small></div><span class="nv">h</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span></span></span></span><br><span><var>ω</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Γ, Δ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b, c</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>Δ'</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>Stmt m ω <span class="bp">Γ</span> <span class="bp">Δ&#39;</span> b c β</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span><span class="bp">Δ&#39;</span> <span class="bp">=</span> List.append <span class="bp">Δ</span> [α]</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">numExts (S (h <span class="bp">▸</span> s)) <span class="bp">≤</span> numExts s</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk18" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk18"><span class="alectryon-token"><span class="k">induction</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>Stmt m ω Γ Δ' b c β</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">generalizing</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Δ</var><b>: </b><span>List Type</span></span></div></blockquote></div></small></div><span class="nv">Δ</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">with</span></span><span class="alectryon-token"></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span></span></span></span><br><span><var>ω</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Γ, Δ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b, c</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>Δ'</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>Stmt m ω <span class="bp">Γ</span> <span class="bp">Δ&#39;</span> b c β</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span><span class="bp">Δ&#39;</span> <span class="bp">=</span> List.append <span class="bp">Δ</span> [α]</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">numExts (S (h <span class="bp">▸</span> s)) <span class="bp">≤</span> numExts s</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
    </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk19" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk19"><span class="alectryon-token"><span class="k">subst</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>h</var><b>: </b><span>Δ✝ = List.append Δ [α]</span></span></div></blockquote></div></small></div><span class="nv">h</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span></span></span></span><br><span><var>ω</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b, c</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>Δ', Γ✝</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>α✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b✝, c✝</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>β✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>e✝</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ✝</span> <span class="bp">→</span> Assg (List.append <span class="bp">Δ</span> [α]) <span class="bp">→</span> α<span class="bp">✝</span></span></span></span><br><span><var>s✝</var><span class="hyp-type"><b>: </b><span>Stmt m ω <span class="bp">Γ✝</span> (α<span class="bp">✝</span> :: List.append <span class="bp">Δ</span> [α]) b<span class="bp">✝</span> c<span class="bp">✝</span> β<span class="bp">✝</span></span></span></span><br><span><var>ih</var><span class="hyp-type"><b>: </b><span><span class="bp">∀</span> {<span class="bp">Δ</span>_1 : List <span class="kt">Type</span>} (h : α<span class="bp">✝</span> :: List.append <span class="bp">Δ</span> [α] <span class="bp">=</span> List.append <span class="bp">Δ</span>_1 [α]), numExts (S (h <span class="bp">▸</span> s<span class="bp">✝</span>)) <span class="bp">≤</span> numExts s<span class="bp">✝</span></span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">letmut</span></span><div class="goal-conclusion">numExts (S ((_ : List.append <span class="bp">Δ</span> [α] <span class="bp">=</span> List.append <span class="bp">Δ</span> [α]) <span class="bp">▸</span> letmut e<span class="bp">✝</span> s<span class="bp">✝</span>)) <span class="bp">≤</span> numExts (letmut e<span class="bp">✝</span> s<span class="bp">✝</span>)</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk1a" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk1a"><span class="alectryon-token"><span class="bp">|</span> bind </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>_</var><b>: </b><span>Stmt m ω Γ✝ Δ✝ b✝ c✝ α✝</span></span></div></blockquote></div></small></div>_</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>_</var><b>: </b><span>Stmt m ω (α✝ :: Γ✝) Δ✝ b✝ c✝ β✝</span></span></div></blockquote></div></small></div>_</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ih₁</var><b>: </b><span>∀ {Δ : List Type} (h : Δ✝ = List.append Δ [α]), numExts (S (h ▸ s✝)) ≤ numExts s✝</span></span></div></blockquote></div></small></div><span class="nv">ih₁</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ih₂</var><b>: </b><span>∀ {Δ : List Type} (h : Δ✝ = List.append Δ [α]), numExts (S (h ▸ s'✝)) ≤ numExts s'✝</span></span></div></blockquote></div></small></div><span class="nv">ih₂</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span></span></span></span><br><span><var>ω</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b, c</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>Δ', Γ✝</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>b✝, c✝</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>α✝, β✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>s✝</var><span class="hyp-type"><b>: </b><span>Stmt m ω <span class="bp">Γ✝</span> (List.append <span class="bp">Δ</span> [α]) b<span class="bp">✝</span> c<span class="bp">✝</span> α<span class="bp">✝</span></span></span></span><br><span><var>s'✝</var><span class="hyp-type"><b>: </b><span>Stmt m ω (α<span class="bp">✝</span> :: <span class="bp">Γ✝</span>) (List.append <span class="bp">Δ</span> [α]) b<span class="bp">✝</span> c<span class="bp">✝</span> β<span class="bp">✝</span></span></span></span><br><span><var>ih₁</var><span class="hyp-type"><b>: </b><span><span class="bp">∀</span> {<span class="bp">Δ</span>_1 : List <span class="kt">Type</span>} (h : List.append <span class="bp">Δ</span> [α] <span class="bp">=</span> List.append <span class="bp">Δ</span>_1 [α]), numExts (S (h <span class="bp">▸</span> s<span class="bp">✝</span>)) <span class="bp">≤</span> numExts s<span class="bp">✝</span></span></span></span><br><span><var>ih₂</var><span class="hyp-type"><b>: </b><span><span class="bp">∀</span> {<span class="bp">Δ</span>_1 : List <span class="kt">Type</span>} (h : List.append <span class="bp">Δ</span> [α] <span class="bp">=</span> List.append <span class="bp">Δ</span>_1 [α]), numExts (S (h <span class="bp">▸</span> s&#39;<span class="bp">✝</span>)) <span class="bp">≤</span> numExts s&#39;<span class="bp">✝</span></span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">bind</span></span><div class="goal-conclusion">numExts (S ((_ : List.append <span class="bp">Δ</span> [α] <span class="bp">=</span> List.append <span class="bp">Δ</span> [α]) <span class="bp">▸</span> bind s<span class="bp">✝</span> s&#39;<span class="bp">✝</span>)) <span class="bp">≤</span> numExts (bind s<span class="bp">✝</span> s&#39;<span class="bp">✝</span>)</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk1b" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk1b"><span class="alectryon-token"><span class="k">simp</span></span><span class="alectryon-token"> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat.add_le_add</var><b>: </b><span>∀ {a b c d : Nat}, a ≤ b → c ≤ d → a + c ≤ b + d</span></span></div></blockquote></div></small></div>Nat.add_le_add</span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ih₁</var><b>: </b><span>∀ {Δ_1 : List Type} (h : List.append Δ [α] = List.append Δ_1 [α]), numExts (S (h ▸ s✝)) ≤ numExts s✝</span></span></div></blockquote></div></small></div><span class="nv">ih₁</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>rfl</var><b>: </b><span>∀ {α : Type 1} {a : α}, a = a</span></span></div></blockquote></div></small></div>rfl</span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ih₂</var><b>: </b><span>∀ {Δ_1 : List Type} (h : List.append Δ [α] = List.append Δ_1 [α]), numExts (S (h ▸ s'✝)) ≤ numExts s'✝</span></span></div></blockquote></div></small></div><span class="nv">ih₂</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>rfl</var><b>: </b><span>∀ {α : Type 1} {a : α}, a = a</span></span></div></blockquote></div></small></div>rfl</span><span class="alectryon-token">]</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk1c" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk1c"><span class="alectryon-token"><span class="bp">|</span> letmut </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>_</var><b>: </b><span>Assg Γ✝ → Assg Δ✝ → α✝</span></span></div></blockquote></div></small></div>_</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>_</var><b>: </b><span>Stmt m ω Γ✝ (α✝ :: Δ✝) b✝ c✝ β✝</span></span></div></blockquote></div></small></div>_</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ih</var><b>: </b><span>∀ {Δ : List Type} (h : α✝ :: Δ✝ = List.append Δ [α]), numExts (S (h ▸ s✝)) ≤ numExts s✝</span></span></div></blockquote></div></small></div><span class="nv">ih</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span></span></span></span><br><span><var>ω</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b, c</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>Δ', Γ✝</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>α✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b✝, c✝</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>β✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>e✝</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ✝</span> <span class="bp">→</span> Assg (List.append <span class="bp">Δ</span> [α]) <span class="bp">→</span> α<span class="bp">✝</span></span></span></span><br><span><var>s✝</var><span class="hyp-type"><b>: </b><span>Stmt m ω <span class="bp">Γ✝</span> (α<span class="bp">✝</span> :: List.append <span class="bp">Δ</span> [α]) b<span class="bp">✝</span> c<span class="bp">✝</span> β<span class="bp">✝</span></span></span></span><br><span><var>ih</var><span class="hyp-type"><b>: </b><span><span class="bp">∀</span> {<span class="bp">Δ</span>_1 : List <span class="kt">Type</span>} (h : α<span class="bp">✝</span> :: List.append <span class="bp">Δ</span> [α] <span class="bp">=</span> List.append <span class="bp">Δ</span>_1 [α]), numExts (S (h <span class="bp">▸</span> s<span class="bp">✝</span>)) <span class="bp">≤</span> numExts s<span class="bp">✝</span></span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">letmut</span></span><div class="goal-conclusion">numExts (S ((_ : List.append <span class="bp">Δ</span> [α] <span class="bp">=</span> List.append <span class="bp">Δ</span> [α]) <span class="bp">▸</span> letmut e<span class="bp">✝</span> s<span class="bp">✝</span>)) <span class="bp">≤</span> numExts (letmut e<span class="bp">✝</span> s<span class="bp">✝</span>)</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk1d" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk1d"><span class="alectryon-token"><span class="k">simp</span></span><span class="alectryon-token"> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat.add_le_add</var><b>: </b><span>∀ {a b c d : Nat}, a ≤ b → c ≤ d → a + c ≤ b + d</span></span></div></blockquote></div></small></div>Nat.add_le_add</span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ih</var><b>: </b><span>∀ {Δ_1 : List Type} (h : α✝ :: List.append Δ [α] = List.append Δ_1 [α]), numExts (S (h ▸ s✝)) ≤ numExts s✝</span></span></div></blockquote></div></small></div><span class="nv">ih</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>List.cons_append</var><b>: </b><span>∀ {α : Type 1} (a : α) (as bs : List α), a :: as ++ bs = a :: (as ++ bs)</span></span></div></blockquote></div></small></div>List.cons_append</span><span class="alectryon-token"> <span class="bp">..</span>)<span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>symm</var><b>: </b><span>∀ {α : Type 1} {a b : α}, a = b → b = a</span></span></div></blockquote></div></small></div><span class="na">symm</span></span><span class="alectryon-token">]</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk1e" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk1e"><span class="alectryon-token"><span class="bp">|</span> assg <span class="bp">=&gt;</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span></span></span></span><br><span><var>ω</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b, c</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>Δ', Γ✝</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>b✝, c✝</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>x✝</var><span class="hyp-type"><b>: </b><span>Fin (List.length (List.append <span class="bp">Δ</span> [α]))</span></span></span><br><span><var>e✝</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ✝</span> <span class="bp">→</span> Assg (List.append <span class="bp">Δ</span> [α]) <span class="bp">→</span> List.get (List.append <span class="bp">Δ</span> [α]) x<span class="bp">✝</span></span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">assg</span></span><div class="goal-conclusion">numExts (S ((_ : List.append <span class="bp">Δ</span> [α] <span class="bp">=</span> List.append <span class="bp">Δ</span> [α]) <span class="bp">▸</span> assg x<span class="bp">✝</span> e<span class="bp">✝</span>)) <span class="bp">≤</span> numExts (assg x<span class="bp">✝</span> e<span class="bp">✝</span>)</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk1f" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk1f"><span class="alectryon-token"><span class="k">aesop</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk20" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk20"><span class="alectryon-token"><span class="bp">|</span> ite </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>_</var><b>: </b><span>Assg Γ✝ → Assg Δ✝ → Bool</span></span></div></blockquote></div></small></div>_</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>_</var><b>: </b><span>Stmt m ω Γ✝ Δ✝ b✝ c✝ α✝</span></span></div></blockquote></div></small></div>_</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>_</var><b>: </b><span>Stmt m ω Γ✝ Δ✝ b✝ c✝ α✝</span></span></div></blockquote></div></small></div>_</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ih₁</var><b>: </b><span>∀ {Δ : List Type} (h : Δ✝ = List.append Δ [α]), numExts (S (h ▸ s₁✝)) ≤ numExts s₁✝</span></span></div></blockquote></div></small></div><span class="nv">ih₁</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ih₂</var><b>: </b><span>∀ {Δ : List Type} (h : Δ✝ = List.append Δ [α]), numExts (S (h ▸ s₂✝)) ≤ numExts s₂✝</span></span></div></blockquote></div></small></div><span class="nv">ih₂</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span></span></span></span><br><span><var>ω</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b, c</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>Δ', Γ✝</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>b✝, c✝</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>α✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>e✝</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ✝</span> <span class="bp">→</span> Assg (List.append <span class="bp">Δ</span> [α]) <span class="bp">→</span> Bool</span></span></span><br><span><var>s₁✝, s₂✝</var><span class="hyp-type"><b>: </b><span>Stmt m ω <span class="bp">Γ✝</span> (List.append <span class="bp">Δ</span> [α]) b<span class="bp">✝</span> c<span class="bp">✝</span> α<span class="bp">✝</span></span></span></span><br><span><var>ih₁</var><span class="hyp-type"><b>: </b><span><span class="bp">∀</span> {<span class="bp">Δ</span>_1 : List <span class="kt">Type</span>} (h : List.append <span class="bp">Δ</span> [α] <span class="bp">=</span> List.append <span class="bp">Δ</span>_1 [α]), numExts (S (h <span class="bp">▸</span> s₁<span class="bp">✝</span>)) <span class="bp">≤</span> numExts s₁<span class="bp">✝</span></span></span></span><br><span><var>ih₂</var><span class="hyp-type"><b>: </b><span><span class="bp">∀</span> {<span class="bp">Δ</span>_1 : List <span class="kt">Type</span>} (h : List.append <span class="bp">Δ</span> [α] <span class="bp">=</span> List.append <span class="bp">Δ</span>_1 [α]), numExts (S (h <span class="bp">▸</span> s₂<span class="bp">✝</span>)) <span class="bp">≤</span> numExts s₂<span class="bp">✝</span></span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">ite</span></span><div class="goal-conclusion">numExts (S ((_ : List.append <span class="bp">Δ</span> [α] <span class="bp">=</span> List.append <span class="bp">Δ</span> [α]) <span class="bp">▸</span> ite e<span class="bp">✝</span> s₁<span class="bp">✝</span> s₂<span class="bp">✝</span>)) <span class="bp">≤</span> numExts (ite e<span class="bp">✝</span> s₁<span class="bp">✝</span> s₂<span class="bp">✝</span>)</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk21" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk21"><span class="alectryon-token"><span class="k">simp</span></span><span class="alectryon-token"> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat.add_le_add</var><b>: </b><span>∀ {a b c d : Nat}, a ≤ b → c ≤ d → a + c ≤ b + d</span></span></div></blockquote></div></small></div>Nat.add_le_add</span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ih₁</var><b>: </b><span>∀ {Δ_1 : List Type} (h : List.append Δ [α] = List.append Δ_1 [α]), numExts (S (h ▸ s₁✝)) ≤ numExts s₁✝</span></span></div></blockquote></div></small></div><span class="nv">ih₁</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>rfl</var><b>: </b><span>∀ {α : Type 1} {a : α}, a = a</span></span></div></blockquote></div></small></div>rfl</span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ih₂</var><b>: </b><span>∀ {Δ_1 : List Type} (h : List.append Δ [α] = List.append Δ_1 [α]), numExts (S (h ▸ s₂✝)) ≤ numExts s₂✝</span></span></div></blockquote></div></small></div><span class="nv">ih₂</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>rfl</var><b>: </b><span>∀ {α : Type 1} {a : α}, a = a</span></span></div></blockquote></div></small></div>rfl</span><span class="alectryon-token">]</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk22" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk22"><span class="alectryon-token"><span class="bp">|</span> sfor </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>_</var><b>: </b><span>Assg Γ✝ → Assg Δ✝ → List α✝</span></span></div></blockquote></div></small></div>_</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>_</var><b>: </b><span>Stmt m ω (α✝ :: Γ✝) Δ✝ true true Unit</span></span></div></blockquote></div></small></div>_</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ih</var><b>: </b><span>∀ {Δ : List Type} (h : Δ✝ = List.append Δ [α]), numExts (S (h ▸ s✝)) ≤ numExts s✝</span></span></div></blockquote></div></small></div><span class="nv">ih</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span></span></span></span><br><span><var>ω</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b, c</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>Δ', Γ✝</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>α✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b✝, c✝</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>e✝</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ✝</span> <span class="bp">→</span> Assg (List.append <span class="bp">Δ</span> [α]) <span class="bp">→</span> List α<span class="bp">✝</span></span></span></span><br><span><var>s✝</var><span class="hyp-type"><b>: </b><span>Stmt m ω (α<span class="bp">✝</span> :: <span class="bp">Γ✝</span>) (List.append <span class="bp">Δ</span> [α]) true true Unit</span></span></span><br><span><var>ih</var><span class="hyp-type"><b>: </b><span><span class="bp">∀</span> {<span class="bp">Δ</span>_1 : List <span class="kt">Type</span>} (h : List.append <span class="bp">Δ</span> [α] <span class="bp">=</span> List.append <span class="bp">Δ</span>_1 [α]), numExts (S (h <span class="bp">▸</span> s<span class="bp">✝</span>)) <span class="bp">≤</span> numExts s<span class="bp">✝</span></span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">sfor</span></span><div class="goal-conclusion">numExts (S ((_ : List.append <span class="bp">Δ</span> [α] <span class="bp">=</span> List.append <span class="bp">Δ</span> [α]) <span class="bp">▸</span> sfor e<span class="bp">✝</span> s<span class="bp">✝</span>)) <span class="bp">≤</span> numExts (sfor e<span class="bp">✝</span> s<span class="bp">✝</span>)</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk23" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk23"><span class="alectryon-token"><span class="k">simp</span></span><span class="alectryon-token"> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat.add_le_add</var><b>: </b><span>∀ {a b c d : Nat}, a ≤ b → c ≤ d → a + c ≤ b + d</span></span></div></blockquote></div></small></div>Nat.add_le_add</span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ih</var><b>: </b><span>∀ {Δ_1 : List Type} (h : List.append Δ [α] = List.append Δ_1 [α]), numExts (S (h ▸ s✝)) ≤ numExts s✝</span></span></div></blockquote></div></small></div><span class="nv">ih</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>rfl</var><b>: </b><span>∀ {α : Type 1} {a : α}, a = a</span></span></div></blockquote></div></small></div>rfl</span><span class="alectryon-token">]</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk24" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk24"><span class="alectryon-token"><span class="bp">|</span> _ <span class="bp">=&gt;</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span></span></span></span><br><span><var>ω</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b, c</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>Δ', Γ✝</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>b✝, c✝</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>α✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>e✝</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ✝</span> <span class="bp">→</span> Assg (List.append <span class="bp">Δ</span> [α]) <span class="bp">→</span> ω</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">ret</span></span><div class="goal-conclusion">numExts (S ((_ : List.append <span class="bp">Δ</span> [α] <span class="bp">=</span> List.append <span class="bp">Δ</span> [α]) <span class="bp">▸</span> ret e<span class="bp">✝</span>)) <span class="bp">≤</span> numExts (ret e<span class="bp">✝</span>)</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk25" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk25"><span class="alectryon-token"><span class="k">simp</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">

</span><span class="alectryon-token"><span class="kd">theorem</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt.numExts_L_L</var><b>: </b><span>∀ {m : Type → Type u_1} {ω : Type} {Γ Δ : List Type} {b c : Bool} {β : Type} [inst : Monad m] (s : Stmt m ω Γ Δ b c β),
  numExts (L (L s)) ≤ numExts s</span></span></div></blockquote></div></small></div><span class="nv">Stmt.numExts_L_L</span></span><span class="alectryon-token"> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Monad</var><b>: </b><span>(Type ?u.339386 → Type ?u.339385) → Type (max (?u.339386 + 1) ?u.339385)</span></span></div></blockquote></div></small></div>Monad</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>Type → Type u_1</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token">] (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>Stmt m ω Γ Δ b c β</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt</var><b>: </b><span>(Type → Type u_1) → Type → List Type → List Type → Bool → Bool → Type → Type (max 1 u_1)</span></span></div></blockquote></div></small></div>Stmt</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>Type → Type u_1</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ω</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">ω</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Γ</var><b>: </b><span>List Type</span></span></div></blockquote></div></small></div><span class="nv">Γ</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Δ</var><b>: </b><span>List Type</span></span></div></blockquote></div></small></div><span class="nv">Δ</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>c</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div><span class="nv">c</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>β</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">β</span></span><span class="alectryon-token">) : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>numExts</var><b>: </b><span>{m : Type → Type u_1} → {ω : Type} → {Γ Δ : List Type} → {b c : Bool} → {α : Type} → Stmt m ω Γ Δ b c α → Nat</span></span></div></blockquote></div></small></div>numExts</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>L</var><b>: </b><span>{m : Type → Type u_1} →
  {ω : Type} →
    {Γ Δ : List Type} →
      {b c : Bool} → {α : Type} → [inst : Monad m] → Stmt m ω Γ Δ b c α → Stmt (ExceptT Unit m) ω Γ Δ b c α</span></span></div></blockquote></div></small></div>L</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>L</var><b>: </b><span>{m : Type → Type u_1} →
  {ω : Type} →
    {Γ Δ : List Type} →
      {b c : Bool} → {α : Type} → [inst : Monad m] → Stmt m ω Γ Δ b c α → Stmt (ExceptT Unit m) ω Γ Δ b c α</span></span></div></blockquote></div></small></div>L</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>Stmt m ω Γ Δ b c β</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token">)) <span class="bp">≤</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>numExts</var><b>: </b><span>{m : Type → Type u_1} → {ω : Type} → {Γ Δ : List Type} → {b c : Bool} → {α : Type} → Stmt m ω Γ Δ b c α → Nat</span></span></div></blockquote></div></small></div>numExts</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>Stmt m ω Γ Δ b c β</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token"> := </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk26" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk26"><span class="alectryon-token"><span class="kd">by</span></span><span class="alectryon-token"></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>ω</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Γ, Δ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>b, c</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>Stmt m ω <span class="bp">Γ</span> <span class="bp">Δ</span> b c β</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">numExts (L (L s)) <span class="bp">≤</span> numExts s</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk27" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk27"><span class="alectryon-token"><span class="k">induction</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>Stmt m ω Γ Δ b c β</span></span></div></blockquote></div></small></div><span class="nv">s</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>ω</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Γ, Δ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>b, c</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>Γ✝, Δ✝</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>α✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b✝, c✝</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>e✝</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ✝</span> <span class="bp">→</span> Assg <span class="bp">Δ✝</span> <span class="bp">→</span> m α<span class="bp">✝</span></span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">expr</span></span><div class="goal-conclusion">numExts (L (L (expr e<span class="bp">✝</span>))) <span class="bp">≤</span> numExts (expr e<span class="bp">✝</span>)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Formal-lean-chk28" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>ω</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Γ, Δ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>b, c</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>Γ✝, Δ✝</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>b✝, c✝</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>α✝, β✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>s✝</var><span class="hyp-type"><b>: </b><span>Stmt m ω <span class="bp">Γ✝</span> <span class="bp">Δ✝</span> b<span class="bp">✝</span> c<span class="bp">✝</span> α<span class="bp">✝</span></span></span></span><br><span><var>s'✝</var><span class="hyp-type"><b>: </b><span>Stmt m ω (α<span class="bp">✝</span> :: <span class="bp">Γ✝</span>) <span class="bp">Δ✝</span> b<span class="bp">✝</span> c<span class="bp">✝</span> β<span class="bp">✝</span></span></span></span><br></div><label class="goal-separator" for="Formal-lean-chk28"><hr><span class="goal-name">bind</span></label><div class="goal-conclusion">numExts (L (L (bind s<span class="bp">✝</span> s&#39;<span class="bp">✝</span>))) <span class="bp">≤</span> numExts (bind s<span class="bp">✝</span> s&#39;<span class="bp">✝</span>)</div></blockquote><input class="alectryon-extra-goal-toggle" id="Formal-lean-chk29" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>ω</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Γ, Δ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>b, c</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>Γ✝, Δ✝</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>α✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b✝, c✝</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>β✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>e✝</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ✝</span> <span class="bp">→</span> Assg <span class="bp">Δ✝</span> <span class="bp">→</span> α<span class="bp">✝</span></span></span></span><br><span><var>s✝</var><span class="hyp-type"><b>: </b><span>Stmt m ω <span class="bp">Γ✝</span> (α<span class="bp">✝</span> :: <span class="bp">Δ✝</span>) b<span class="bp">✝</span> c<span class="bp">✝</span> β<span class="bp">✝</span></span></span></span><br></div><label class="goal-separator" for="Formal-lean-chk29"><hr><span class="goal-name">letmut</span></label><div class="goal-conclusion">numExts (L (L (letmut e<span class="bp">✝</span> s<span class="bp">✝</span>))) <span class="bp">≤</span> numExts (letmut e<span class="bp">✝</span> s<span class="bp">✝</span>)</div></blockquote><input class="alectryon-extra-goal-toggle" id="Formal-lean-chk2a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>ω</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Γ, Δ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>b, c</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>Γ✝, Δ✝</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>b✝, c✝</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>x✝</var><span class="hyp-type"><b>: </b><span>Fin (List.length <span class="bp">Δ✝</span>)</span></span></span><br><span><var>e✝</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ✝</span> <span class="bp">→</span> Assg <span class="bp">Δ✝</span> <span class="bp">→</span> List.get <span class="bp">Δ✝</span> x<span class="bp">✝</span></span></span></span><br></div><label class="goal-separator" for="Formal-lean-chk2a"><hr><span class="goal-name">assg</span></label><div class="goal-conclusion">numExts (L (L (assg x<span class="bp">✝</span> e<span class="bp">✝</span>))) <span class="bp">≤</span> numExts (assg x<span class="bp">✝</span> e<span class="bp">✝</span>)</div></blockquote><input class="alectryon-extra-goal-toggle" id="Formal-lean-chk2b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>ω</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Γ, Δ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>b, c</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>Γ✝, Δ✝</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>b✝, c✝</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>α✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>e✝</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ✝</span> <span class="bp">→</span> Assg <span class="bp">Δ✝</span> <span class="bp">→</span> Bool</span></span></span><br><span><var>s₁✝, s₂✝</var><span class="hyp-type"><b>: </b><span>Stmt m ω <span class="bp">Γ✝</span> <span class="bp">Δ✝</span> b<span class="bp">✝</span> c<span class="bp">✝</span> α<span class="bp">✝</span></span></span></span><br></div><label class="goal-separator" for="Formal-lean-chk2b"><hr><span class="goal-name">ite</span></label><div class="goal-conclusion">numExts (L (L (ite e<span class="bp">✝</span> s₁<span class="bp">✝</span> s₂<span class="bp">✝</span>))) <span class="bp">≤</span> numExts (ite e<span class="bp">✝</span> s₁<span class="bp">✝</span> s₂<span class="bp">✝</span>)</div></blockquote><input class="alectryon-extra-goal-toggle" id="Formal-lean-chk2c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>ω</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Γ, Δ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>b, c</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>Γ✝, Δ✝</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>b✝, c✝</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>α✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>e✝</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ✝</span> <span class="bp">→</span> Assg <span class="bp">Δ✝</span> <span class="bp">→</span> ω</span></span></span><br></div><label class="goal-separator" for="Formal-lean-chk2c"><hr><span class="goal-name">ret</span></label><div class="goal-conclusion">numExts (L (L (ret e<span class="bp">✝</span>))) <span class="bp">≤</span> numExts (ret e<span class="bp">✝</span>)</div></blockquote><input class="alectryon-extra-goal-toggle" id="Formal-lean-chk2d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>ω</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Γ, Δ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>b, c</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>Γ✝, Δ✝</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>α✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b✝, c✝</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>e✝</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ✝</span> <span class="bp">→</span> Assg <span class="bp">Δ✝</span> <span class="bp">→</span> List α<span class="bp">✝</span></span></span></span><br><span><var>s✝</var><span class="hyp-type"><b>: </b><span>Stmt m ω (α<span class="bp">✝</span> :: <span class="bp">Γ✝</span>) <span class="bp">Δ✝</span> true true Unit</span></span></span><br></div><label class="goal-separator" for="Formal-lean-chk2d"><hr><span class="goal-name">sfor</span></label><div class="goal-conclusion">numExts (L (L (sfor e<span class="bp">✝</span> s<span class="bp">✝</span>))) <span class="bp">≤</span> numExts (sfor e<span class="bp">✝</span> s<span class="bp">✝</span>)</div></blockquote><input class="alectryon-extra-goal-toggle" id="Formal-lean-chk2e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>ω</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Γ, Δ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>b, c</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>Γ✝, Δ✝</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>c✝</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>α✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><label class="goal-separator" for="Formal-lean-chk2e"><hr><span class="goal-name">sbreak</span></label><div class="goal-conclusion">numExts (L (L sbreak)) <span class="bp">≤</span> numExts sbreak</div></blockquote><input class="alectryon-extra-goal-toggle" id="Formal-lean-chk2f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>ω</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Γ, Δ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>b, c</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>Γ✝, Δ✝</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>b✝</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>α✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><label class="goal-separator" for="Formal-lean-chk2f"><hr><span class="goal-name">scont</span></label><div class="goal-conclusion">numExts (L (L scont)) <span class="bp">≤</span> numExts scont</div></blockquote></div></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk30" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk30"><span class="alectryon-token"><span class="k">&lt;;&gt;</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>ω</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Γ, Δ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>b, c</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>Γ✝, Δ✝</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>α✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b✝, c✝</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>e✝</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ✝</span> <span class="bp">→</span> Assg <span class="bp">Δ✝</span> <span class="bp">→</span> m α<span class="bp">✝</span></span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">expr</span></span><div class="goal-conclusion">numExts (L (L (expr e<span class="bp">✝</span>))) <span class="bp">≤</span> numExts (expr e<span class="bp">✝</span>)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Formal-lean-chk31" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>ω</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Γ, Δ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>b, c</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>Γ✝, Δ✝</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>b✝, c✝</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>α✝, β✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>s✝</var><span class="hyp-type"><b>: </b><span>Stmt m ω <span class="bp">Γ✝</span> <span class="bp">Δ✝</span> b<span class="bp">✝</span> c<span class="bp">✝</span> α<span class="bp">✝</span></span></span></span><br><span><var>s'✝</var><span class="hyp-type"><b>: </b><span>Stmt m ω (α<span class="bp">✝</span> :: <span class="bp">Γ✝</span>) <span class="bp">Δ✝</span> b<span class="bp">✝</span> c<span class="bp">✝</span> β<span class="bp">✝</span></span></span></span><br></div><label class="goal-separator" for="Formal-lean-chk31"><hr><span class="goal-name">bind</span></label><div class="goal-conclusion">numExts (L (L (bind s<span class="bp">✝</span> s&#39;<span class="bp">✝</span>))) <span class="bp">≤</span> numExts (bind s<span class="bp">✝</span> s&#39;<span class="bp">✝</span>)</div></blockquote><input class="alectryon-extra-goal-toggle" id="Formal-lean-chk32" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>ω</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Γ, Δ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>b, c</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>Γ✝, Δ✝</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>α✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b✝, c✝</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>β✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>e✝</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ✝</span> <span class="bp">→</span> Assg <span class="bp">Δ✝</span> <span class="bp">→</span> α<span class="bp">✝</span></span></span></span><br><span><var>s✝</var><span class="hyp-type"><b>: </b><span>Stmt m ω <span class="bp">Γ✝</span> (α<span class="bp">✝</span> :: <span class="bp">Δ✝</span>) b<span class="bp">✝</span> c<span class="bp">✝</span> β<span class="bp">✝</span></span></span></span><br></div><label class="goal-separator" for="Formal-lean-chk32"><hr><span class="goal-name">letmut</span></label><div class="goal-conclusion">numExts (L (L (letmut e<span class="bp">✝</span> s<span class="bp">✝</span>))) <span class="bp">≤</span> numExts (letmut e<span class="bp">✝</span> s<span class="bp">✝</span>)</div></blockquote><input class="alectryon-extra-goal-toggle" id="Formal-lean-chk33" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>ω</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Γ, Δ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>b, c</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>Γ✝, Δ✝</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>b✝, c✝</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>x✝</var><span class="hyp-type"><b>: </b><span>Fin (List.length <span class="bp">Δ✝</span>)</span></span></span><br><span><var>e✝</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ✝</span> <span class="bp">→</span> Assg <span class="bp">Δ✝</span> <span class="bp">→</span> List.get <span class="bp">Δ✝</span> x<span class="bp">✝</span></span></span></span><br></div><label class="goal-separator" for="Formal-lean-chk33"><hr><span class="goal-name">assg</span></label><div class="goal-conclusion">numExts (L (L (assg x<span class="bp">✝</span> e<span class="bp">✝</span>))) <span class="bp">≤</span> numExts (assg x<span class="bp">✝</span> e<span class="bp">✝</span>)</div></blockquote><input class="alectryon-extra-goal-toggle" id="Formal-lean-chk34" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>ω</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Γ, Δ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>b, c</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>Γ✝, Δ✝</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>b✝, c✝</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>α✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>e✝</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ✝</span> <span class="bp">→</span> Assg <span class="bp">Δ✝</span> <span class="bp">→</span> Bool</span></span></span><br><span><var>s₁✝, s₂✝</var><span class="hyp-type"><b>: </b><span>Stmt m ω <span class="bp">Γ✝</span> <span class="bp">Δ✝</span> b<span class="bp">✝</span> c<span class="bp">✝</span> α<span class="bp">✝</span></span></span></span><br></div><label class="goal-separator" for="Formal-lean-chk34"><hr><span class="goal-name">ite</span></label><div class="goal-conclusion">numExts (L (L (ite e<span class="bp">✝</span> s₁<span class="bp">✝</span> s₂<span class="bp">✝</span>))) <span class="bp">≤</span> numExts (ite e<span class="bp">✝</span> s₁<span class="bp">✝</span> s₂<span class="bp">✝</span>)</div></blockquote><input class="alectryon-extra-goal-toggle" id="Formal-lean-chk35" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>ω</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Γ, Δ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>b, c</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>Γ✝, Δ✝</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>b✝, c✝</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>α✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>e✝</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ✝</span> <span class="bp">→</span> Assg <span class="bp">Δ✝</span> <span class="bp">→</span> ω</span></span></span><br></div><label class="goal-separator" for="Formal-lean-chk35"><hr><span class="goal-name">ret</span></label><div class="goal-conclusion">numExts (L (L (ret e<span class="bp">✝</span>))) <span class="bp">≤</span> numExts (ret e<span class="bp">✝</span>)</div></blockquote><input class="alectryon-extra-goal-toggle" id="Formal-lean-chk36" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>ω</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Γ, Δ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>b, c</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>Γ✝, Δ✝</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>α✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b✝, c✝</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>e✝</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ✝</span> <span class="bp">→</span> Assg <span class="bp">Δ✝</span> <span class="bp">→</span> List α<span class="bp">✝</span></span></span></span><br><span><var>s✝</var><span class="hyp-type"><b>: </b><span>Stmt m ω (α<span class="bp">✝</span> :: <span class="bp">Γ✝</span>) <span class="bp">Δ✝</span> true true Unit</span></span></span><br></div><label class="goal-separator" for="Formal-lean-chk36"><hr><span class="goal-name">sfor</span></label><div class="goal-conclusion">numExts (L (L (sfor e<span class="bp">✝</span> s<span class="bp">✝</span>))) <span class="bp">≤</span> numExts (sfor e<span class="bp">✝</span> s<span class="bp">✝</span>)</div></blockquote><input class="alectryon-extra-goal-toggle" id="Formal-lean-chk37" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>ω</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Γ, Δ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>b, c</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>Γ✝, Δ✝</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>c✝</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>α✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><label class="goal-separator" for="Formal-lean-chk37"><hr><span class="goal-name">sbreak</span></label><div class="goal-conclusion">numExts (L (L sbreak)) <span class="bp">≤</span> numExts sbreak</div></blockquote><input class="alectryon-extra-goal-toggle" id="Formal-lean-chk38" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>ω</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Γ, Δ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>b, c</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>Γ✝, Δ✝</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>b✝</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>α✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><label class="goal-separator" for="Formal-lean-chk38"><hr><span class="goal-name">scont</span></label><div class="goal-conclusion">numExts (L (L scont)) <span class="bp">≤</span> numExts scont</div></blockquote></div></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk39" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk39"><span class="alectryon-token"><span class="k">simp</span></span><span class="alectryon-token"> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat.add_le_add</var><b>: </b><span>∀ {a b c d : Nat}, a ≤ b → c ≤ d → a + c ≤ b + d</span></span></div></blockquote></div></small></div><span class="k">Nat.add_le_add</span></span><span class="alectryon-token">, <span class="bp">*</span>]</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">

</span><span class="alectryon-token"><span class="kd">theorem</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt.numExts_C_B</var><b>: </b><span>∀ {m : Type → Type u_1} {ω : Type} {Γ Δ : List Type} {b c : Bool} {β : Type} [inst : Monad m] (s : Stmt m ω Γ Δ b c β),
  numExts (C (B s)) ≤ numExts s</span></span></div></blockquote></div></small></div><span class="nv">Stmt.numExts_C_B</span></span><span class="alectryon-token"> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Monad</var><b>: </b><span>(Type ?u.342450 → Type ?u.342449) → Type (max (?u.342450 + 1) ?u.342449)</span></span></div></blockquote></div></small></div>Monad</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>Type → Type u_1</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token">] (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>Stmt m ω Γ Δ b c β</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt</var><b>: </b><span>(Type → Type u_1) → Type → List Type → List Type → Bool → Bool → Type → Type (max 1 u_1)</span></span></div></blockquote></div></small></div>Stmt</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>Type → Type u_1</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ω</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">ω</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Γ</var><b>: </b><span>List Type</span></span></div></blockquote></div></small></div><span class="nv">Γ</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Δ</var><b>: </b><span>List Type</span></span></div></blockquote></div></small></div><span class="nv">Δ</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>c</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div><span class="nv">c</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>β</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">β</span></span><span class="alectryon-token">) : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>numExts</var><b>: </b><span>{m : Type → Type u_1} → {ω : Type} → {Γ Δ : List Type} → {b c : Bool} → {α : Type} → Stmt m ω Γ Δ b c α → Nat</span></span></div></blockquote></div></small></div>numExts</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>C</var><b>: </b><span>{m : Type → Type u_1} →
  {ω : Type} →
    {Γ Δ : List Type} →
      {c : Bool} → {α : Type} → [inst : Monad m] → Stmt m ω Γ Δ false c α → Stmt (ExceptT Unit m) ω Γ Δ false false α</span></span></div></blockquote></div></small></div>C</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>B</var><b>: </b><span>{m : Type → Type u_1} →
  {ω : Type} →
    {Γ Δ : List Type} →
      {b c : Bool} → {α : Type} → [inst : Monad m] → Stmt m ω Γ Δ b c α → Stmt (ExceptT Unit m) ω Γ Δ false c α</span></span></div></blockquote></div></small></div>B</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>Stmt m ω Γ Δ b c β</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token">)) <span class="bp">≤</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>numExts</var><b>: </b><span>{m : Type → Type u_1} → {ω : Type} → {Γ Δ : List Type} → {b c : Bool} → {α : Type} → Stmt m ω Γ Δ b c α → Nat</span></span></div></blockquote></div></small></div>numExts</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>Stmt m ω Γ Δ b c β</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token"> := </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk3a" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk3a"><span class="alectryon-token"><span class="kd">by</span></span><span class="alectryon-token"></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>ω</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Γ, Δ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>b, c</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>Stmt m ω <span class="bp">Γ</span> <span class="bp">Δ</span> b c β</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">numExts (C (B s)) <span class="bp">≤</span> numExts s</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk3b" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk3b"><span class="alectryon-token"><span class="k">induction</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>Stmt m ω Γ Δ b c β</span></span></div></blockquote></div></small></div><span class="nv">s</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>ω</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Γ, Δ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>b, c</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>Γ✝, Δ✝</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>α✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b✝, c✝</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>e✝</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ✝</span> <span class="bp">→</span> Assg <span class="bp">Δ✝</span> <span class="bp">→</span> m α<span class="bp">✝</span></span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">expr</span></span><div class="goal-conclusion">numExts (C (B (expr e<span class="bp">✝</span>))) <span class="bp">≤</span> numExts (expr e<span class="bp">✝</span>)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Formal-lean-chk3c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>ω</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Γ, Δ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>b, c</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>Γ✝, Δ✝</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>b✝, c✝</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>α✝, β✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>s✝</var><span class="hyp-type"><b>: </b><span>Stmt m ω <span class="bp">Γ✝</span> <span class="bp">Δ✝</span> b<span class="bp">✝</span> c<span class="bp">✝</span> α<span class="bp">✝</span></span></span></span><br><span><var>s'✝</var><span class="hyp-type"><b>: </b><span>Stmt m ω (α<span class="bp">✝</span> :: <span class="bp">Γ✝</span>) <span class="bp">Δ✝</span> b<span class="bp">✝</span> c<span class="bp">✝</span> β<span class="bp">✝</span></span></span></span><br></div><label class="goal-separator" for="Formal-lean-chk3c"><hr><span class="goal-name">bind</span></label><div class="goal-conclusion">numExts (C (B (bind s<span class="bp">✝</span> s&#39;<span class="bp">✝</span>))) <span class="bp">≤</span> numExts (bind s<span class="bp">✝</span> s&#39;<span class="bp">✝</span>)</div></blockquote><input class="alectryon-extra-goal-toggle" id="Formal-lean-chk3d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>ω</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Γ, Δ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>b, c</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>Γ✝, Δ✝</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>α✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b✝, c✝</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>β✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>e✝</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ✝</span> <span class="bp">→</span> Assg <span class="bp">Δ✝</span> <span class="bp">→</span> α<span class="bp">✝</span></span></span></span><br><span><var>s✝</var><span class="hyp-type"><b>: </b><span>Stmt m ω <span class="bp">Γ✝</span> (α<span class="bp">✝</span> :: <span class="bp">Δ✝</span>) b<span class="bp">✝</span> c<span class="bp">✝</span> β<span class="bp">✝</span></span></span></span><br></div><label class="goal-separator" for="Formal-lean-chk3d"><hr><span class="goal-name">letmut</span></label><div class="goal-conclusion">numExts (C (B (letmut e<span class="bp">✝</span> s<span class="bp">✝</span>))) <span class="bp">≤</span> numExts (letmut e<span class="bp">✝</span> s<span class="bp">✝</span>)</div></blockquote><input class="alectryon-extra-goal-toggle" id="Formal-lean-chk3e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>ω</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Γ, Δ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>b, c</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>Γ✝, Δ✝</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>b✝, c✝</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>x✝</var><span class="hyp-type"><b>: </b><span>Fin (List.length <span class="bp">Δ✝</span>)</span></span></span><br><span><var>e✝</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ✝</span> <span class="bp">→</span> Assg <span class="bp">Δ✝</span> <span class="bp">→</span> List.get <span class="bp">Δ✝</span> x<span class="bp">✝</span></span></span></span><br></div><label class="goal-separator" for="Formal-lean-chk3e"><hr><span class="goal-name">assg</span></label><div class="goal-conclusion">numExts (C (B (assg x<span class="bp">✝</span> e<span class="bp">✝</span>))) <span class="bp">≤</span> numExts (assg x<span class="bp">✝</span> e<span class="bp">✝</span>)</div></blockquote><input class="alectryon-extra-goal-toggle" id="Formal-lean-chk3f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>ω</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Γ, Δ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>b, c</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>Γ✝, Δ✝</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>b✝, c✝</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>α✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>e✝</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ✝</span> <span class="bp">→</span> Assg <span class="bp">Δ✝</span> <span class="bp">→</span> Bool</span></span></span><br><span><var>s₁✝, s₂✝</var><span class="hyp-type"><b>: </b><span>Stmt m ω <span class="bp">Γ✝</span> <span class="bp">Δ✝</span> b<span class="bp">✝</span> c<span class="bp">✝</span> α<span class="bp">✝</span></span></span></span><br></div><label class="goal-separator" for="Formal-lean-chk3f"><hr><span class="goal-name">ite</span></label><div class="goal-conclusion">numExts (C (B (ite e<span class="bp">✝</span> s₁<span class="bp">✝</span> s₂<span class="bp">✝</span>))) <span class="bp">≤</span> numExts (ite e<span class="bp">✝</span> s₁<span class="bp">✝</span> s₂<span class="bp">✝</span>)</div></blockquote><input class="alectryon-extra-goal-toggle" id="Formal-lean-chk40" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>ω</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Γ, Δ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>b, c</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>Γ✝, Δ✝</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>b✝, c✝</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>α✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>e✝</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ✝</span> <span class="bp">→</span> Assg <span class="bp">Δ✝</span> <span class="bp">→</span> ω</span></span></span><br></div><label class="goal-separator" for="Formal-lean-chk40"><hr><span class="goal-name">ret</span></label><div class="goal-conclusion">numExts (C (B (ret e<span class="bp">✝</span>))) <span class="bp">≤</span> numExts (ret e<span class="bp">✝</span>)</div></blockquote><input class="alectryon-extra-goal-toggle" id="Formal-lean-chk41" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>ω</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Γ, Δ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>b, c</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>Γ✝, Δ✝</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>α✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b✝, c✝</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>e✝</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ✝</span> <span class="bp">→</span> Assg <span class="bp">Δ✝</span> <span class="bp">→</span> List α<span class="bp">✝</span></span></span></span><br><span><var>s✝</var><span class="hyp-type"><b>: </b><span>Stmt m ω (α<span class="bp">✝</span> :: <span class="bp">Γ✝</span>) <span class="bp">Δ✝</span> true true Unit</span></span></span><br></div><label class="goal-separator" for="Formal-lean-chk41"><hr><span class="goal-name">sfor</span></label><div class="goal-conclusion">numExts (C (B (sfor e<span class="bp">✝</span> s<span class="bp">✝</span>))) <span class="bp">≤</span> numExts (sfor e<span class="bp">✝</span> s<span class="bp">✝</span>)</div></blockquote><input class="alectryon-extra-goal-toggle" id="Formal-lean-chk42" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>ω</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Γ, Δ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>b, c</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>Γ✝, Δ✝</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>c✝</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>α✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><label class="goal-separator" for="Formal-lean-chk42"><hr><span class="goal-name">sbreak</span></label><div class="goal-conclusion">numExts (C (B sbreak)) <span class="bp">≤</span> numExts sbreak</div></blockquote><input class="alectryon-extra-goal-toggle" id="Formal-lean-chk43" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>ω</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Γ, Δ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>b, c</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>Γ✝, Δ✝</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>b✝</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>α✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><label class="goal-separator" for="Formal-lean-chk43"><hr><span class="goal-name">scont</span></label><div class="goal-conclusion">numExts (C (B scont)) <span class="bp">≤</span> numExts scont</div></blockquote></div></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk44" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk44"><span class="alectryon-token"><span class="k">&lt;;&gt;</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>ω</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Γ, Δ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>b, c</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>Γ✝, Δ✝</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>α✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b✝, c✝</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>e✝</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ✝</span> <span class="bp">→</span> Assg <span class="bp">Δ✝</span> <span class="bp">→</span> m α<span class="bp">✝</span></span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">expr</span></span><div class="goal-conclusion">numExts (C (B (expr e<span class="bp">✝</span>))) <span class="bp">≤</span> numExts (expr e<span class="bp">✝</span>)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Formal-lean-chk45" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>ω</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Γ, Δ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>b, c</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>Γ✝, Δ✝</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>b✝, c✝</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>α✝, β✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>s✝</var><span class="hyp-type"><b>: </b><span>Stmt m ω <span class="bp">Γ✝</span> <span class="bp">Δ✝</span> b<span class="bp">✝</span> c<span class="bp">✝</span> α<span class="bp">✝</span></span></span></span><br><span><var>s'✝</var><span class="hyp-type"><b>: </b><span>Stmt m ω (α<span class="bp">✝</span> :: <span class="bp">Γ✝</span>) <span class="bp">Δ✝</span> b<span class="bp">✝</span> c<span class="bp">✝</span> β<span class="bp">✝</span></span></span></span><br></div><label class="goal-separator" for="Formal-lean-chk45"><hr><span class="goal-name">bind</span></label><div class="goal-conclusion">numExts (C (B (bind s<span class="bp">✝</span> s&#39;<span class="bp">✝</span>))) <span class="bp">≤</span> numExts (bind s<span class="bp">✝</span> s&#39;<span class="bp">✝</span>)</div></blockquote><input class="alectryon-extra-goal-toggle" id="Formal-lean-chk46" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>ω</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Γ, Δ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>b, c</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>Γ✝, Δ✝</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>α✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b✝, c✝</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>β✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>e✝</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ✝</span> <span class="bp">→</span> Assg <span class="bp">Δ✝</span> <span class="bp">→</span> α<span class="bp">✝</span></span></span></span><br><span><var>s✝</var><span class="hyp-type"><b>: </b><span>Stmt m ω <span class="bp">Γ✝</span> (α<span class="bp">✝</span> :: <span class="bp">Δ✝</span>) b<span class="bp">✝</span> c<span class="bp">✝</span> β<span class="bp">✝</span></span></span></span><br></div><label class="goal-separator" for="Formal-lean-chk46"><hr><span class="goal-name">letmut</span></label><div class="goal-conclusion">numExts (C (B (letmut e<span class="bp">✝</span> s<span class="bp">✝</span>))) <span class="bp">≤</span> numExts (letmut e<span class="bp">✝</span> s<span class="bp">✝</span>)</div></blockquote><input class="alectryon-extra-goal-toggle" id="Formal-lean-chk47" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>ω</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Γ, Δ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>b, c</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>Γ✝, Δ✝</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>b✝, c✝</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>x✝</var><span class="hyp-type"><b>: </b><span>Fin (List.length <span class="bp">Δ✝</span>)</span></span></span><br><span><var>e✝</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ✝</span> <span class="bp">→</span> Assg <span class="bp">Δ✝</span> <span class="bp">→</span> List.get <span class="bp">Δ✝</span> x<span class="bp">✝</span></span></span></span><br></div><label class="goal-separator" for="Formal-lean-chk47"><hr><span class="goal-name">assg</span></label><div class="goal-conclusion">numExts (C (B (assg x<span class="bp">✝</span> e<span class="bp">✝</span>))) <span class="bp">≤</span> numExts (assg x<span class="bp">✝</span> e<span class="bp">✝</span>)</div></blockquote><input class="alectryon-extra-goal-toggle" id="Formal-lean-chk48" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>ω</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Γ, Δ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>b, c</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>Γ✝, Δ✝</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>b✝, c✝</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>α✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>e✝</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ✝</span> <span class="bp">→</span> Assg <span class="bp">Δ✝</span> <span class="bp">→</span> Bool</span></span></span><br><span><var>s₁✝, s₂✝</var><span class="hyp-type"><b>: </b><span>Stmt m ω <span class="bp">Γ✝</span> <span class="bp">Δ✝</span> b<span class="bp">✝</span> c<span class="bp">✝</span> α<span class="bp">✝</span></span></span></span><br></div><label class="goal-separator" for="Formal-lean-chk48"><hr><span class="goal-name">ite</span></label><div class="goal-conclusion">numExts (C (B (ite e<span class="bp">✝</span> s₁<span class="bp">✝</span> s₂<span class="bp">✝</span>))) <span class="bp">≤</span> numExts (ite e<span class="bp">✝</span> s₁<span class="bp">✝</span> s₂<span class="bp">✝</span>)</div></blockquote><input class="alectryon-extra-goal-toggle" id="Formal-lean-chk49" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>ω</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Γ, Δ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>b, c</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>Γ✝, Δ✝</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>b✝, c✝</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>α✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>e✝</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ✝</span> <span class="bp">→</span> Assg <span class="bp">Δ✝</span> <span class="bp">→</span> ω</span></span></span><br></div><label class="goal-separator" for="Formal-lean-chk49"><hr><span class="goal-name">ret</span></label><div class="goal-conclusion">numExts (C (B (ret e<span class="bp">✝</span>))) <span class="bp">≤</span> numExts (ret e<span class="bp">✝</span>)</div></blockquote><input class="alectryon-extra-goal-toggle" id="Formal-lean-chk4a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>ω</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Γ, Δ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>b, c</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>Γ✝, Δ✝</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>α✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b✝, c✝</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>e✝</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ✝</span> <span class="bp">→</span> Assg <span class="bp">Δ✝</span> <span class="bp">→</span> List α<span class="bp">✝</span></span></span></span><br><span><var>s✝</var><span class="hyp-type"><b>: </b><span>Stmt m ω (α<span class="bp">✝</span> :: <span class="bp">Γ✝</span>) <span class="bp">Δ✝</span> true true Unit</span></span></span><br></div><label class="goal-separator" for="Formal-lean-chk4a"><hr><span class="goal-name">sfor</span></label><div class="goal-conclusion">numExts (C (B (sfor e<span class="bp">✝</span> s<span class="bp">✝</span>))) <span class="bp">≤</span> numExts (sfor e<span class="bp">✝</span> s<span class="bp">✝</span>)</div></blockquote><input class="alectryon-extra-goal-toggle" id="Formal-lean-chk4b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>ω</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Γ, Δ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>b, c</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>Γ✝, Δ✝</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>c✝</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>α✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><label class="goal-separator" for="Formal-lean-chk4b"><hr><span class="goal-name">sbreak</span></label><div class="goal-conclusion">numExts (C (B sbreak)) <span class="bp">≤</span> numExts sbreak</div></blockquote><input class="alectryon-extra-goal-toggle" id="Formal-lean-chk4c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>ω</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Γ, Δ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>b, c</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>Γ✝, Δ✝</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>b✝</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>α✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><label class="goal-separator" for="Formal-lean-chk4c"><hr><span class="goal-name">scont</span></label><div class="goal-conclusion">numExts (C (B scont)) <span class="bp">≤</span> numExts scont</div></blockquote></div></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk4d" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk4d"><span class="alectryon-token"><span class="k">simp</span></span><span class="alectryon-token"> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat.add_le_add</var><b>: </b><span>∀ {a b c d : Nat}, a ≤ b → c ≤ d → a + c ≤ b + d</span></span></div></blockquote></div></small></div><span class="k">Nat.add_le_add</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>numExts_L_L</var><b>: </b><span>∀ {m : Type → Type ?u.342870} {ω : Type} {Γ Δ : List Type} {b c : Bool} {β : Type} [inst : Monad m]
  (s : Stmt m ω Γ Δ b c β), numExts (L (L s)) ≤ numExts s</span></span></div></blockquote></div></small></div><span class="k">numExts_L_L</span></span><span class="alectryon-token">, <span class="bp">*</span>]</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">

<span class="c1">-- Auxiliary tactic for showing that `D` terminates</span>
</span><span class="alectryon-token"><span class="k">macro</span></span><span class="alectryon-token"> <span class="s2">&quot;D_tac&quot;</span> : tactic <span class="bp">=&gt;</span>
  <span class="bp">`</span>({</span><span class="alectryon-token"><span class="k">simp_wf</span></span><span class="alectryon-token">
     </span><span class="alectryon-token"><span class="k">solve</span></span><span class="alectryon-token">
      <span class="bp">|</span> </span><span class="alectryon-token"><span class="k">apply</span></span><span class="alectryon-token"> Prod.Lex.left<span class="bp">;</span> </span><span class="alectryon-token"><span class="k">assumption</span></span><span class="alectryon-token">
      <span class="bp">|</span> </span><span class="alectryon-token"><span class="k">apply</span></span><span class="alectryon-token"> Prod.Lex.right&#39; <span class="bp">&lt;;&gt;</span> </span><span class="alectryon-token"><span class="k">simp_arith</span></span><span class="alectryon-token"> })</span><span class="alectryon-token">

<span class="bp">@</span>[</span><span class="alectryon-token"><span class="k">simp</span></span><span class="alectryon-token">] </span><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>D</var><b>: </b><span>{m : Type → Type} → {Γ : List Type} → {α : Type} → [inst : Monad m] → Stmt m Empty Γ ∅ false false α → Assg Γ → m α</span></span></div></blockquote></div></small></div><span class="nv">D</span></span><span class="alectryon-token"> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Monad</var><b>: </b><span>(Type ?u.348150 → Type ?u.348149) → Type (max (?u.348150 + 1) ?u.348149)</span></span></div></blockquote></div></small></div>Monad</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>Type → Type</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token">] : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt</var><b>: </b><span>(Type → Type) → Type → List Type → List Type → Bool → Bool → Type → Type 1</span></span></div></blockquote></div></small></div>Stmt</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>Type → Type</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Empty</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Empty</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Γ</var><b>: </b><span>List Type</span></span></div></blockquote></div></small></div><span class="nv">Γ</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>∅</var><b>: </b><span>List Type</span></span></div></blockquote></div></small></div><span class="bp">∅</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>false</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div>false</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>false</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div>false</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token"> <span class="bp">→</span> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Γ</var><b>: </b><span>List Type</span></span></div></blockquote></div></small></div><span class="nv">Γ</span></span><span class="alectryon-token"> <span class="bp">⊢</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>Type → Type</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token">)
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt.expr</var><b>: </b><span>{m : Type → Type ?u.349536} →
  {ω : Type} → {Γ Δ : List Type} → {α : Type} → {b c : Bool} → (Assg Γ → Assg Δ → m α) → Stmt m ω Γ Δ b c α</span></span></div></blockquote></div></small></div>Stmt.expr</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>Assg Γ → Assg ∅ → m α</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>Assg Γ → Assg ∅ → m α</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token">[<span class="bp">·</span>][</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>∅</var><b>: </b><span>Assg ∅</span></span></div></blockquote></div></small></div><span class="bp">∅</span></span><span class="alectryon-token">])
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt.bind</var><b>: </b><span>{m : Type → Type ?u.349597} →
  {ω : Type} →
    {Γ Δ : List Type} →
      {b c : Bool} → {α β : Type} → Stmt m ω Γ Δ b c α → Stmt m ω (α :: Γ) Δ b c β → Stmt m ω Γ Δ b c β</span></span></div></blockquote></div></small></div>Stmt.bind</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>Stmt m Empty Γ ∅ false false α✝</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s'</var><b>: </b><span>Stmt m Empty (α✝ :: Γ) ∅ false false α</span></span></div></blockquote></div></small></div><span class="nv">s&#39;</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> (</span><span class="alectryon-token"><span class="k">fun</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ρ</var><b>: </b><span>Assg Γ</span></span></div></blockquote></div></small></div><span class="nv">ρ</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>D</var><b>: </b><span>{m : Type → Type} → {Γ : List Type} → {α : Type} → [inst : Monad m] → Stmt m Empty Γ ∅ false false α → Assg Γ → m α</span></span></div></blockquote></div></small></div><span class="nv">D</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>Stmt m Empty Γ ∅ false false α✝</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ρ</var><b>: </b><span>Assg Γ</span></span></div></blockquote></div></small></div><span class="nv">ρ</span></span><span class="alectryon-token"> <span class="bp">&gt;&gt;=</span> </span><span class="alectryon-token"><span class="k">fun</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>α✝</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>D</var><b>: </b><span>{m : Type → Type} → {Γ : List Type} → {α : Type} → [inst : Monad m] → Stmt m Empty Γ ∅ false false α → Assg Γ → m α</span></span></div></blockquote></div></small></div><span class="nv">D</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s'</var><b>: </b><span>Stmt m Empty (α✝ :: Γ) ∅ false false α</span></span></div></blockquote></div></small></div><span class="nv">s&#39;</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>α✝</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> :: </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ρ</var><b>: </b><span>Assg Γ</span></span></div></blockquote></div></small></div><span class="nv">ρ</span></span><span class="alectryon-token">))
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt.letmut</var><b>: </b><span>{m : Type → Type ?u.349872} →
  {ω : Type} →
    {Γ Δ : List Type} →
      {α : Type} → {b c : Bool} → {β : Type} → (Assg Γ → Assg Δ → α) → Stmt m ω Γ (α :: Δ) b c β → Stmt m ω Γ Δ b c β</span></span></div></blockquote></div></small></div>Stmt.letmut</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>Assg Γ → Assg ∅ → α✝</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>Stmt m Empty Γ (α✝ :: ∅) false false α</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span>
    </span><span class="alectryon-token"><span class="k">have</span></span><span class="alectryon-token"> := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat.lt_succ_of_le</var><b>: </b><span>∀ {n m : Nat}, n ≤ m → n &lt; Nat.succ m</span></span></div></blockquote></div></small></div>Nat.lt_succ_of_le</span><span class="alectryon-token"> <span class="bp">&lt;|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt.numExts_S</var><b>: </b><span>∀ {m : Type → Type} {ω : Type} {Γ Δ : List Type} {α : Type} {b c : Bool} {β : Type} [inst : Monad m]
  (s : Stmt m ω Γ (List.append Δ [α]) b c β), Stmt.numExts (S s) ≤ Stmt.numExts s</span></span></div></blockquote></div></small></div>Stmt.numExts_S</span><span class="alectryon-token"> (<span class="bp">Δ</span> := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>[]</var><b>: </b><span>List Type</span></span></div></blockquote></div></small></div>[]</span><span class="alectryon-token">) </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>Stmt m Empty Γ (α✝ :: ∅) false false α</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token">  <span class="c1">-- for termination</span>
    </span><span class="alectryon-token"><span class="k">fun</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ρ</var><b>: </b><span>Assg Γ</span></span></div></blockquote></div></small></div><span class="nv">ρ</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span>
      </span><span class="alectryon-token"><span class="k">let</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>α✝</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>Assg Γ → Assg ∅ → α✝</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token">[</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ρ</var><b>: </b><span>Assg Γ</span></span></div></blockquote></div></small></div><span class="nv">ρ</span></span><span class="alectryon-token">][</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>∅</var><b>: </b><span>Assg ∅</span></span></div></blockquote></div></small></div><span class="bp">∅</span></span><span class="alectryon-token">]
      </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>StateT.run'</var><b>: </b><span>{σ : Type} → {m : Type → Type} → [inst : Functor m] → {α : Type} → StateT σ m α → σ → m α</span></span></div></blockquote></div></small></div>StateT.run&#39;</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>D</var><b>: </b><span>{m : Type → Type} → {Γ : List Type} → {α : Type} → [inst : Monad m] → Stmt m Empty Γ ∅ false false α → Assg Γ → m α</span></span></div></blockquote></div></small></div><span class="nv">D</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>S</var><b>: </b><span>{m : Type → Type} →
  {ω : Type} →
    {Γ Δ : List Type} →
      {α : Type} →
        {b c : Bool} →
          {β : Type} → [inst : Monad m] → Stmt m ω Γ (List.append Δ [α]) b c β → Stmt (StateT α m) ω (α :: Γ) Δ b c β</span></span></div></blockquote></div></small></div>S</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>Stmt m Empty Γ (α✝ :: ∅) false false α</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token">) (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>α✝</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> :: </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ρ</var><b>: </b><span>Assg Γ</span></span></div></blockquote></div></small></div><span class="nv">ρ</span></span><span class="alectryon-token">)) </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>α✝</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt.ite</var><b>: </b><span>{m : Type → Type ?u.350351} →
  {ω : Type} →
    {Γ Δ : List Type} →
      {b c : Bool} →
        {α : Type} → (Assg Γ → Assg Δ → Bool) → Stmt m ω Γ Δ b c α → Stmt m ω Γ Δ b c α → Stmt m ω Γ Δ b c α</span></span></div></blockquote></div></small></div>Stmt.ite</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>Assg Γ → Assg ∅ → Bool</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s₁</var><b>: </b><span>Stmt m Empty Γ ∅ false false α</span></span></div></blockquote></div></small></div><span class="nv">s₁</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s₂</var><b>: </b><span>Stmt m Empty Γ ∅ false false α</span></span></div></blockquote></div></small></div><span class="nv">s₂</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> (</span><span class="alectryon-token"><span class="k">fun</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ρ</var><b>: </b><span>Assg Γ</span></span></div></blockquote></div></small></div><span class="nv">ρ</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><span class="k">if</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>Assg Γ → Assg ∅ → Bool</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token">[</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ρ</var><b>: </b><span>Assg Γ</span></span></div></blockquote></div></small></div><span class="nv">ρ</span></span><span class="alectryon-token">][</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>∅</var><b>: </b><span>Assg ∅</span></span></div></blockquote></div></small></div><span class="bp">∅</span></span><span class="alectryon-token">] </span><span class="alectryon-token"><span class="k">then</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>D</var><b>: </b><span>{m : Type → Type} → {Γ : List Type} → {α : Type} → [inst : Monad m] → Stmt m Empty Γ ∅ false false α → Assg Γ → m α</span></span></div></blockquote></div></small></div><span class="nv">D</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s₁</var><b>: </b><span>Stmt m Empty Γ ∅ false false α</span></span></div></blockquote></div></small></div><span class="nv">s₁</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ρ</var><b>: </b><span>Assg Γ</span></span></div></blockquote></div></small></div><span class="nv">ρ</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">else</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>D</var><b>: </b><span>{m : Type → Type} → {Γ : List Type} → {α : Type} → [inst : Monad m] → Stmt m Empty Γ ∅ false false α → Assg Γ → m α</span></span></div></blockquote></div></small></div><span class="nv">D</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s₂</var><b>: </b><span>Stmt m Empty Γ ∅ false false α</span></span></div></blockquote></div></small></div><span class="nv">s₂</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ρ</var><b>: </b><span>Assg Γ</span></span></div></blockquote></div></small></div><span class="nv">ρ</span></span><span class="alectryon-token">)
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt.sfor</var><b>: </b><span>{m : Type → Type ?u.350515} →
  {ω : Type} →
    {Γ Δ : List Type} →
      {α : Type} →
        {b c : Bool} → (Assg Γ → Assg Δ → List α) → Stmt m ω (α :: Γ) Δ true true Unit → Stmt m ω Γ Δ b c Unit</span></span></div></blockquote></div></small></div>Stmt.sfor</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>Assg Γ → Assg ∅ → List α✝</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>Stmt m Empty (α✝ :: Γ) ∅ true true Unit</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span>
    </span><span class="alectryon-token"><span class="k">have</span></span><span class="alectryon-token"> := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat.lt_succ_of_le</var><b>: </b><span>∀ {n m : Nat}, n ≤ m → n &lt; Nat.succ m</span></span></div></blockquote></div></small></div>Nat.lt_succ_of_le</span><span class="alectryon-token"> <span class="bp">&lt;|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt.numExts_C_B</var><b>: </b><span>∀ {m : Type → Type} {ω : Type} {Γ Δ : List Type} {b c : Bool} {β : Type} [inst : Monad m] (s : Stmt m ω Γ Δ b c β),
  Stmt.numExts (C (B s)) ≤ Stmt.numExts s</span></span></div></blockquote></div></small></div>Stmt.numExts_C_B</span><span class="alectryon-token"> (<span class="bp">Δ</span> := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>[]</var><b>: </b><span>List Type</span></span></div></blockquote></div></small></div>[]</span><span class="alectryon-token">) </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>Stmt m Empty (α✝ :: Γ) ∅ true true Unit</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token">  <span class="c1">-- for termination</span>
    </span><span class="alectryon-token"><span class="k">fun</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ρ</var><b>: </b><span>Assg Γ</span></span></div></blockquote></div></small></div><span class="nv">ρ</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span>
      </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>runCatch</var><b>: </b><span>{m : Type → Type} → {α : Type} → [inst : Monad m] → ExceptT α m α → m α</span></span></div></blockquote></div></small></div>runCatch</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>forM</var><b>: </b><span>{m : Type → Type} → {γ α : Type} → [self : ForM m γ α] → [inst : Monad m] → γ → (α → m PUnit) → m PUnit</span></span></div></blockquote></div></small></div>forM</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>Assg Γ → Assg ∅ → List α✝</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token">[</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ρ</var><b>: </b><span>Assg Γ</span></span></div></blockquote></div></small></div><span class="nv">ρ</span></span><span class="alectryon-token">][</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>∅</var><b>: </b><span>Assg ∅</span></span></div></blockquote></div></small></div><span class="bp">∅</span></span><span class="alectryon-token">] (</span><span class="alectryon-token"><span class="k">fun</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>α✝</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>runCatch</var><b>: </b><span>{m : Type → Type} → {α : Type} → [inst : Monad m] → ExceptT α m α → m α</span></span></div></blockquote></div></small></div>runCatch</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>D</var><b>: </b><span>{m : Type → Type} → {Γ : List Type} → {α : Type} → [inst : Monad m] → Stmt m Empty Γ ∅ false false α → Assg Γ → m α</span></span></div></blockquote></div></small></div><span class="nv">D</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>C</var><b>: </b><span>{m : Type → Type} →
  {ω : Type} →
    {Γ Δ : List Type} →
      {c : Bool} → {α : Type} → [inst : Monad m] → Stmt m ω Γ Δ false c α → Stmt (ExceptT Unit m) ω Γ Δ false false α</span></span></div></blockquote></div></small></div>C</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>B</var><b>: </b><span>{m : Type → Type} →
  {ω : Type} →
    {Γ Δ : List Type} →
      {b c : Bool} → {α : Type} → [inst : Monad m] → Stmt m ω Γ Δ b c α → Stmt (ExceptT Unit m) ω Γ Δ false c α</span></span></div></blockquote></div></small></div>B</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>Stmt m Empty (α✝ :: Γ) ∅ true true Unit</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token">)) (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>α✝</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> :: </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ρ</var><b>: </b><span>Assg Γ</span></span></div></blockquote></div></small></div><span class="nv">ρ</span></span><span class="alectryon-token">))))
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt.ret</var><b>: </b><span>{m : Type → Type ?u.351104} →
  {ω : Type} → {Γ Δ : List Type} → {b c : Bool} → {α : Type} → (Assg Γ → Assg Δ → ω) → Stmt m ω Γ Δ b c α</span></span></div></blockquote></div></small></div>Stmt.ret</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>Assg Γ → Assg ∅ → Empty</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> (</span><span class="alectryon-token"><span class="k">nomatch</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>Assg Γ → Assg ∅ → Empty</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token">[<span class="bp">·</span>][</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>∅</var><b>: </b><span>Assg ∅</span></span></div></blockquote></div></small></div><span class="bp">∅</span></span><span class="alectryon-token">])
</span><span class="alectryon-token"><span class="k">termination_by</span></span><span class="alectryon-token"> _ s <span class="bp">=&gt;</span> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>Stmt m Empty Γ ∅ false false α</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>numExts</var><b>: </b><span>{m : Type → Type} → {ω : Type} → {Γ Δ : List Type} → {b c : Bool} → {α : Type} → Stmt m ω Γ Δ b c α → Nat</span></span></div></blockquote></div></small></div>numExts</span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>sizeOf</var><b>: </b><span>{α : Type 1} → [self : SizeOf α] → α → Nat</span></span></div></blockquote></div></small></div>sizeOf</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>Stmt m Empty Γ ∅ false false α</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token">)
</span><span class="alectryon-token"><span class="k">decreasing_by</span></span><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk4e" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk4e"><span class="alectryon-token"><span class="k">D_tac</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span></pre>
<p>Finally we compose <code>D</code> and <code>R</code> into the translation rule for a top-level statement (1').</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Do.trans</var><b>: </b><span>{m : Type → Type} → {α : Type} → [inst : Monad m] → Do m α → m α</span></span></div></blockquote></div></small></div><span class="nv">Do.trans</span></span><span class="alectryon-token"> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Monad</var><b>: </b><span>(Type → Type) → Type 1</span></span></div></blockquote></div></small></div>Monad</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>Type → Type</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token">] (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>Do m α</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Do</var><b>: </b><span>(Type → Type) → Type → Type 1</span></span></div></blockquote></div></small></div>Do</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>Type → Type</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token">) : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>Type → Type</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token"> := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>runCatch</var><b>: </b><span>{m : Type → Type} → {α : Type} → [inst : Monad m] → ExceptT α m α → m α</span></span></div></blockquote></div></small></div>runCatch</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>D</var><b>: </b><span>{m : Type → Type} → {Γ : List Type} → {α : Type} → [inst : Monad m] → Stmt m Empty Γ ∅ false false α → Assg Γ → m α</span></span></div></blockquote></div></small></div>D</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>R</var><b>: </b><span>{m : Type → Type} →
  {ω : Type} →
    {Γ Δ : List Type} →
      {b c : Bool} → {α : Type} → [inst : Monad m] → Stmt m ω Γ Δ b c α → Stmt (ExceptT ω m) Empty Γ Δ b c α</span></span></div></blockquote></div></small></div>R</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>Do m α</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token">) </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>∅</var><b>: </b><span>Assg ∅</span></span></div></blockquote></div></small></div><span class="bp">∅</span></span><span class="alectryon-token">)</span></span></pre>
<h2 id="equivalence-proof"><a class="header" href="#equivalence-proof">Equivalence Proof</a></h2>
<p>Using the monadic dynamic semantics, we can modularly prove for each individual translation function that
evaluating its output is equivalent to directly evaluating the input, modulo some lifting and adjustment
of resulting values. After induction on the statement, the proofs are mostly concerned with case splitting,
application of congruence theorems, and simplification. We can mostly offload these tasks onto
<a href="https://github.com/JLimperg/aesop">Aesop</a>.</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kn">attribute</span></span><span class="alectryon-token"> [</span><span class="alectryon-token"><span class="kn">local</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">simp</span></span><span class="alectryon-token">] </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>map_eq_pure_bind</var><b>: </b><span>∀ {m : Type u_1 → Type u_2} {α β : Type u_1} [inst : Monad m] [inst_1 : LawfulMonad m] (f : α → β) (x : m α),
  f &lt;$&gt; x = do
    let a ← x
    pure (f a)</span></span></div></blockquote></div></small></div>map_eq_pure_bind</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ExceptT.run_bind</var><b>: </b><span>∀ {m : Type u_1 → Type u_2} {ε α β : Type u_1} {f : α → ExceptT ε m β} [inst : Monad m] (x : ExceptT ε m α),
  ExceptT.run (x &gt;&gt;= f) = do
    let x ← ExceptT.run x
    match x with
      | Except.ok x =&gt; ExceptT.run (f x)
      | Except.error e =&gt; pure (Except.error e)</span></span></div></blockquote></div></small></div>ExceptT.run_bind</span><span class="alectryon-token">
</span><span class="alectryon-token"><span class="kn">attribute</span></span><span class="alectryon-token"> [</span><span class="alectryon-token"><span class="k">aesop</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">safe</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">apply</span></span><span class="alectryon-token">] </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>bind_congr</var><b>: </b><span>∀ {m : Type u_1 → Type u_2} {α β : Type u_1} [inst : Bind m] {x : m α} {f g : α → m β},
  (∀ (a : α), f a = g a) → x &gt;&gt;= f = x &gt;&gt;= g</span></span></div></blockquote></div></small></div>bind_congr</span><span class="alectryon-token">

</span><span class="alectryon-token"><span class="kd">theorem</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>eval_R</var><b>: </b><span>∀ {m : Type → Type u_1} {ω : Type} {Γ Δ : List Type} {b c : Bool} {α : Type} {ρ : Assg Γ} {σ : Assg Δ} [inst : Monad m]
  [inst_1 : LawfulMonad m] (s : Stmt m ω Γ Δ b c α),
  Stmt.eval ρ (R s) σ = do
    let x ← ExceptT.lift (Stmt.eval ρ s σ)
    match b, c, x with
      | b, c, (Neut.ret o, snd) =&gt; throw o
      | b, c, (Neut.val a, σ) =&gt; pure (Neut.val a, σ)
      | b, .(true), (Neut.rcont, σ) =&gt; pure (Neut.rcont, σ)
      | .(true), c, (Neut.rbreak, σ) =&gt; pure (Neut.rbreak, σ)</span></span></div></blockquote></div></small></div><span class="nv">eval_R</span></span><span class="alectryon-token"> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Monad</var><b>: </b><span>(Type ?u.373143 → Type ?u.373142) → Type (max (?u.373143 + 1) ?u.373142)</span></span></div></blockquote></div></small></div>Monad</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>Type → Type u_1</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token">] [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>LawfulMonad</var><b>: </b><span>(m : Type ?u.373172 → Type ?u.373171) → [inst : Monad m] → Prop</span></span></div></blockquote></div></small></div>LawfulMonad</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>Type → Type u_1</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token">] (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>Stmt m ω Γ Δ b c α</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt</var><b>: </b><span>(Type → Type ?u.373206) → Type → List Type → List Type → Bool → Bool → Type → Type (max 1 ?u.373206)</span></span></div></blockquote></div></small></div>Stmt</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>Type → Type u_1</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ω</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">ω</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Γ</var><b>: </b><span>List Type</span></span></div></blockquote></div></small></div><span class="nv">Γ</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Δ</var><b>: </b><span>List Type</span></span></div></blockquote></div></small></div><span class="nv">Δ</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>c</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div><span class="nv">c</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token">) : (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>R</var><b>: </b><span>{m : Type → Type u_1} →
  {ω : Type} →
    {Γ Δ : List Type} →
      {b c : Bool} → {α : Type} → [inst : Monad m] → Stmt m ω Γ Δ b c α → Stmt (ExceptT ω m) Empty Γ Δ b c α</span></span></div></blockquote></div></small></div>R</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>Stmt m ω Γ Δ b c α</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token">)<span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>eval</var><b>: </b><span>{m : Type → Type u_1} →
  {Γ : List Type} →
    {ω : Type} →
      {Δ : List Type} →
        {b c : Bool} → {α : Type} → [inst : Monad m] → Assg Γ → Stmt m ω Γ Δ b c α → Assg Δ → m (Neut ω α b c × Assg Δ)</span></span></div></blockquote></div></small></div><span class="na">eval</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ρ</var><b>: </b><span>Assg Γ</span></span></div></blockquote></div></small></div><span class="nv">ρ</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>σ</var><b>: </b><span>Assg Δ</span></span></div></blockquote></div></small></div><span class="nv">σ</span></span><span class="alectryon-token"> <span class="bp">=</span> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ExceptT.lift</var><b>: </b><span>{ε : Type} → {m : Type → Type u_1} → [inst : Monad m] → {α : Type} → m α → ExceptT ε m α</span></span></div></blockquote></div></small></div>ExceptT.lift</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>Stmt m ω Γ Δ b c α</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>eval</var><b>: </b><span>{m : Type → Type u_1} →
  {Γ : List Type} →
    {ω : Type} →
      {Δ : List Type} →
        {b c : Bool} → {α : Type} → [inst : Monad m] → Assg Γ → Stmt m ω Γ Δ b c α → Assg Δ → m (Neut ω α b c × Assg Δ)</span></span></div></blockquote></div></small></div>eval</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ρ</var><b>: </b><span>Assg Γ</span></span></div></blockquote></div></small></div><span class="nv">ρ</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>σ</var><b>: </b><span>Assg Δ</span></span></div></blockquote></div></small></div><span class="nv">σ</span></span><span class="alectryon-token">) <span class="bp">&gt;&gt;=</span> </span><span class="alectryon-token"><span class="k">fun</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>Neut ω α b c × Assg Δ</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><span class="k">match</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><span class="k">generalizing</span></span><span class="alectryon-token"> := </span><span class="alectryon-token"><span class="k">false</span></span><span class="alectryon-token">) </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>Neut ω α b c × Assg Δ</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">with</span></span><span class="alectryon-token">
    <span class="bp">|</span> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Neut.ret</var><b>: </b><span>{ω α : Type} → {b c : Bool} → ω → Neut ω α b c</span></span></div></blockquote></div></small></div>Neut.ret</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>o</var><b>: </b><span>ω</span></span></div></blockquote></div></small></div><span class="nv">o</span></span><span class="alectryon-token">, _) <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>throw</var><b>: </b><span>{ε : Type} → {m : Type → Type u_1} → [self : MonadExcept ε m] → {α : Type} → ε → m α</span></span></div></blockquote></div></small></div>throw</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>o</var><b>: </b><span>ω</span></span></div></blockquote></div></small></div><span class="nv">o</span></span><span class="alectryon-token">
    <span class="bp">|</span> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Neut.val</var><b>: </b><span>{ω α : Type} → {b c : Bool} → α → Neut ω α b c</span></span></div></blockquote></div></small></div>Neut.val</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>σ</var><b>: </b><span>Assg Δ</span></span></div></blockquote></div></small></div><span class="nv">σ</span></span><span class="alectryon-token">) <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>pure</var><b>: </b><span>{f : Type → Type u_1} → [self : Pure f] → {α : Type} → α → f α</span></span></div></blockquote></div></small></div>pure</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Neut.val</var><b>: </b><span>{ω α : Type} → {b c : Bool} → α → Neut ω α b c</span></span></div></blockquote></div></small></div>Neut.val</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>σ</var><b>: </b><span>Assg Δ</span></span></div></blockquote></div></small></div><span class="nv">σ</span></span><span class="alectryon-token">)
    <span class="bp">|</span> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Neut.rcont</var><b>: </b><span>{ω α : Type} → {b : Bool} → Neut ω α b true</span></span></div></blockquote></div></small></div>Neut.rcont</span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>σ</var><b>: </b><span>Assg Δ</span></span></div></blockquote></div></small></div><span class="nv">σ</span></span><span class="alectryon-token">) <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>pure</var><b>: </b><span>{f : Type → Type u_1} → [self : Pure f] → {α : Type} → α → f α</span></span></div></blockquote></div></small></div>pure</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Neut.rcont</var><b>: </b><span>{ω α : Type} → {b : Bool} → Neut ω α b true</span></span></div></blockquote></div></small></div>Neut.rcont</span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>σ</var><b>: </b><span>Assg Δ</span></span></div></blockquote></div></small></div><span class="nv">σ</span></span><span class="alectryon-token">)
    <span class="bp">|</span> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Neut.rbreak</var><b>: </b><span>{ω α : Type} → {c : Bool} → Neut ω α true c</span></span></div></blockquote></div></small></div>Neut.rbreak</span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>σ</var><b>: </b><span>Assg Δ</span></span></div></blockquote></div></small></div><span class="nv">σ</span></span><span class="alectryon-token">) <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>pure</var><b>: </b><span>{f : Type → Type u_1} → [self : Pure f] → {α : Type} → α → f α</span></span></div></blockquote></div></small></div>pure</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Neut.rbreak</var><b>: </b><span>{ω α : Type} → {c : Bool} → Neut ω α true c</span></span></div></blockquote></div></small></div>Neut.rbreak</span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>σ</var><b>: </b><span>Assg Δ</span></span></div></blockquote></div></small></div><span class="nv">σ</span></span><span class="alectryon-token">) : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ExceptT</var><b>: </b><span>Type → (Type → Type u_1) → Type → Type u_1</span></span></div></blockquote></div></small></div>ExceptT</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ω</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">ω</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>Type → Type u_1</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Neut</var><b>: </b><span>Type → Type → Bool → Bool → Type</span></span></div></blockquote></div></small></div>Neut</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Empty</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Empty</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>c</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div><span class="nv">c</span></span><span class="alectryon-token"> <span class="bp">×</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Assg</var><b>: </b><span>List Type → Type</span></span></div></blockquote></div></small></div>Assg</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Δ</var><b>: </b><span>List Type</span></span></div></blockquote></div></small></div><span class="nv">Δ</span></span><span class="alectryon-token">)) := </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk4f" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk4f"><span class="alectryon-token"><span class="kd">by</span></span><span class="alectryon-token"></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>ω</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Γ, Δ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>b, c</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ρ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ</span></span></span></span><br><span><var>σ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Δ</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>Stmt m ω <span class="bp">Γ</span> <span class="bp">Δ</span> b c α</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Stmt.eval ρ (R s) σ <span class="bp">=</span> <span class="k">do</span>
  <span class="k">let</span> x <span class="bp">←</span> ExceptT.lift (Stmt.eval ρ s σ)
  <span class="k">match</span> b, c, x <span class="k">with</span>
    <span class="bp">|</span> b, c, (Neut.ret o, snd) <span class="bp">=&gt;</span> throw o
    <span class="bp">|</span> b, c, (Neut.val a, σ) <span class="bp">=&gt;</span> pure (Neut.val a, σ)
    <span class="bp">|</span> b, <span class="bp">.</span>(true), (Neut.rcont, σ) <span class="bp">=&gt;</span> pure (Neut.rcont, σ)
    <span class="bp">|</span> <span class="bp">.</span>(true), c, (Neut.rbreak, σ) <span class="bp">=&gt;</span> pure (Neut.rbreak, σ)</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk50" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk50"><span class="alectryon-token"><span class="k">apply</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ExceptT.ext</var><b>: </b><span>∀ {m : Type → Type u_1} {ε α : Type} [inst : Monad m] {x y : ExceptT ε m α}, ExceptT.run x = ExceptT.run y → x = y</span></span></div></blockquote></div></small></div>ExceptT.ext</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>ω</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Γ, Δ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>b, c</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ρ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ</span></span></span></span><br><span><var>σ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Δ</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>Stmt m ω <span class="bp">Γ</span> <span class="bp">Δ</span> b c α</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">h</span></span><div class="goal-conclusion">ExceptT.run (Stmt.eval ρ (R s) σ) <span class="bp">=</span>
  ExceptT.run <span class="k">do</span>
    <span class="k">let</span> x <span class="bp">←</span> ExceptT.lift (Stmt.eval ρ s σ)
    <span class="k">match</span> b, c, x <span class="k">with</span>
      <span class="bp">|</span> b, c, (Neut.ret o, snd) <span class="bp">=&gt;</span> throw o
      <span class="bp">|</span> b, c, (Neut.val a, σ) <span class="bp">=&gt;</span> pure (Neut.val a, σ)
      <span class="bp">|</span> b, <span class="bp">.</span>(true), (Neut.rcont, σ) <span class="bp">=&gt;</span> pure (Neut.rcont, σ)
      <span class="bp">|</span> <span class="bp">.</span>(true), c, (Neut.rbreak, σ) <span class="bp">=&gt;</span> pure (Neut.rbreak, σ)</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk51" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk51"><span class="alectryon-token"><span class="k">induction</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>Stmt m ω Γ Δ b c α</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">with</span></span><span class="alectryon-token"></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>ω</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Γ, Δ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>b, c</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ρ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ</span></span></span></span><br><span><var>σ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Δ</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>Stmt m ω <span class="bp">Γ</span> <span class="bp">Δ</span> b c α</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">h</span></span><div class="goal-conclusion">ExceptT.run (Stmt.eval ρ (R s) σ) <span class="bp">=</span>
  ExceptT.run <span class="k">do</span>
    <span class="k">let</span> x <span class="bp">←</span> ExceptT.lift (Stmt.eval ρ s σ)
    <span class="k">match</span> b, c, x <span class="k">with</span>
      <span class="bp">|</span> b, c, (Neut.ret o, snd) <span class="bp">=&gt;</span> throw o
      <span class="bp">|</span> b, c, (Neut.val a, σ) <span class="bp">=&gt;</span> pure (Neut.val a, σ)
      <span class="bp">|</span> b, <span class="bp">.</span>(true), (Neut.rcont, σ) <span class="bp">=&gt;</span> pure (Neut.rcont, σ)
      <span class="bp">|</span> <span class="bp">.</span>(true), c, (Neut.rbreak, σ) <span class="bp">=&gt;</span> pure (Neut.rbreak, σ)</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk52" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk52"><span class="alectryon-token"><span class="bp">|</span> sfor </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>Assg Γ✝ → Assg Δ✝ → List α✝</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>ω</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Γ, Δ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>b, c</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>Γ✝, Δ✝</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>α✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b✝, c✝</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ✝</span> <span class="bp">→</span> Assg <span class="bp">Δ✝</span> <span class="bp">→</span> List α<span class="bp">✝</span></span></span></span><br><span><var>s✝</var><span class="hyp-type"><b>: </b><span>Stmt m ω (α<span class="bp">✝</span> :: <span class="bp">Γ✝</span>) <span class="bp">Δ✝</span> true true Unit</span></span></span><br><span><var>ρ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ✝</span></span></span></span><br><span><var>σ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Δ✝</span></span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">h.sfor</span></span><div class="goal-conclusion">ExceptT.run (Stmt.eval ρ (R (Stmt.sfor e s<span class="bp">✝</span>)) σ) <span class="bp">=</span>
  ExceptT.run <span class="k">do</span>
    <span class="k">let</span> x <span class="bp">←</span> ExceptT.lift (Stmt.eval ρ (Stmt.sfor e s<span class="bp">✝</span>) σ)
    <span class="k">match</span> b<span class="bp">✝</span>, c<span class="bp">✝</span>, x <span class="k">with</span>
      <span class="bp">|</span> b, c, (Neut.ret o, snd) <span class="bp">=&gt;</span> throw o
      <span class="bp">|</span> b, c, (Neut.val a, σ) <span class="bp">=&gt;</span> pure (Neut.val a, σ)
      <span class="bp">|</span> b, <span class="bp">.</span>(true), (Neut.rcont, σ) <span class="bp">=&gt;</span> pure (Neut.rcont, σ)
      <span class="bp">|</span> <span class="bp">.</span>(true), c, (Neut.rbreak, σ) <span class="bp">=&gt;</span> pure (Neut.rbreak, σ)</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
    </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk53" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk53"><span class="alectryon-token"><span class="k">simp</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">only</span></span><span class="alectryon-token"> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt.eval</var><b>: </b><span>{m : Type → Type ?u.375552} →
  {Γ : List Type} →
    {ω : Type} →
      {Δ : List Type} →
        {b c : Bool} → {α : Type} → [inst : Monad m] → Assg Γ → Stmt m ω Γ Δ b c α → Assg Δ → m (Neut ω α b c × Assg Δ)</span></span></div></blockquote></div></small></div>Stmt.eval</span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>R</var><b>: </b><span>{m : Type → Type ?u.375899} →
  {ω : Type} →
    {Γ Δ : List Type} →
      {b c : Bool} → {α : Type} → [inst : Monad m] → Stmt m ω Γ Δ b c α → Stmt (ExceptT ω m) Empty Γ Δ b c α</span></span></div></blockquote></div></small></div>R</span><span class="alectryon-token">]</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>ω</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Γ, Δ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>b, c</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>Γ✝, Δ✝</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>α✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b✝, c✝</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ✝</span> <span class="bp">→</span> Assg <span class="bp">Δ✝</span> <span class="bp">→</span> List α<span class="bp">✝</span></span></span></span><br><span><var>s✝</var><span class="hyp-type"><b>: </b><span>Stmt m ω (α<span class="bp">✝</span> :: <span class="bp">Γ✝</span>) <span class="bp">Δ✝</span> true true Unit</span></span></span><br><span><var>ρ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ✝</span></span></span></span><br><span><var>σ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Δ✝</span></span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">h.sfor</span></span><div class="goal-conclusion">ExceptT.run (Stmt.eval.go ρ c<span class="bp">✝</span> b<span class="bp">✝</span> α<span class="bp">✝</span> (R s<span class="bp">✝</span>) σ (e ρ σ)) <span class="bp">=</span>
  ExceptT.run <span class="k">do</span>
    <span class="k">let</span> x <span class="bp">←</span> ExceptT.lift (Stmt.eval.go ρ c<span class="bp">✝</span> b<span class="bp">✝</span> α<span class="bp">✝</span> s<span class="bp">✝</span> σ (e ρ σ))
    <span class="k">match</span> b<span class="bp">✝</span>, c<span class="bp">✝</span>, x <span class="k">with</span>
      <span class="bp">|</span> b, c, (Neut.ret o, snd) <span class="bp">=&gt;</span> throw o
      <span class="bp">|</span> b, c, (Neut.val a, σ) <span class="bp">=&gt;</span> pure (Neut.val a, σ)
      <span class="bp">|</span> b, <span class="bp">.</span>(true), (Neut.rcont, σ) <span class="bp">=&gt;</span> pure (Neut.rcont, σ)
      <span class="bp">|</span> <span class="bp">.</span>(true), c, (Neut.rbreak, σ) <span class="bp">=&gt;</span> pure (Neut.rbreak, σ)</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
    </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk54" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk54"><span class="alectryon-token"><span class="k">induction</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>Assg Γ✝ → Assg Δ✝ → List α✝</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ρ</var><b>: </b><span>Assg Γ✝</span></span></div></blockquote></div></small></div><span class="nv">ρ</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>σ</var><b>: </b><span>Assg Δ✝</span></span></div></blockquote></div></small></div><span class="nv">σ</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">generalizing</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>σ</var><b>: </b><span>Assg Δ✝</span></span></div></blockquote></div></small></div><span class="nv">σ</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>ω</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Γ, Δ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>b, c</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>Γ✝, Δ✝</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>α✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b✝, c✝</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ✝</span> <span class="bp">→</span> Assg <span class="bp">Δ✝</span> <span class="bp">→</span> List α<span class="bp">✝</span></span></span></span><br><span><var>s✝</var><span class="hyp-type"><b>: </b><span>Stmt m ω (α<span class="bp">✝</span> :: <span class="bp">Γ✝</span>) <span class="bp">Δ✝</span> true true Unit</span></span></span><br><span><var>ρ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ✝</span></span></span></span><br><span><var>σ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Δ✝</span></span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">h.sfor.nil</span></span><div class="goal-conclusion">ExceptT.run (Stmt.eval.go ρ c<span class="bp">✝</span> b<span class="bp">✝</span> α<span class="bp">✝</span> (R s<span class="bp">✝</span>) σ []) <span class="bp">=</span>
  ExceptT.run <span class="k">do</span>
    <span class="k">let</span> x <span class="bp">←</span> ExceptT.lift (Stmt.eval.go ρ c<span class="bp">✝</span> b<span class="bp">✝</span> α<span class="bp">✝</span> s<span class="bp">✝</span> σ [])
    <span class="k">match</span> b<span class="bp">✝</span>, c<span class="bp">✝</span>, x <span class="k">with</span>
      <span class="bp">|</span> b, c, (Neut.ret o, snd) <span class="bp">=&gt;</span> throw o
      <span class="bp">|</span> b, c, (Neut.val a, σ) <span class="bp">=&gt;</span> pure (Neut.val a, σ)
      <span class="bp">|</span> b, <span class="bp">.</span>(true), (Neut.rcont, σ) <span class="bp">=&gt;</span> pure (Neut.rcont, σ)
      <span class="bp">|</span> <span class="bp">.</span>(true), c, (Neut.rbreak, σ) <span class="bp">=&gt;</span> pure (Neut.rbreak, σ)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Formal-lean-chk55" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>ω</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Γ, Δ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>b, c</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>Γ✝, Δ✝</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>α✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b✝, c✝</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ✝</span> <span class="bp">→</span> Assg <span class="bp">Δ✝</span> <span class="bp">→</span> List α<span class="bp">✝</span></span></span></span><br><span><var>s✝</var><span class="hyp-type"><b>: </b><span>Stmt m ω (α<span class="bp">✝</span> :: <span class="bp">Γ✝</span>) <span class="bp">Δ✝</span> true true Unit</span></span></span><br><span><var>ρ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ✝</span></span></span></span><br><span><var>head✝</var><span class="hyp-type"><b>: </b><span>α<span class="bp">✝</span></span></span></span><br><span><var>tail✝</var><span class="hyp-type"><b>: </b><span>List α<span class="bp">✝</span></span></span></span><br><span><var>σ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Δ✝</span></span></span></span><br></div><label class="goal-separator" for="Formal-lean-chk55"><hr><span class="goal-name">h.sfor.cons</span></label><div class="goal-conclusion">ExceptT.run (Stmt.eval.go ρ c<span class="bp">✝</span> b<span class="bp">✝</span> α<span class="bp">✝</span> (R s<span class="bp">✝</span>) σ (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>)) <span class="bp">=</span>
  ExceptT.run <span class="k">do</span>
    <span class="k">let</span> x <span class="bp">←</span> ExceptT.lift (Stmt.eval.go ρ c<span class="bp">✝</span> b<span class="bp">✝</span> α<span class="bp">✝</span> s<span class="bp">✝</span> σ (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>))
    <span class="k">match</span> b<span class="bp">✝</span>, c<span class="bp">✝</span>, x <span class="k">with</span>
      <span class="bp">|</span> b, c, (Neut.ret o, snd) <span class="bp">=&gt;</span> throw o
      <span class="bp">|</span> b, c, (Neut.val a, σ) <span class="bp">=&gt;</span> pure (Neut.val a, σ)
      <span class="bp">|</span> b, <span class="bp">.</span>(true), (Neut.rcont, σ) <span class="bp">=&gt;</span> pure (Neut.rcont, σ)
      <span class="bp">|</span> <span class="bp">.</span>(true), c, (Neut.rbreak, σ) <span class="bp">=&gt;</span> pure (Neut.rbreak, σ)</div></blockquote></div></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk56" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk56"><span class="alectryon-token"><span class="k">&lt;;&gt;</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>ω</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Γ, Δ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>b, c</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>Γ✝, Δ✝</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>α✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b✝, c✝</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ✝</span> <span class="bp">→</span> Assg <span class="bp">Δ✝</span> <span class="bp">→</span> List α<span class="bp">✝</span></span></span></span><br><span><var>s✝</var><span class="hyp-type"><b>: </b><span>Stmt m ω (α<span class="bp">✝</span> :: <span class="bp">Γ✝</span>) <span class="bp">Δ✝</span> true true Unit</span></span></span><br><span><var>ρ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ✝</span></span></span></span><br><span><var>σ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Δ✝</span></span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">h.sfor.nil</span></span><div class="goal-conclusion">ExceptT.run (Stmt.eval.go ρ c<span class="bp">✝</span> b<span class="bp">✝</span> α<span class="bp">✝</span> (R s<span class="bp">✝</span>) σ []) <span class="bp">=</span>
  ExceptT.run <span class="k">do</span>
    <span class="k">let</span> x <span class="bp">←</span> ExceptT.lift (Stmt.eval.go ρ c<span class="bp">✝</span> b<span class="bp">✝</span> α<span class="bp">✝</span> s<span class="bp">✝</span> σ [])
    <span class="k">match</span> b<span class="bp">✝</span>, c<span class="bp">✝</span>, x <span class="k">with</span>
      <span class="bp">|</span> b, c, (Neut.ret o, snd) <span class="bp">=&gt;</span> throw o
      <span class="bp">|</span> b, c, (Neut.val a, σ) <span class="bp">=&gt;</span> pure (Neut.val a, σ)
      <span class="bp">|</span> b, <span class="bp">.</span>(true), (Neut.rcont, σ) <span class="bp">=&gt;</span> pure (Neut.rcont, σ)
      <span class="bp">|</span> <span class="bp">.</span>(true), c, (Neut.rbreak, σ) <span class="bp">=&gt;</span> pure (Neut.rbreak, σ)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Formal-lean-chk57" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>ω</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Γ, Δ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>b, c</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>Γ✝, Δ✝</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>α✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b✝, c✝</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ✝</span> <span class="bp">→</span> Assg <span class="bp">Δ✝</span> <span class="bp">→</span> List α<span class="bp">✝</span></span></span></span><br><span><var>s✝</var><span class="hyp-type"><b>: </b><span>Stmt m ω (α<span class="bp">✝</span> :: <span class="bp">Γ✝</span>) <span class="bp">Δ✝</span> true true Unit</span></span></span><br><span><var>ρ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ✝</span></span></span></span><br><span><var>head✝</var><span class="hyp-type"><b>: </b><span>α<span class="bp">✝</span></span></span></span><br><span><var>tail✝</var><span class="hyp-type"><b>: </b><span>List α<span class="bp">✝</span></span></span></span><br><span><var>σ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Δ✝</span></span></span></span><br></div><label class="goal-separator" for="Formal-lean-chk57"><hr><span class="goal-name">h.sfor.cons</span></label><div class="goal-conclusion">ExceptT.run (Stmt.eval.go ρ c<span class="bp">✝</span> b<span class="bp">✝</span> α<span class="bp">✝</span> (R s<span class="bp">✝</span>) σ (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>)) <span class="bp">=</span>
  ExceptT.run <span class="k">do</span>
    <span class="k">let</span> x <span class="bp">←</span> ExceptT.lift (Stmt.eval.go ρ c<span class="bp">✝</span> b<span class="bp">✝</span> α<span class="bp">✝</span> s<span class="bp">✝</span> σ (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>))
    <span class="k">match</span> b<span class="bp">✝</span>, c<span class="bp">✝</span>, x <span class="k">with</span>
      <span class="bp">|</span> b, c, (Neut.ret o, snd) <span class="bp">=&gt;</span> throw o
      <span class="bp">|</span> b, c, (Neut.val a, σ) <span class="bp">=&gt;</span> pure (Neut.val a, σ)
      <span class="bp">|</span> b, <span class="bp">.</span>(true), (Neut.rcont, σ) <span class="bp">=&gt;</span> pure (Neut.rcont, σ)
      <span class="bp">|</span> <span class="bp">.</span>(true), c, (Neut.rbreak, σ) <span class="bp">=&gt;</span> pure (Neut.rbreak, σ)</div></blockquote></div></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk58" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk58"><span class="alectryon-token"><span class="k">aesop</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><span class="k">add</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">norm</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">unfold</span></span><span class="alectryon-token"> Stmt.eval.go)</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk59" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk59"><span class="alectryon-token"><span class="bp">|</span> _ <span class="bp">=&gt;</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>ω</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Γ, Δ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>b, c</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>Γ✝, Δ✝</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>α✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b✝, c✝</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>β✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>e✝</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ✝</span> <span class="bp">→</span> Assg <span class="bp">Δ✝</span> <span class="bp">→</span> α<span class="bp">✝</span></span></span></span><br><span><var>s✝</var><span class="hyp-type"><b>: </b><span>Stmt m ω <span class="bp">Γ✝</span> (α<span class="bp">✝</span> :: <span class="bp">Δ✝</span>) b<span class="bp">✝</span> c<span class="bp">✝</span> β<span class="bp">✝</span></span></span></span><br><span><var>ρ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ✝</span></span></span></span><br><span><var>σ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Δ✝</span></span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">h.letmut</span></span><div class="goal-conclusion">ExceptT.run (Stmt.eval ρ (R (Stmt.letmut e<span class="bp">✝</span> s<span class="bp">✝</span>)) σ) <span class="bp">=</span>
  ExceptT.run <span class="k">do</span>
    <span class="k">let</span> x <span class="bp">←</span> ExceptT.lift (Stmt.eval ρ (Stmt.letmut e<span class="bp">✝</span> s<span class="bp">✝</span>) σ)
    <span class="k">match</span> b<span class="bp">✝</span>, c<span class="bp">✝</span>, x <span class="k">with</span>
      <span class="bp">|</span> b, c, (Neut.ret o, snd) <span class="bp">=&gt;</span> throw o
      <span class="bp">|</span> b, c, (Neut.val a, σ) <span class="bp">=&gt;</span> pure (Neut.val a, σ)
      <span class="bp">|</span> b, <span class="bp">.</span>(true), (Neut.rcont, σ) <span class="bp">=&gt;</span> pure (Neut.rcont, σ)
      <span class="bp">|</span> <span class="bp">.</span>(true), c, (Neut.rbreak, σ) <span class="bp">=&gt;</span> pure (Neut.rbreak, σ)</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk5a" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk5a"><span class="alectryon-token"><span class="k">aesop</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><span class="k">add</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">unsafe</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">cases</span></span><span class="alectryon-token"> Neut) (</span><span class="alectryon-token"><span class="k">erase</span></span><span class="alectryon-token"> Aesop.BuiltinRules.destructProducts)</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">

<span class="bp">@</span>[</span><span class="alectryon-token"><span class="k">simp</span></span><span class="alectryon-token">] </span><span class="alectryon-token"><span class="kd">theorem</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>eval_mapAssg</var><b>: </b><span>∀ {m : Type → Type u_1} {Γ' Γ : List Type} {ω : Type} {Δ : List Type} {b c : Bool} {β : Type} {ρ : Assg Γ'} {σ : Assg Δ}
  [inst : Monad m] [inst_1 : LawfulMonad m] (f : Assg Γ' → Assg Γ) (s : Stmt m ω Γ Δ b c β),
  Stmt.eval ρ (Stmt.mapAssg f s) σ = Stmt.eval (f ρ) s σ</span></span></div></blockquote></div></small></div><span class="nv">eval_mapAssg</span></span><span class="alectryon-token"> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Monad</var><b>: </b><span>(Type ?u.513583 → Type ?u.513582) → Type (max (?u.513583 + 1) ?u.513582)</span></span></div></blockquote></div></small></div>Monad</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>Type → Type u_1</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token">] [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>LawfulMonad</var><b>: </b><span>(m : Type → Type u_1) → [inst : Monad m] → Prop</span></span></div></blockquote></div></small></div>LawfulMonad</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>Type → Type u_1</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token">] (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>Assg Γ' → Assg Γ</span></span></div></blockquote></div></small></div><span class="nv">f</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Assg</var><b>: </b><span>List (Type ?u.513856) → Type ?u.513856</span></span></div></blockquote></div></small></div>Assg</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Γ'</var><b>: </b><span>List Type</span></span></div></blockquote></div></small></div><span class="nv">Γ&#39;</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Assg</var><b>: </b><span>List (Type ?u.513712) → Type ?u.513712</span></span></div></blockquote></div></small></div>Assg</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Γ</var><b>: </b><span>List Type</span></span></div></blockquote></div></small></div><span class="nv">Γ</span></span><span class="alectryon-token">) : <span class="bp">∀</span> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>Stmt m ω Γ Δ b c β</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt</var><b>: </b><span>(Type → Type u_1) → Type → List Type → List Type → Bool → Bool → Type → Type (max 1 u_1)</span></span></div></blockquote></div></small></div>Stmt</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>Type → Type u_1</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ω</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">ω</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Γ</var><b>: </b><span>List Type</span></span></div></blockquote></div></small></div><span class="nv">Γ</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Δ</var><b>: </b><span>List Type</span></span></div></blockquote></div></small></div><span class="nv">Δ</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>c</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div><span class="nv">c</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>β</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">β</span></span><span class="alectryon-token">), </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt.eval</var><b>: </b><span>{m : Type → Type u_1} →
  {Γ : List Type} →
    {ω : Type} →
      {Δ : List Type} →
        {b c : Bool} → {α : Type} → [inst : Monad m] → Assg Γ → Stmt m ω Γ Δ b c α → Assg Δ → m (Neut ω α b c × Assg Δ)</span></span></div></blockquote></div></small></div>Stmt.eval</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ρ</var><b>: </b><span>Assg Γ'</span></span></div></blockquote></div></small></div><span class="nv">ρ</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt.mapAssg</var><b>: </b><span>{Γ' Γ : List Type} →
  {m : Type → Type u_1} →
    {ω : Type} →
      {Δ : List Type} → {b c : Bool} → {β : Type} → (Assg Γ' → Assg Γ) → Stmt m ω Γ Δ b c β → Stmt m ω Γ' Δ b c β</span></span></div></blockquote></div></small></div>Stmt.mapAssg</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>Assg Γ' → Assg Γ</span></span></div></blockquote></div></small></div><span class="nv">f</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>Stmt m ω Γ Δ b c β</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token">) </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>σ</var><b>: </b><span>Assg Δ</span></span></div></blockquote></div></small></div><span class="nv">σ</span></span><span class="alectryon-token"> <span class="bp">=</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt.eval</var><b>: </b><span>{m : Type → Type u_1} →
  {Γ : List Type} →
    {ω : Type} →
      {Δ : List Type} →
        {b c : Bool} → {α : Type} → [inst : Monad m] → Assg Γ → Stmt m ω Γ Δ b c α → Assg Δ → m (Neut ω α b c × Assg Δ)</span></span></div></blockquote></div></small></div>Stmt.eval</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>Assg Γ' → Assg Γ</span></span></div></blockquote></div></small></div><span class="nv">f</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ρ</var><b>: </b><span>Assg Γ'</span></span></div></blockquote></div></small></div><span class="nv">ρ</span></span><span class="alectryon-token">) </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>Stmt m ω Γ Δ b c β</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>σ</var><b>: </b><span>Assg Δ</span></span></div></blockquote></div></small></div><span class="nv">σ</span></span><span class="alectryon-token"> := </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk5b" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk5b"><span class="alectryon-token"><span class="kd">by</span></span><span class="alectryon-token"></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>Γ', Γ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>ω</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>b, c</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ρ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ&#39;</span></span></span></span><br><span><var>σ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Δ</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ&#39;</span> <span class="bp">→</span> Assg <span class="bp">Γ</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="bp">∀</span> (s : Stmt m ω <span class="bp">Γ</span> <span class="bp">Δ</span> b c β), Stmt.eval ρ (Stmt.mapAssg f s) σ <span class="bp">=</span> Stmt.eval (f ρ) s σ</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk5c" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk5c"><span class="alectryon-token"><span class="k">intro</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>Stmt m ω Γ Δ b c β</span></span></div></blockquote></div></small></div><span class="nv">s</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>Γ', Γ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>ω</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>b, c</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ρ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ&#39;</span></span></span></span><br><span><var>σ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Δ</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ&#39;</span> <span class="bp">→</span> Assg <span class="bp">Γ</span></span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>Stmt m ω <span class="bp">Γ</span> <span class="bp">Δ</span> b c β</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Stmt.eval ρ (Stmt.mapAssg f s) σ <span class="bp">=</span> Stmt.eval (f ρ) s σ</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk5d" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk5d"><span class="alectryon-token"><span class="k">induction</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>Stmt m ω Γ Δ b c β</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">generalizing</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Γ'</var><b>: </b><span>List Type</span></span></div></blockquote></div></small></div><span class="nv">Γ&#39;</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">with</span></span><span class="alectryon-token"></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>Γ', Γ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>ω</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>b, c</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ρ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ&#39;</span></span></span></span><br><span><var>σ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Δ</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ&#39;</span> <span class="bp">→</span> Assg <span class="bp">Γ</span></span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>Stmt m ω <span class="bp">Γ</span> <span class="bp">Δ</span> b c β</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Stmt.eval ρ (Stmt.mapAssg f s) σ <span class="bp">=</span> Stmt.eval (f ρ) s σ</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk5e" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk5e"><span class="alectryon-token"><span class="bp">|</span> sfor </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>Assg Γ✝ → Assg Δ✝ → List α✝</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>Stmt m ω (α✝ :: Γ✝) Δ✝ true true Unit</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ih</var><b>: </b><span>∀ {Γ' : List Type} {ρ : Assg Γ'} {σ : Assg Δ✝} (f : Assg Γ' → Assg (α✝ :: Γ✝)),
  Stmt.eval ρ (Stmt.mapAssg f s) σ = Stmt.eval (f ρ) s σ</span></span></div></blockquote></div></small></div><span class="nv">ih</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>ω</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>b, c</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>Γ✝, Δ✝</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>α✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b✝, c✝</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ✝</span> <span class="bp">→</span> Assg <span class="bp">Δ✝</span> <span class="bp">→</span> List α<span class="bp">✝</span></span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>Stmt m ω (α<span class="bp">✝</span> :: <span class="bp">Γ✝</span>) <span class="bp">Δ✝</span> true true Unit</span></span></span><br><span><var>ih</var><span class="hyp-type"><b>: </b><span><span class="bp">∀</span> {<span class="bp">Γ&#39;</span> : List <span class="kt">Type</span>} {ρ : Assg <span class="bp">Γ&#39;</span>} {σ : Assg <span class="bp">Δ✝</span>} (f : Assg <span class="bp">Γ&#39;</span> <span class="bp">→</span> Assg (α<span class="bp">✝</span> :: <span class="bp">Γ✝</span>)),
  Stmt.eval ρ (Stmt.mapAssg f s) σ <span class="bp">=</span> Stmt.eval (f ρ) s σ</span></span></span><br><span><var>Γ'</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>ρ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ&#39;</span></span></span></span><br><span><var>σ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Δ✝</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ&#39;</span> <span class="bp">→</span> Assg <span class="bp">Γ✝</span></span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">sfor</span></span><div class="goal-conclusion">Stmt.eval ρ (Stmt.mapAssg f (Stmt.sfor e s)) σ <span class="bp">=</span> Stmt.eval (f ρ) (Stmt.sfor e s) σ</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
    </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk5f" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk5f"><span class="alectryon-token"><span class="k">simp</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">only</span></span><span class="alectryon-token"> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt.eval</var><b>: </b><span>{m : Type → Type ?u.514267} →
  {Γ : List Type} →
    {ω : Type} →
      {Δ : List Type} →
        {b c : Bool} → {α : Type} → [inst : Monad m] → Assg Γ → Stmt m ω Γ Δ b c α → Assg Δ → m (Neut ω α b c × Assg Δ)</span></span></div></blockquote></div></small></div>Stmt.eval</span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt.mapAssg</var><b>: </b><span>{Γ' Γ : List Type} →
  {m : Type → Type ?u.514610} →
    {ω : Type} →
      {Δ : List Type} → {b c : Bool} → {β : Type} → (Assg Γ' → Assg Γ) → Stmt m ω Γ Δ b c β → Stmt m ω Γ' Δ b c β</span></span></div></blockquote></div></small></div>Stmt.mapAssg</span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Function.comp</var><b>: </b><span>{α : Sort ?u.514825} → {β : Sort ?u.514824} → {δ : Sort ?u.514823} → (β → δ) → (α → β) → α → δ</span></span></div></blockquote></div></small></div>Function.comp</span><span class="alectryon-token">]</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>ω</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>b, c</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>Γ✝, Δ✝</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>α✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b✝, c✝</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ✝</span> <span class="bp">→</span> Assg <span class="bp">Δ✝</span> <span class="bp">→</span> List α<span class="bp">✝</span></span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>Stmt m ω (α<span class="bp">✝</span> :: <span class="bp">Γ✝</span>) <span class="bp">Δ✝</span> true true Unit</span></span></span><br><span><var>ih</var><span class="hyp-type"><b>: </b><span><span class="bp">∀</span> {<span class="bp">Γ&#39;</span> : List <span class="kt">Type</span>} {ρ : Assg <span class="bp">Γ&#39;</span>} {σ : Assg <span class="bp">Δ✝</span>} (f : Assg <span class="bp">Γ&#39;</span> <span class="bp">→</span> Assg (α<span class="bp">✝</span> :: <span class="bp">Γ✝</span>)),
  Stmt.eval ρ (Stmt.mapAssg f s) σ <span class="bp">=</span> Stmt.eval (f ρ) s σ</span></span></span><br><span><var>Γ'</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>ρ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ&#39;</span></span></span></span><br><span><var>σ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Δ✝</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ&#39;</span> <span class="bp">→</span> Assg <span class="bp">Γ✝</span></span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">sfor</span></span><div class="goal-conclusion">Stmt.eval.go ρ c<span class="bp">✝</span> b<span class="bp">✝</span> α<span class="bp">✝</span>
    (Stmt.mapAssg
      (<span class="k">fun</span> x <span class="bp">=&gt;</span>
        <span class="k">match</span> x <span class="k">with</span>
        <span class="bp">|</span> (a, as) <span class="bp">=&gt;</span> a :: f as)
      s)
    σ (e (f ρ) σ) <span class="bp">=</span>
  Stmt.eval.go (f ρ) c<span class="bp">✝</span> b<span class="bp">✝</span> α<span class="bp">✝</span> s σ (e (f ρ) σ)</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
    </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk60" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk60"><span class="alectryon-token"><span class="k">induction</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>Assg Γ✝ → Assg Δ✝ → List α✝</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>Assg Γ' → Assg Γ✝</span></span></div></blockquote></div></small></div><span class="nv">f</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ρ</var><b>: </b><span>Assg Γ'</span></span></div></blockquote></div></small></div><span class="nv">ρ</span></span><span class="alectryon-token">) </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>σ</var><b>: </b><span>Assg Δ✝</span></span></div></blockquote></div></small></div><span class="nv">σ</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">generalizing</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>σ</var><b>: </b><span>Assg Δ✝</span></span></div></blockquote></div></small></div><span class="nv">σ</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>ω</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>b, c</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>Γ✝, Δ✝</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>α✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b✝, c✝</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ✝</span> <span class="bp">→</span> Assg <span class="bp">Δ✝</span> <span class="bp">→</span> List α<span class="bp">✝</span></span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>Stmt m ω (α<span class="bp">✝</span> :: <span class="bp">Γ✝</span>) <span class="bp">Δ✝</span> true true Unit</span></span></span><br><span><var>ih</var><span class="hyp-type"><b>: </b><span><span class="bp">∀</span> {<span class="bp">Γ&#39;</span> : List <span class="kt">Type</span>} {ρ : Assg <span class="bp">Γ&#39;</span>} {σ : Assg <span class="bp">Δ✝</span>} (f : Assg <span class="bp">Γ&#39;</span> <span class="bp">→</span> Assg (α<span class="bp">✝</span> :: <span class="bp">Γ✝</span>)),
  Stmt.eval ρ (Stmt.mapAssg f s) σ <span class="bp">=</span> Stmt.eval (f ρ) s σ</span></span></span><br><span><var>Γ'</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>ρ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ&#39;</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ&#39;</span> <span class="bp">→</span> Assg <span class="bp">Γ✝</span></span></span></span><br><span><var>σ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Δ✝</span></span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">sfor.nil</span></span><div class="goal-conclusion">Stmt.eval.go ρ c<span class="bp">✝</span> b<span class="bp">✝</span> α<span class="bp">✝</span>
    (Stmt.mapAssg
      (<span class="k">fun</span> x <span class="bp">=&gt;</span>
        <span class="k">match</span> x <span class="k">with</span>
        <span class="bp">|</span> (a, as) <span class="bp">=&gt;</span> a :: f as)
      s)
    σ [] <span class="bp">=</span>
  Stmt.eval.go (f ρ) c<span class="bp">✝</span> b<span class="bp">✝</span> α<span class="bp">✝</span> s σ []</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Formal-lean-chk61" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>ω</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>b, c</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>Γ✝, Δ✝</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>α✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b✝, c✝</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ✝</span> <span class="bp">→</span> Assg <span class="bp">Δ✝</span> <span class="bp">→</span> List α<span class="bp">✝</span></span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>Stmt m ω (α<span class="bp">✝</span> :: <span class="bp">Γ✝</span>) <span class="bp">Δ✝</span> true true Unit</span></span></span><br><span><var>ih</var><span class="hyp-type"><b>: </b><span><span class="bp">∀</span> {<span class="bp">Γ&#39;</span> : List <span class="kt">Type</span>} {ρ : Assg <span class="bp">Γ&#39;</span>} {σ : Assg <span class="bp">Δ✝</span>} (f : Assg <span class="bp">Γ&#39;</span> <span class="bp">→</span> Assg (α<span class="bp">✝</span> :: <span class="bp">Γ✝</span>)),
  Stmt.eval ρ (Stmt.mapAssg f s) σ <span class="bp">=</span> Stmt.eval (f ρ) s σ</span></span></span><br><span><var>Γ'</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>ρ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ&#39;</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ&#39;</span> <span class="bp">→</span> Assg <span class="bp">Γ✝</span></span></span></span><br><span><var>head✝</var><span class="hyp-type"><b>: </b><span>α<span class="bp">✝</span></span></span></span><br><span><var>tail✝</var><span class="hyp-type"><b>: </b><span>List α<span class="bp">✝</span></span></span></span><br><span><var>σ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Δ✝</span></span></span></span><br></div><label class="goal-separator" for="Formal-lean-chk61"><hr><span class="goal-name">sfor.cons</span></label><div class="goal-conclusion">Stmt.eval.go ρ c<span class="bp">✝</span> b<span class="bp">✝</span> α<span class="bp">✝</span>
    (Stmt.mapAssg
      (<span class="k">fun</span> x <span class="bp">=&gt;</span>
        <span class="k">match</span> x <span class="k">with</span>
        <span class="bp">|</span> (a, as) <span class="bp">=&gt;</span> a :: f as)
      s)
    σ (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) <span class="bp">=</span>
  Stmt.eval.go (f ρ) c<span class="bp">✝</span> b<span class="bp">✝</span> α<span class="bp">✝</span> s σ (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>)</div></blockquote></div></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk62" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk62"><span class="alectryon-token"><span class="k">&lt;;&gt;</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>ω</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>b, c</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>Γ✝, Δ✝</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>α✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b✝, c✝</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ✝</span> <span class="bp">→</span> Assg <span class="bp">Δ✝</span> <span class="bp">→</span> List α<span class="bp">✝</span></span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>Stmt m ω (α<span class="bp">✝</span> :: <span class="bp">Γ✝</span>) <span class="bp">Δ✝</span> true true Unit</span></span></span><br><span><var>ih</var><span class="hyp-type"><b>: </b><span><span class="bp">∀</span> {<span class="bp">Γ&#39;</span> : List <span class="kt">Type</span>} {ρ : Assg <span class="bp">Γ&#39;</span>} {σ : Assg <span class="bp">Δ✝</span>} (f : Assg <span class="bp">Γ&#39;</span> <span class="bp">→</span> Assg (α<span class="bp">✝</span> :: <span class="bp">Γ✝</span>)),
  Stmt.eval ρ (Stmt.mapAssg f s) σ <span class="bp">=</span> Stmt.eval (f ρ) s σ</span></span></span><br><span><var>Γ'</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>ρ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ&#39;</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ&#39;</span> <span class="bp">→</span> Assg <span class="bp">Γ✝</span></span></span></span><br><span><var>σ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Δ✝</span></span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">sfor.nil</span></span><div class="goal-conclusion">Stmt.eval.go ρ c<span class="bp">✝</span> b<span class="bp">✝</span> α<span class="bp">✝</span>
    (Stmt.mapAssg
      (<span class="k">fun</span> x <span class="bp">=&gt;</span>
        <span class="k">match</span> x <span class="k">with</span>
        <span class="bp">|</span> (a, as) <span class="bp">=&gt;</span> a :: f as)
      s)
    σ [] <span class="bp">=</span>
  Stmt.eval.go (f ρ) c<span class="bp">✝</span> b<span class="bp">✝</span> α<span class="bp">✝</span> s σ []</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Formal-lean-chk63" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>ω</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>b, c</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>Γ✝, Δ✝</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>α✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b✝, c✝</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ✝</span> <span class="bp">→</span> Assg <span class="bp">Δ✝</span> <span class="bp">→</span> List α<span class="bp">✝</span></span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>Stmt m ω (α<span class="bp">✝</span> :: <span class="bp">Γ✝</span>) <span class="bp">Δ✝</span> true true Unit</span></span></span><br><span><var>ih</var><span class="hyp-type"><b>: </b><span><span class="bp">∀</span> {<span class="bp">Γ&#39;</span> : List <span class="kt">Type</span>} {ρ : Assg <span class="bp">Γ&#39;</span>} {σ : Assg <span class="bp">Δ✝</span>} (f : Assg <span class="bp">Γ&#39;</span> <span class="bp">→</span> Assg (α<span class="bp">✝</span> :: <span class="bp">Γ✝</span>)),
  Stmt.eval ρ (Stmt.mapAssg f s) σ <span class="bp">=</span> Stmt.eval (f ρ) s σ</span></span></span><br><span><var>Γ'</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>ρ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ&#39;</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ&#39;</span> <span class="bp">→</span> Assg <span class="bp">Γ✝</span></span></span></span><br><span><var>head✝</var><span class="hyp-type"><b>: </b><span>α<span class="bp">✝</span></span></span></span><br><span><var>tail✝</var><span class="hyp-type"><b>: </b><span>List α<span class="bp">✝</span></span></span></span><br><span><var>σ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Δ✝</span></span></span></span><br></div><label class="goal-separator" for="Formal-lean-chk63"><hr><span class="goal-name">sfor.cons</span></label><div class="goal-conclusion">Stmt.eval.go ρ c<span class="bp">✝</span> b<span class="bp">✝</span> α<span class="bp">✝</span>
    (Stmt.mapAssg
      (<span class="k">fun</span> x <span class="bp">=&gt;</span>
        <span class="k">match</span> x <span class="k">with</span>
        <span class="bp">|</span> (a, as) <span class="bp">=&gt;</span> a :: f as)
      s)
    σ (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) <span class="bp">=</span>
  Stmt.eval.go (f ρ) c<span class="bp">✝</span> b<span class="bp">✝</span> α<span class="bp">✝</span> s σ (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>)</div></blockquote></div></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk64" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk64"><span class="alectryon-token"><span class="k">aesop</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><span class="k">add</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">norm</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">unfold</span></span><span class="alectryon-token"> Stmt.eval.go)</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk65" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk65"><span class="alectryon-token"><span class="bp">|</span> _ <span class="bp">=&gt;</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>ω</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>b, c</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>Γ✝, Δ✝</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>α✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b✝, c✝</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>β✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>e✝</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ✝</span> <span class="bp">→</span> Assg <span class="bp">Δ✝</span> <span class="bp">→</span> α<span class="bp">✝</span></span></span></span><br><span><var>s✝</var><span class="hyp-type"><b>: </b><span>Stmt m ω <span class="bp">Γ✝</span> (α<span class="bp">✝</span> :: <span class="bp">Δ✝</span>) b<span class="bp">✝</span> c<span class="bp">✝</span> β<span class="bp">✝</span></span></span></span><br><span><var>Γ'</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>ρ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ&#39;</span></span></span></span><br><span><var>σ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Δ✝</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ&#39;</span> <span class="bp">→</span> Assg <span class="bp">Γ✝</span></span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">letmut</span></span><div class="goal-conclusion">Stmt.eval ρ (Stmt.mapAssg f (Stmt.letmut e<span class="bp">✝</span> s<span class="bp">✝</span>)) σ <span class="bp">=</span> Stmt.eval (f ρ) (Stmt.letmut e<span class="bp">✝</span> s<span class="bp">✝</span>) σ</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk66" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk66"><span class="alectryon-token"><span class="k">aesop</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><span class="k">add</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">unsafe</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">cases</span></span><span class="alectryon-token"> Neut)</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span></pre>
<p>We need one last helper function on context bottoms to be able to state the invariant of <code>S</code>, and then
prove various lemmas about their interactions.</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Assg.bot</var><b>: </b><span>{α : Type u_1} → {Γ : List (Type u_1)} → Assg (List.append Γ [α]) → α</span></span></div></blockquote></div></small></div><span class="nv">Assg.bot</span></span><span class="alectryon-token"> : {</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Γ</var><b>: </b><span>List (Type u_1)</span></span></div></blockquote></div></small></div><span class="nv">Γ</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>_</var><b>: </b><span>Type (u_1 + 1)</span></span></div></blockquote></div></small></div>_</span><span class="alectryon-token">} <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Assg</var><b>: </b><span>List (Type u_1) → Type u_1</span></span></div></blockquote></div></small></div>Assg</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Γ</var><b>: </b><span>List (Type u_1)</span></span></div></blockquote></div></small></div><span class="nv">Γ</span></span><span class="alectryon-token"> <span class="bp">++</span> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type u_1</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token">]) <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type u_1</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token">
  <span class="bp">|</span> [],     [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token">]     <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token">
  <span class="bp">|</span> _ :: </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>_</var><b>: </b><span>List (Type u_1)</span></span></div></blockquote></div></small></div>_</span><span class="alectryon-token">, _ :: </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>as</var><b>: </b><span>HList (List.append tail✝ [α])</span></span></div></blockquote></div></small></div><span class="nv">as</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>bot</var><b>: </b><span>{α : Type u_1} → {Γ : List (Type u_1)} → Assg (List.append Γ [α]) → α</span></span></div></blockquote></div></small></div><span class="nv">bot</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>as</var><b>: </b><span>HList (List.append tail✝ [α])</span></span></div></blockquote></div></small></div><span class="nv">as</span></span><span class="alectryon-token">

<span class="bp">@</span>[</span><span class="alectryon-token"><span class="k">simp</span></span><span class="alectryon-token">] </span><span class="alectryon-token"><span class="kd">theorem</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Assg.dropBot_extendBot</var><b>: </b><span>∀ {α : Type u_1} {Γ : List (Type u_1)} (a : α) (σ : Assg Γ), dropBot (extendBot a σ) = σ</span></span></div></blockquote></div></small></div><span class="nv">Assg.dropBot_extendBot</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type u_1</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token">) (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>σ</var><b>: </b><span>Assg Γ</span></span></div></blockquote></div></small></div><span class="nv">σ</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Assg</var><b>: </b><span>List (Type u_1) → Type u_1</span></span></div></blockquote></div></small></div>Assg</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Γ</var><b>: </b><span>List (Type u_1)</span></span></div></blockquote></div></small></div><span class="nv">Γ</span></span><span class="alectryon-token">) : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Assg.dropBot</var><b>: </b><span>{α : Type u_1} → {Γ : List (Type u_1)} → Assg (List.append Γ [α]) → Assg Γ</span></span></div></blockquote></div></small></div>Assg.dropBot</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Assg.extendBot</var><b>: </b><span>{α : Type u_1} → α → {Γ : List (Type u_1)} → Assg Γ → Assg (List.append Γ [α])</span></span></div></blockquote></div></small></div>Assg.extendBot</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>σ</var><b>: </b><span>Assg Γ</span></span></div></blockquote></div></small></div><span class="nv">σ</span></span><span class="alectryon-token">) <span class="bp">=</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>σ</var><b>: </b><span>Assg Γ</span></span></div></blockquote></div></small></div><span class="nv">σ</span></span><span class="alectryon-token"> := </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk67" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk67"><span class="alectryon-token"><span class="kd">by</span></span><span class="alectryon-token"></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>List (<span class="kt">Type</span> u_1)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br><span><var>σ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dropBot (extendBot a σ) <span class="bp">=</span> σ</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk68" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk68"><span class="alectryon-token"><span class="k">induction</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Γ</var><b>: </b><span>List (Type u_1)</span></span></div></blockquote></div></small></div><span class="nv">Γ</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br><span><var>σ</var><span class="hyp-type"><b>: </b><span>Assg []</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">nil</span></span><div class="goal-conclusion">dropBot (extendBot a σ) <span class="bp">=</span> σ</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Formal-lean-chk69" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br><span><var>head✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>tail✝</var><span class="hyp-type"><b>: </b><span>List (<span class="kt">Type</span> u_1)</span></span></span><br><span><var>σ</var><span class="hyp-type"><b>: </b><span>Assg (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>)</span></span></span><br></div><label class="goal-separator" for="Formal-lean-chk69"><hr><span class="goal-name">cons</span></label><div class="goal-conclusion">dropBot (extendBot a σ) <span class="bp">=</span> σ</div></blockquote></div></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk6a" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk6a"><span class="alectryon-token"><span class="k">&lt;;&gt;</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br><span><var>σ</var><span class="hyp-type"><b>: </b><span>Assg []</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">nil</span></span><div class="goal-conclusion">dropBot (extendBot a σ) <span class="bp">=</span> σ</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Formal-lean-chk6b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br><span><var>head✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>tail✝</var><span class="hyp-type"><b>: </b><span>List (<span class="kt">Type</span> u_1)</span></span></span><br><span><var>σ</var><span class="hyp-type"><b>: </b><span>Assg (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>)</span></span></span><br></div><label class="goal-separator" for="Formal-lean-chk6b"><hr><span class="goal-name">cons</span></label><div class="goal-conclusion">dropBot (extendBot a σ) <span class="bp">=</span> σ</div></blockquote></div></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk6c" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk6c"><span class="alectryon-token"><span class="k">cases</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>σ</var><b>: </b><span>Assg []</span></span></div></blockquote></div></small></div><span class="nv">σ</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">nil.unit</span></span><div class="goal-conclusion">dropBot (extendBot a PUnit.unit) <span class="bp">=</span> PUnit.unit</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk6d" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk6d"><span class="alectryon-token"><span class="k">&lt;;&gt;</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">nil.unit</span></span><div class="goal-conclusion">dropBot (extendBot a PUnit.unit) <span class="bp">=</span> PUnit.unit</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk6e" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk6e"><span class="alectryon-token"><span class="k">simp</span></span><span class="alectryon-token"> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>dropBot</var><b>: </b><span>{α : Type ?u.538065} → {Γ : List (Type ?u.538065)} → Assg (List.append Γ [α]) → Assg Γ</span></span></div></blockquote></div></small></div><span class="k">dropBot</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>extendBot</var><b>: </b><span>{α : Type ?u.538765} → α → {Γ : List (Type ?u.538765)} → Assg Γ → Assg (List.append Γ [α])</span></span></div></blockquote></div></small></div><span class="k">extendBot</span></span><span class="alectryon-token">, <span class="bp">*</span>]</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
<span class="bp">@</span>[</span><span class="alectryon-token"><span class="k">simp</span></span><span class="alectryon-token">] </span><span class="alectryon-token"><span class="kd">theorem</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Assg.bot_extendBot</var><b>: </b><span>∀ {α : Type u_1} {Γ : List (Type u_1)} (a : α) (σ : Assg Γ), bot (extendBot a σ) = a</span></span></div></blockquote></div></small></div><span class="nv">Assg.bot_extendBot</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type u_1</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token">) (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>σ</var><b>: </b><span>Assg Γ</span></span></div></blockquote></div></small></div><span class="nv">σ</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Assg</var><b>: </b><span>List (Type u_1) → Type u_1</span></span></div></blockquote></div></small></div>Assg</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Γ</var><b>: </b><span>List (Type u_1)</span></span></div></blockquote></div></small></div><span class="nv">Γ</span></span><span class="alectryon-token">) : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Assg.bot</var><b>: </b><span>{α : Type u_1} → {Γ : List (Type u_1)} → Assg (List.append Γ [α]) → α</span></span></div></blockquote></div></small></div>Assg.bot</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Assg.extendBot</var><b>: </b><span>{α : Type u_1} → α → {Γ : List (Type u_1)} → Assg Γ → Assg (List.append Γ [α])</span></span></div></blockquote></div></small></div>Assg.extendBot</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>σ</var><b>: </b><span>Assg Γ</span></span></div></blockquote></div></small></div><span class="nv">σ</span></span><span class="alectryon-token">) <span class="bp">=</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"> := </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk6f" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk6f"><span class="alectryon-token"><span class="kd">by</span></span><span class="alectryon-token"></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>List (<span class="kt">Type</span> u_1)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br><span><var>σ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bot (extendBot a σ) <span class="bp">=</span> a</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk70" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk70"><span class="alectryon-token"><span class="k">induction</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Γ</var><b>: </b><span>List (Type u_1)</span></span></div></blockquote></div></small></div><span class="nv">Γ</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br><span><var>σ</var><span class="hyp-type"><b>: </b><span>Assg []</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">nil</span></span><div class="goal-conclusion">bot (extendBot a σ) <span class="bp">=</span> a</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Formal-lean-chk71" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br><span><var>head✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>tail✝</var><span class="hyp-type"><b>: </b><span>List (<span class="kt">Type</span> u_1)</span></span></span><br><span><var>σ</var><span class="hyp-type"><b>: </b><span>Assg (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>)</span></span></span><br></div><label class="goal-separator" for="Formal-lean-chk71"><hr><span class="goal-name">cons</span></label><div class="goal-conclusion">bot (extendBot a σ) <span class="bp">=</span> a</div></blockquote></div></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk72" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk72"><span class="alectryon-token"><span class="k">&lt;;&gt;</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br><span><var>σ</var><span class="hyp-type"><b>: </b><span>Assg []</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">nil</span></span><div class="goal-conclusion">bot (extendBot a σ) <span class="bp">=</span> a</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Formal-lean-chk73" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br><span><var>head✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>tail✝</var><span class="hyp-type"><b>: </b><span>List (<span class="kt">Type</span> u_1)</span></span></span><br><span><var>σ</var><span class="hyp-type"><b>: </b><span>Assg (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>)</span></span></span><br></div><label class="goal-separator" for="Formal-lean-chk73"><hr><span class="goal-name">cons</span></label><div class="goal-conclusion">bot (extendBot a σ) <span class="bp">=</span> a</div></blockquote></div></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk74" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk74"><span class="alectryon-token"><span class="k">cases</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>σ</var><b>: </b><span>Assg (head✝ :: tail✝)</span></span></div></blockquote></div></small></div><span class="nv">σ</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">nil.unit</span></span><div class="goal-conclusion">bot (extendBot a PUnit.unit) <span class="bp">=</span> a</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk75" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk75"><span class="alectryon-token"><span class="k">&lt;;&gt;</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">nil.unit</span></span><div class="goal-conclusion">bot (extendBot a PUnit.unit) <span class="bp">=</span> a</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk76" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk76"><span class="alectryon-token"><span class="k">simp</span></span><span class="alectryon-token"> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>bot</var><b>: </b><span>{α : Type ?u.539943} → {Γ : List (Type ?u.539943)} → Assg (List.append Γ [α]) → α</span></span></div></blockquote></div></small></div><span class="k">bot</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>extendBot</var><b>: </b><span>{α : Type ?u.540652} → α → {Γ : List (Type ?u.540652)} → Assg Γ → Assg (List.append Γ [α])</span></span></div></blockquote></div></small></div><span class="k">extendBot</span></span><span class="alectryon-token">, <span class="bp">*</span>]</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
<span class="bp">@</span>[</span><span class="alectryon-token"><span class="k">simp</span></span><span class="alectryon-token">] </span><span class="alectryon-token"><span class="kd">theorem</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Assg.extendBot_bot_dropBot</var><b>: </b><span>∀ {Γ : List (Type u_1)} {α : Type u_1} (σ : Assg (List.append Γ [α])), extendBot (bot σ) (dropBot σ) = σ</span></span></div></blockquote></div></small></div><span class="nv">Assg.extendBot_bot_dropBot</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>σ</var><b>: </b><span>Assg (List.append Γ [α])</span></span></div></blockquote></div></small></div><span class="nv">σ</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Assg</var><b>: </b><span>List (Type u_1) → Type u_1</span></span></div></blockquote></div></small></div>Assg</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Γ</var><b>: </b><span>List (Type u_1)</span></span></div></blockquote></div></small></div><span class="nv">Γ</span></span><span class="alectryon-token"> <span class="bp">++</span> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type u_1</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token">])) : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Assg.extendBot</var><b>: </b><span>{α : Type u_1} → α → {Γ : List (Type u_1)} → Assg Γ → Assg (List.append Γ [α])</span></span></div></blockquote></div></small></div>Assg.extendBot</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Assg.bot</var><b>: </b><span>{α : Type u_1} → {Γ : List (Type u_1)} → Assg (List.append Γ [α]) → α</span></span></div></blockquote></div></small></div>Assg.bot</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>σ</var><b>: </b><span>Assg (List.append Γ [α])</span></span></div></blockquote></div></small></div><span class="nv">σ</span></span><span class="alectryon-token">) (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Assg.dropBot</var><b>: </b><span>{α : Type u_1} → {Γ : List (Type u_1)} → Assg (List.append Γ [α]) → Assg Γ</span></span></div></blockquote></div></small></div>Assg.dropBot</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>σ</var><b>: </b><span>Assg (List.append Γ [α])</span></span></div></blockquote></div></small></div><span class="nv">σ</span></span><span class="alectryon-token">) <span class="bp">=</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>σ</var><b>: </b><span>Assg (List.append Γ [α])</span></span></div></blockquote></div></small></div><span class="nv">σ</span></span><span class="alectryon-token"> := </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk77" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk77"><span class="alectryon-token"><span class="kd">by</span></span><span class="alectryon-token"></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Γ</var><span class="hyp-type"><b>: </b><span>List (<span class="kt">Type</span> u_1)</span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>σ</var><span class="hyp-type"><b>: </b><span>Assg (List.append <span class="bp">Γ</span> [α])</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">extendBot (bot σ) (dropBot σ) <span class="bp">=</span> σ</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk78" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk78"><span class="alectryon-token"><span class="k">induction</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Γ</var><b>: </b><span>List (Type u_1)</span></span></div></blockquote></div></small></div><span class="nv">Γ</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>σ</var><span class="hyp-type"><b>: </b><span>Assg (List.append [] [α])</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">nil</span></span><div class="goal-conclusion">extendBot (bot σ) (dropBot σ) <span class="bp">=</span> σ</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Formal-lean-chk79" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>α, head✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>tail✝</var><span class="hyp-type"><b>: </b><span>List (<span class="kt">Type</span> u_1)</span></span></span><br><span><var>σ</var><span class="hyp-type"><b>: </b><span>Assg (List.append (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) [α])</span></span></span><br></div><label class="goal-separator" for="Formal-lean-chk79"><hr><span class="goal-name">cons</span></label><div class="goal-conclusion">extendBot (bot σ) (dropBot σ) <span class="bp">=</span> σ</div></blockquote></div></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk7a" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk7a"><span class="alectryon-token"><span class="k">&lt;;&gt;</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>σ</var><span class="hyp-type"><b>: </b><span>Assg (List.append [] [α])</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">nil</span></span><div class="goal-conclusion">extendBot (bot σ) (dropBot σ) <span class="bp">=</span> σ</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Formal-lean-chk7b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>α, head✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>tail✝</var><span class="hyp-type"><b>: </b><span>List (<span class="kt">Type</span> u_1)</span></span></span><br><span><var>σ</var><span class="hyp-type"><b>: </b><span>Assg (List.append (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) [α])</span></span></span><br></div><label class="goal-separator" for="Formal-lean-chk7b"><hr><span class="goal-name">cons</span></label><div class="goal-conclusion">extendBot (bot σ) (dropBot σ) <span class="bp">=</span> σ</div></blockquote></div></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk7c" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk7c"><span class="alectryon-token"><span class="k">cases</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>σ</var><b>: </b><span>Assg (List.append (head✝ :: tail✝) [α])</span></span></div></blockquote></div></small></div><span class="nv">σ</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>fst✝</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br><span><var>snd✝</var><span class="hyp-type"><b>: </b><span>HList []</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">nil.mk</span></span><div class="goal-conclusion">extendBot (bot (fst<span class="bp">✝</span>, snd<span class="bp">✝</span>)) (dropBot (fst<span class="bp">✝</span>, snd<span class="bp">✝</span>)) <span class="bp">=</span> (fst<span class="bp">✝</span>, snd<span class="bp">✝</span>)</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk7d" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk7d"><span class="alectryon-token"><span class="k">&lt;;&gt;</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>fst✝</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br><span><var>snd✝</var><span class="hyp-type"><b>: </b><span>HList []</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">nil.mk</span></span><div class="goal-conclusion">extendBot (bot (fst<span class="bp">✝</span>, snd<span class="bp">✝</span>)) (dropBot (fst<span class="bp">✝</span>, snd<span class="bp">✝</span>)) <span class="bp">=</span> (fst<span class="bp">✝</span>, snd<span class="bp">✝</span>)</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk7e" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk7e"><span class="alectryon-token"><span class="k">simp</span></span><span class="alectryon-token"> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>dropBot</var><b>: </b><span>{α : Type ?u.541687} → {Γ : List (Type ?u.541687)} → Assg (List.append Γ [α]) → Assg Γ</span></span></div></blockquote></div></small></div><span class="k">dropBot</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>bot</var><b>: </b><span>{α : Type ?u.541702} → {Γ : List (Type ?u.541702)} → Assg (List.append Γ [α]) → α</span></span></div></blockquote></div></small></div><span class="k">bot</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>extendBot</var><b>: </b><span>{α : Type ?u.541475} → α → {Γ : List (Type ?u.541475)} → Assg Γ → Assg (List.append Γ [α])</span></span></div></blockquote></div></small></div><span class="k">extendBot</span></span><span class="alectryon-token">, <span class="bp">*</span>]</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk7f" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk7f"><span class="alectryon-token"><span class="k">&lt;;&gt;</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk80" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk80"><span class="alectryon-token"><span class="k">rfl</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">

<span class="bp">@</span>[</span><span class="alectryon-token"><span class="k">simp</span></span><span class="alectryon-token">] </span><span class="alectryon-token"><span class="kd">theorem</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Assg.dropBot_set_extendBot_init</var><b>: </b><span>∀ {α : Type u_1} {Γ : List (Type u_1)} {i : Fin (List.length (List.append Γ [α]))} (a : α) (σ : Assg Γ)
  (h : i.val &lt; List.length Γ) {b : List.get (List.append Γ [α]) i},
  dropBot (HList.set (extendBot a σ) i b) =
    HList.set σ { val := i.val, isLt := h }
      ((_ :
          List.get (Γ ++ [α]) { val := i.val, isLt := (_ : i.val &lt; List.length (Γ ++ [α])) } =
            List.get Γ { val := i.val, isLt := h }) ▸
        b)</span></span></div></blockquote></div></small></div><span class="nv">Assg.dropBot_set_extendBot_init</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type u_1</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token">) (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>σ</var><b>: </b><span>Assg Γ</span></span></div></blockquote></div></small></div><span class="nv">σ</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Assg</var><b>: </b><span>List (Type u_1) → Type u_1</span></span></div></blockquote></div></small></div>Assg</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Γ</var><b>: </b><span>List (Type u_1)</span></span></div></blockquote></div></small></div><span class="nv">Γ</span></span><span class="alectryon-token">) (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>h</var><b>: </b><span>i.val &lt; List.length Γ</span></span></div></blockquote></div></small></div><span class="nv">h</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>i</var><b>: </b><span>Fin (List.length (List.append Γ [α]))</span></span></div></blockquote></div></small></div><span class="nv">i</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>1</var><b>: </b><span>{n : Nat} → Fin n → Nat</span></span></div></blockquote></div></small></div><span class="mi">1</span></span><span class="alectryon-token"> <span class="bp">&lt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Γ</var><b>: </b><span>List (Type u_1)</span></span></div></blockquote></div></small></div><span class="nv">Γ</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>length</var><b>: </b><span>{α : Type (u_1 + 1)} → List α → Nat</span></span></div></blockquote></div></small></div>length</span><span class="alectryon-token">) {</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>List.get (List.append Γ [α]) i</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token">} : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Assg.dropBot</var><b>: </b><span>{α : Type u_1} → {Γ : List (Type u_1)} → Assg (List.append Γ [α]) → Assg Γ</span></span></div></blockquote></div></small></div>Assg.dropBot</span><span class="alectryon-token"> ((</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Assg.extendBot</var><b>: </b><span>{α : Type u_1} → α → {Γ : List (Type u_1)} → Assg Γ → Assg (List.append Γ [α])</span></span></div></blockquote></div></small></div>Assg.extendBot</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>σ</var><b>: </b><span>Assg Γ</span></span></div></blockquote></div></small></div><span class="nv">σ</span></span><span class="alectryon-token">)<span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>set</var><b>: </b><span>{αs : List (Type u_1)} → HList αs → (i : Fin (List.length αs)) → List.get αs i → HList αs</span></span></div></blockquote></div></small></div><span class="na">set</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>i</var><b>: </b><span>Fin (List.length (List.append Γ [α]))</span></span></div></blockquote></div></small></div><span class="nv">i</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>List.get (List.append Γ [α]) i</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token">) <span class="bp">=</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>σ</var><b>: </b><span>Assg Γ</span></span></div></blockquote></div></small></div><span class="nv">σ</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>set</var><b>: </b><span>{αs : List (Type u_1)} → HList αs → (i : Fin (List.length αs)) → List.get αs i → HList αs</span></span></div></blockquote></div></small></div>set</span><span class="alectryon-token"> ⟨</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>i</var><b>: </b><span>Fin (List.length (List.append Γ [α]))</span></span></div></blockquote></div></small></div><span class="nv">i</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>1</var><b>: </b><span>{n : Nat} → Fin n → Nat</span></span></div></blockquote></div></small></div><span class="mi">1</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>h</var><b>: </b><span>i.val &lt; List.length Γ</span></span></div></blockquote></div></small></div><span class="nv">h</span></span><span class="alectryon-token">⟩ (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>List.get_append_left</var><b>: </b><span>∀ {α : Type (u_1 + 1)} {i : Nat} (as bs : List α) (h : i &lt; List.length as) {h' : i &lt; List.length (as ++ bs)},
  List.get (as ++ bs) { val := i, isLt := h' } = List.get as { val := i, isLt := h }</span></span></div></blockquote></div></small></div>List.get_append_left</span><span class="alectryon-token"> <span class="bp">..</span> <span class="bp">▸</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>List.get (List.append Γ [α]) i</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token">) := </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk81" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk81"><span class="alectryon-token"><span class="kd">by</span></span><span class="alectryon-token"></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>List (<span class="kt">Type</span> u_1)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>Fin (List.length (List.append <span class="bp">Γ</span> [α]))</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br><span><var>σ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ</span></span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>i.val <span class="bp">&lt;</span> List.length <span class="bp">Γ</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>List.get (List.append <span class="bp">Γ</span> [α]) i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dropBot (HList.set (extendBot a σ) i b) <span class="bp">=</span>
  HList.set σ { val := i.val, isLt := h }
    ((_ :
        List.get (<span class="bp">Γ</span> <span class="bp">++</span> [α]) { val := i.val, isLt := (_ : i.val <span class="bp">&lt;</span> List.length (<span class="bp">Γ</span> <span class="bp">++</span> [α])) } <span class="bp">=</span>
          List.get <span class="bp">Γ</span> { val := i.val, isLt := h }) <span class="bp">▸</span>
      b)</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk82" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk82"><span class="alectryon-token"><span class="k">induction</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Γ</var><b>: </b><span>List (Type u_1)</span></span></div></blockquote></div></small></div><span class="nv">Γ</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">with</span></span><span class="alectryon-token"></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>List (<span class="kt">Type</span> u_1)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>Fin (List.length (List.append <span class="bp">Γ</span> [α]))</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br><span><var>σ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ</span></span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>i.val <span class="bp">&lt;</span> List.length <span class="bp">Γ</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>List.get (List.append <span class="bp">Γ</span> [α]) i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dropBot (HList.set (extendBot a σ) i b) <span class="bp">=</span>
  HList.set σ { val := i.val, isLt := h }
    ((_ :
        List.get (<span class="bp">Γ</span> <span class="bp">++</span> [α]) { val := i.val, isLt := (_ : i.val <span class="bp">&lt;</span> List.length (<span class="bp">Γ</span> <span class="bp">++</span> [α])) } <span class="bp">=</span>
          List.get <span class="bp">Γ</span> { val := i.val, isLt := h }) <span class="bp">▸</span>
      b)</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk83" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk83"><span class="alectryon-token"><span class="bp">|</span> nil <span class="bp">=&gt;</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>Fin (List.length (List.append [] [α]))</span></span></span><br><span><var>σ</var><span class="hyp-type"><b>: </b><span>Assg []</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>i.val <span class="bp">&lt;</span> List.length []</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>List.get (List.append [] [α]) i</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">nil</span></span><div class="goal-conclusion">dropBot (HList.set (extendBot a σ) i b) <span class="bp">=</span>
  HList.set σ { val := i.val, isLt := h }
    ((_ :
        List.get ([] <span class="bp">++</span> [α]) { val := i.val, isLt := (_ : i.val <span class="bp">&lt;</span> List.length ([] <span class="bp">++</span> [α])) } <span class="bp">=</span>
          List.get [] { val := i.val, isLt := h }) <span class="bp">▸</span>
      b)</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk84" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk84"><span class="alectryon-token"><span class="k">contradiction</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk85" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk85"><span class="alectryon-token"><span class="bp">|</span> cons  </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>_</var><b>: </b><span>Type u_1</span></span></div></blockquote></div></small></div>_</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>_</var><b>: </b><span>List (Type u_1)</span></span></div></blockquote></div></small></div>_</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ih</var><b>: </b><span>∀ {i : Fin (List.length (List.append tail✝ [α]))} (σ : Assg tail✝) (h : i.val &lt; List.length tail✝)
  {b : List.get (List.append tail✝ [α]) i},
  dropBot (HList.set (extendBot a σ) i b) =
    HList.set σ { val := i.val, isLt := h }
      ((_ :
          List.get (tail✝ ++ [α]) { val := i.val, isLt := (_ : i.val &lt; List.length (tail✝ ++ [α])) } =
            List.get tail✝ { val := i.val, isLt := h }) ▸
        b)</span></span></div></blockquote></div></small></div><span class="nv">ih</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br><span><var>head✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>tail✝</var><span class="hyp-type"><b>: </b><span>List (<span class="kt">Type</span> u_1)</span></span></span><br><span><var>ih</var><span class="hyp-type"><b>: </b><span><span class="bp">∀</span> {i : Fin (List.length (List.append tail<span class="bp">✝</span> [α]))} (σ : Assg tail<span class="bp">✝</span>) (h : i.val <span class="bp">&lt;</span> List.length tail<span class="bp">✝</span>)
  {b : List.get (List.append tail<span class="bp">✝</span> [α]) i},
  dropBot (HList.set (extendBot a σ) i b) <span class="bp">=</span>
    HList.set σ { val := i.val, isLt := h }
      ((_ :
          List.get (tail<span class="bp">✝</span> <span class="bp">++</span> [α]) { val := i.val, isLt := (_ : i.val <span class="bp">&lt;</span> List.length (tail<span class="bp">✝</span> <span class="bp">++</span> [α])) } <span class="bp">=</span>
            List.get tail<span class="bp">✝</span> { val := i.val, isLt := h }) <span class="bp">▸</span>
        b)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>Fin (List.length (List.append (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) [α]))</span></span></span><br><span><var>σ</var><span class="hyp-type"><b>: </b><span>Assg (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>)</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>i.val <span class="bp">&lt;</span> List.length (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>)</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>List.get (List.append (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) [α]) i</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">cons</span></span><div class="goal-conclusion">dropBot (HList.set (extendBot a σ) i b) <span class="bp">=</span>
  HList.set σ { val := i.val, isLt := h }
    ((_ :
        List.get (head<span class="bp">✝</span> :: tail<span class="bp">✝</span> <span class="bp">++</span> [α]) { val := i.val, isLt := (_ : i.val <span class="bp">&lt;</span> List.length (head<span class="bp">✝</span> :: tail<span class="bp">✝</span> <span class="bp">++</span> [α])) } <span class="bp">=</span>
          List.get (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) { val := i.val, isLt := h }) <span class="bp">▸</span>
      b)</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
    </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk86" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk86"><span class="alectryon-token"><span class="k">cases</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>σ</var><b>: </b><span>Assg (head✝ :: tail✝)</span></span></div></blockquote></div></small></div><span class="nv">σ</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br><span><var>head✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>tail✝</var><span class="hyp-type"><b>: </b><span>List (<span class="kt">Type</span> u_1)</span></span></span><br><span><var>ih</var><span class="hyp-type"><b>: </b><span><span class="bp">∀</span> {i : Fin (List.length (List.append tail<span class="bp">✝</span> [α]))} (σ : Assg tail<span class="bp">✝</span>) (h : i.val <span class="bp">&lt;</span> List.length tail<span class="bp">✝</span>)
  {b : List.get (List.append tail<span class="bp">✝</span> [α]) i},
  dropBot (HList.set (extendBot a σ) i b) <span class="bp">=</span>
    HList.set σ { val := i.val, isLt := h }
      ((_ :
          List.get (tail<span class="bp">✝</span> <span class="bp">++</span> [α]) { val := i.val, isLt := (_ : i.val <span class="bp">&lt;</span> List.length (tail<span class="bp">✝</span> <span class="bp">++</span> [α])) } <span class="bp">=</span>
            List.get tail<span class="bp">✝</span> { val := i.val, isLt := h }) <span class="bp">▸</span>
        b)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>Fin (List.length (List.append (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) [α]))</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>i.val <span class="bp">&lt;</span> List.length (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>)</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>List.get (List.append (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) [α]) i</span></span></span><br><span><var>fst✝</var><span class="hyp-type"><b>: </b><span>head<span class="bp">✝</span></span></span></span><br><span><var>snd✝</var><span class="hyp-type"><b>: </b><span>HList tail<span class="bp">✝</span></span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">cons.mk</span></span><div class="goal-conclusion">dropBot (HList.set (extendBot a (fst<span class="bp">✝</span>, snd<span class="bp">✝</span>)) i b) <span class="bp">=</span>
  HList.set (fst<span class="bp">✝</span>, snd<span class="bp">✝</span>) { val := i.val, isLt := h }
    ((_ :
        List.get (head<span class="bp">✝</span> :: tail<span class="bp">✝</span> <span class="bp">++</span> [α]) { val := i.val, isLt := (_ : i.val <span class="bp">&lt;</span> List.length (head<span class="bp">✝</span> :: tail<span class="bp">✝</span> <span class="bp">++</span> [α])) } <span class="bp">=</span>
          List.get (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) { val := i.val, isLt := h }) <span class="bp">▸</span>
      b)</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
    </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk87" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk87"><span class="alectryon-token"><span class="k">have</span></span><span class="alectryon-token"> ⟨</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>i</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">i</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>h'</var><b>: </b><span>i &lt; List.length (List.append (head✝ :: tail✝) [α])</span></span></div></blockquote></div></small></div><span class="nv">h&#39;</span></span><span class="alectryon-token">⟩ := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>i</var><b>: </b><span>Fin (List.length (List.append (head✝ :: tail✝) [α]))</span></span></div></blockquote></div></small></div><span class="nv">i</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br><span><var>head✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>tail✝</var><span class="hyp-type"><b>: </b><span>List (<span class="kt">Type</span> u_1)</span></span></span><br><span><var>ih</var><span class="hyp-type"><b>: </b><span><span class="bp">∀</span> {i : Fin (List.length (List.append tail<span class="bp">✝</span> [α]))} (σ : Assg tail<span class="bp">✝</span>) (h : i.val <span class="bp">&lt;</span> List.length tail<span class="bp">✝</span>)
  {b : List.get (List.append tail<span class="bp">✝</span> [α]) i},
  dropBot (HList.set (extendBot a σ) i b) <span class="bp">=</span>
    HList.set σ { val := i.val, isLt := h }
      ((_ :
          List.get (tail<span class="bp">✝</span> <span class="bp">++</span> [α]) { val := i.val, isLt := (_ : i.val <span class="bp">&lt;</span> List.length (tail<span class="bp">✝</span> <span class="bp">++</span> [α])) } <span class="bp">=</span>
            List.get tail<span class="bp">✝</span> { val := i.val, isLt := h }) <span class="bp">▸</span>
        b)</span></span></span><br><span><var>i✝</var><span class="hyp-type"><b>: </b><span>Fin (List.length (List.append (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) [α]))</span></span></span><br><span><var>fst✝</var><span class="hyp-type"><b>: </b><span>head<span class="bp">✝</span></span></span></span><br><span><var>snd✝</var><span class="hyp-type"><b>: </b><span>HList tail<span class="bp">✝</span></span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>h'</var><span class="hyp-type"><b>: </b><span>i <span class="bp">&lt;</span> List.length (List.append (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) [α])</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>{ val := i, isLt := h&#39; }<span class="bp">.</span>val <span class="bp">&lt;</span> List.length (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>)</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>List.get (List.append (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) [α]) { val := i, isLt := h&#39; }</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">cons.mk</span></span><div class="goal-conclusion">dropBot (HList.set (extendBot a (fst<span class="bp">✝</span>, snd<span class="bp">✝</span>)) { val := i, isLt := h&#39; } b) <span class="bp">=</span>
  HList.set (fst<span class="bp">✝</span>, snd<span class="bp">✝</span>) { val := { val := i, isLt := h&#39; }<span class="bp">.</span>val, isLt := h }
    ((_ :
        List.get (head<span class="bp">✝</span> :: tail<span class="bp">✝</span> <span class="bp">++</span> [α])
            { val := { val := i, isLt := h&#39; }<span class="bp">.</span>val,
              isLt := (_ : { val := i, isLt := h&#39; }<span class="bp">.</span>val <span class="bp">&lt;</span> List.length (head<span class="bp">✝</span> :: tail<span class="bp">✝</span> <span class="bp">++</span> [α])) } <span class="bp">=</span>
          List.get (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) { val := { val := i, isLt := h&#39; }<span class="bp">.</span>val, isLt := h }) <span class="bp">▸</span>
      b)</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
    </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk88" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk88"><span class="alectryon-token"><span class="k">cases</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>i</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">i</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br><span><var>head✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>tail✝</var><span class="hyp-type"><b>: </b><span>List (<span class="kt">Type</span> u_1)</span></span></span><br><span><var>ih</var><span class="hyp-type"><b>: </b><span><span class="bp">∀</span> {i : Fin (List.length (List.append tail<span class="bp">✝</span> [α]))} (σ : Assg tail<span class="bp">✝</span>) (h : i.val <span class="bp">&lt;</span> List.length tail<span class="bp">✝</span>)
  {b : List.get (List.append tail<span class="bp">✝</span> [α]) i},
  dropBot (HList.set (extendBot a σ) i b) <span class="bp">=</span>
    HList.set σ { val := i.val, isLt := h }
      ((_ :
          List.get (tail<span class="bp">✝</span> <span class="bp">++</span> [α]) { val := i.val, isLt := (_ : i.val <span class="bp">&lt;</span> List.length (tail<span class="bp">✝</span> <span class="bp">++</span> [α])) } <span class="bp">=</span>
            List.get tail<span class="bp">✝</span> { val := i.val, isLt := h }) <span class="bp">▸</span>
        b)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>Fin (List.length (List.append (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) [α]))</span></span></span><br><span><var>fst✝</var><span class="hyp-type"><b>: </b><span>head<span class="bp">✝</span></span></span></span><br><span><var>snd✝</var><span class="hyp-type"><b>: </b><span>HList tail<span class="bp">✝</span></span></span></span><br><span><var>h'</var><span class="hyp-type"><b>: </b><span>Nat.zero <span class="bp">&lt;</span> List.length (List.append (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) [α])</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>{ val := Nat.zero, isLt := h&#39; }<span class="bp">.</span>val <span class="bp">&lt;</span> List.length (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>)</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>List.get (List.append (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) [α]) { val := Nat.zero, isLt := h&#39; }</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">cons.mk.zero</span></span><div class="goal-conclusion">dropBot (HList.set (extendBot a (fst<span class="bp">✝</span>, snd<span class="bp">✝</span>)) { val := Nat.zero, isLt := h&#39; } b) <span class="bp">=</span>
  HList.set (fst<span class="bp">✝</span>, snd<span class="bp">✝</span>) { val := { val := Nat.zero, isLt := h&#39; }<span class="bp">.</span>val, isLt := h }
    ((_ :
        List.get (head<span class="bp">✝</span> :: tail<span class="bp">✝</span> <span class="bp">++</span> [α])
            { val := { val := Nat.zero, isLt := h&#39; }<span class="bp">.</span>val,
              isLt := (_ : { val := Nat.zero, isLt := h&#39; }<span class="bp">.</span>val <span class="bp">&lt;</span> List.length (head<span class="bp">✝</span> :: tail<span class="bp">✝</span> <span class="bp">++</span> [α])) } <span class="bp">=</span>
          List.get (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) { val := { val := Nat.zero, isLt := h&#39; }<span class="bp">.</span>val, isLt := h }) <span class="bp">▸</span>
      b)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Formal-lean-chk89" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br><span><var>head✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>tail✝</var><span class="hyp-type"><b>: </b><span>List (<span class="kt">Type</span> u_1)</span></span></span><br><span><var>ih</var><span class="hyp-type"><b>: </b><span><span class="bp">∀</span> {i : Fin (List.length (List.append tail<span class="bp">✝</span> [α]))} (σ : Assg tail<span class="bp">✝</span>) (h : i.val <span class="bp">&lt;</span> List.length tail<span class="bp">✝</span>)
  {b : List.get (List.append tail<span class="bp">✝</span> [α]) i},
  dropBot (HList.set (extendBot a σ) i b) <span class="bp">=</span>
    HList.set σ { val := i.val, isLt := h }
      ((_ :
          List.get (tail<span class="bp">✝</span> <span class="bp">++</span> [α]) { val := i.val, isLt := (_ : i.val <span class="bp">&lt;</span> List.length (tail<span class="bp">✝</span> <span class="bp">++</span> [α])) } <span class="bp">=</span>
            List.get tail<span class="bp">✝</span> { val := i.val, isLt := h }) <span class="bp">▸</span>
        b)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>Fin (List.length (List.append (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) [α]))</span></span></span><br><span><var>fst✝</var><span class="hyp-type"><b>: </b><span>head<span class="bp">✝</span></span></span></span><br><span><var>snd✝</var><span class="hyp-type"><b>: </b><span>HList tail<span class="bp">✝</span></span></span></span><br><span><var>n✝</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>h'</var><span class="hyp-type"><b>: </b><span>Nat.succ n<span class="bp">✝</span> <span class="bp">&lt;</span> List.length (List.append (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) [α])</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>{ val := Nat.succ n<span class="bp">✝</span>, isLt := h&#39; }<span class="bp">.</span>val <span class="bp">&lt;</span> List.length (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>)</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>List.get (List.append (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) [α]) { val := Nat.succ n<span class="bp">✝</span>, isLt := h&#39; }</span></span></span><br></div><label class="goal-separator" for="Formal-lean-chk89"><hr><span class="goal-name">cons.mk.succ</span></label><div class="goal-conclusion">dropBot (HList.set (extendBot a (fst<span class="bp">✝</span>, snd<span class="bp">✝</span>)) { val := Nat.succ n<span class="bp">✝</span>, isLt := h&#39; } b) <span class="bp">=</span>
  HList.set (fst<span class="bp">✝</span>, snd<span class="bp">✝</span>) { val := { val := Nat.succ n<span class="bp">✝</span>, isLt := h&#39; }<span class="bp">.</span>val, isLt := h }
    ((_ :
        List.get (head<span class="bp">✝</span> :: tail<span class="bp">✝</span> <span class="bp">++</span> [α])
            { val := { val := Nat.succ n<span class="bp">✝</span>, isLt := h&#39; }<span class="bp">.</span>val,
              isLt := (_ : { val := Nat.succ n<span class="bp">✝</span>, isLt := h&#39; }<span class="bp">.</span>val <span class="bp">&lt;</span> List.length (head<span class="bp">✝</span> :: tail<span class="bp">✝</span> <span class="bp">++</span> [α])) } <span class="bp">=</span>
          List.get (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) { val := { val := Nat.succ n<span class="bp">✝</span>, isLt := h&#39; }<span class="bp">.</span>val, isLt := h }) <span class="bp">▸</span>
      b)</div></blockquote></div></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk8a" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk8a"><span class="alectryon-token"><span class="k">&lt;;&gt;</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br><span><var>head✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>tail✝</var><span class="hyp-type"><b>: </b><span>List (<span class="kt">Type</span> u_1)</span></span></span><br><span><var>ih</var><span class="hyp-type"><b>: </b><span><span class="bp">∀</span> {i : Fin (List.length (List.append tail<span class="bp">✝</span> [α]))} (σ : Assg tail<span class="bp">✝</span>) (h : i.val <span class="bp">&lt;</span> List.length tail<span class="bp">✝</span>)
  {b : List.get (List.append tail<span class="bp">✝</span> [α]) i},
  dropBot (HList.set (extendBot a σ) i b) <span class="bp">=</span>
    HList.set σ { val := i.val, isLt := h }
      ((_ :
          List.get (tail<span class="bp">✝</span> <span class="bp">++</span> [α]) { val := i.val, isLt := (_ : i.val <span class="bp">&lt;</span> List.length (tail<span class="bp">✝</span> <span class="bp">++</span> [α])) } <span class="bp">=</span>
            List.get tail<span class="bp">✝</span> { val := i.val, isLt := h }) <span class="bp">▸</span>
        b)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>Fin (List.length (List.append (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) [α]))</span></span></span><br><span><var>fst✝</var><span class="hyp-type"><b>: </b><span>head<span class="bp">✝</span></span></span></span><br><span><var>snd✝</var><span class="hyp-type"><b>: </b><span>HList tail<span class="bp">✝</span></span></span></span><br><span><var>h'</var><span class="hyp-type"><b>: </b><span>Nat.zero <span class="bp">&lt;</span> List.length (List.append (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) [α])</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>{ val := Nat.zero, isLt := h&#39; }<span class="bp">.</span>val <span class="bp">&lt;</span> List.length (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>)</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>List.get (List.append (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) [α]) { val := Nat.zero, isLt := h&#39; }</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">cons.mk.zero</span></span><div class="goal-conclusion">dropBot (HList.set (extendBot a (fst<span class="bp">✝</span>, snd<span class="bp">✝</span>)) { val := Nat.zero, isLt := h&#39; } b) <span class="bp">=</span>
  HList.set (fst<span class="bp">✝</span>, snd<span class="bp">✝</span>) { val := { val := Nat.zero, isLt := h&#39; }<span class="bp">.</span>val, isLt := h }
    ((_ :
        List.get (head<span class="bp">✝</span> :: tail<span class="bp">✝</span> <span class="bp">++</span> [α])
            { val := { val := Nat.zero, isLt := h&#39; }<span class="bp">.</span>val,
              isLt := (_ : { val := Nat.zero, isLt := h&#39; }<span class="bp">.</span>val <span class="bp">&lt;</span> List.length (head<span class="bp">✝</span> :: tail<span class="bp">✝</span> <span class="bp">++</span> [α])) } <span class="bp">=</span>
          List.get (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) { val := { val := Nat.zero, isLt := h&#39; }<span class="bp">.</span>val, isLt := h }) <span class="bp">▸</span>
      b)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Formal-lean-chk8b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br><span><var>head✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>tail✝</var><span class="hyp-type"><b>: </b><span>List (<span class="kt">Type</span> u_1)</span></span></span><br><span><var>ih</var><span class="hyp-type"><b>: </b><span><span class="bp">∀</span> {i : Fin (List.length (List.append tail<span class="bp">✝</span> [α]))} (σ : Assg tail<span class="bp">✝</span>) (h : i.val <span class="bp">&lt;</span> List.length tail<span class="bp">✝</span>)
  {b : List.get (List.append tail<span class="bp">✝</span> [α]) i},
  dropBot (HList.set (extendBot a σ) i b) <span class="bp">=</span>
    HList.set σ { val := i.val, isLt := h }
      ((_ :
          List.get (tail<span class="bp">✝</span> <span class="bp">++</span> [α]) { val := i.val, isLt := (_ : i.val <span class="bp">&lt;</span> List.length (tail<span class="bp">✝</span> <span class="bp">++</span> [α])) } <span class="bp">=</span>
            List.get tail<span class="bp">✝</span> { val := i.val, isLt := h }) <span class="bp">▸</span>
        b)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>Fin (List.length (List.append (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) [α]))</span></span></span><br><span><var>fst✝</var><span class="hyp-type"><b>: </b><span>head<span class="bp">✝</span></span></span></span><br><span><var>snd✝</var><span class="hyp-type"><b>: </b><span>HList tail<span class="bp">✝</span></span></span></span><br><span><var>n✝</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>h'</var><span class="hyp-type"><b>: </b><span>Nat.succ n<span class="bp">✝</span> <span class="bp">&lt;</span> List.length (List.append (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) [α])</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>{ val := Nat.succ n<span class="bp">✝</span>, isLt := h&#39; }<span class="bp">.</span>val <span class="bp">&lt;</span> List.length (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>)</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>List.get (List.append (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) [α]) { val := Nat.succ n<span class="bp">✝</span>, isLt := h&#39; }</span></span></span><br></div><label class="goal-separator" for="Formal-lean-chk8b"><hr><span class="goal-name">cons.mk.succ</span></label><div class="goal-conclusion">dropBot (HList.set (extendBot a (fst<span class="bp">✝</span>, snd<span class="bp">✝</span>)) { val := Nat.succ n<span class="bp">✝</span>, isLt := h&#39; } b) <span class="bp">=</span>
  HList.set (fst<span class="bp">✝</span>, snd<span class="bp">✝</span>) { val := { val := Nat.succ n<span class="bp">✝</span>, isLt := h&#39; }<span class="bp">.</span>val, isLt := h }
    ((_ :
        List.get (head<span class="bp">✝</span> :: tail<span class="bp">✝</span> <span class="bp">++</span> [α])
            { val := { val := Nat.succ n<span class="bp">✝</span>, isLt := h&#39; }<span class="bp">.</span>val,
              isLt := (_ : { val := Nat.succ n<span class="bp">✝</span>, isLt := h&#39; }<span class="bp">.</span>val <span class="bp">&lt;</span> List.length (head<span class="bp">✝</span> :: tail<span class="bp">✝</span> <span class="bp">++</span> [α])) } <span class="bp">=</span>
          List.get (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) { val := { val := Nat.succ n<span class="bp">✝</span>, isLt := h&#39; }<span class="bp">.</span>val, isLt := h }) <span class="bp">▸</span>
      b)</div></blockquote></div></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk8c" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk8c"><span class="alectryon-token"><span class="k">simp</span></span><span class="alectryon-token"> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>HList.set</var><b>: </b><span>{αs : List (Type ?u.545613)} → HList αs → (i : Fin (List.length αs)) → List.get αs i → HList αs</span></span></div></blockquote></div></small></div><span class="k">HList.set</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>dropBot</var><b>: </b><span>{α : Type ?u.545644} → {Γ : List (Type ?u.545644)} → Assg (List.append Γ [α]) → Assg Γ</span></span></div></blockquote></div></small></div><span class="k">dropBot</span></span><span class="alectryon-token">]</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br><span><var>head✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>tail✝</var><span class="hyp-type"><b>: </b><span>List (<span class="kt">Type</span> u_1)</span></span></span><br><span><var>ih</var><span class="hyp-type"><b>: </b><span><span class="bp">∀</span> {i : Fin (List.length (List.append tail<span class="bp">✝</span> [α]))} (σ : Assg tail<span class="bp">✝</span>) (h : i.val <span class="bp">&lt;</span> List.length tail<span class="bp">✝</span>)
  {b : List.get (List.append tail<span class="bp">✝</span> [α]) i},
  dropBot (HList.set (extendBot a σ) i b) <span class="bp">=</span>
    HList.set σ { val := i.val, isLt := h }
      ((_ :
          List.get (tail<span class="bp">✝</span> <span class="bp">++</span> [α]) { val := i.val, isLt := (_ : i.val <span class="bp">&lt;</span> List.length (tail<span class="bp">✝</span> <span class="bp">++</span> [α])) } <span class="bp">=</span>
            List.get tail<span class="bp">✝</span> { val := i.val, isLt := h }) <span class="bp">▸</span>
        b)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>Fin (List.length (List.append (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) [α]))</span></span></span><br><span><var>fst✝</var><span class="hyp-type"><b>: </b><span>head<span class="bp">✝</span></span></span></span><br><span><var>snd✝</var><span class="hyp-type"><b>: </b><span>HList tail<span class="bp">✝</span></span></span></span><br><span><var>n✝</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>h'</var><span class="hyp-type"><b>: </b><span>Nat.succ n<span class="bp">✝</span> <span class="bp">&lt;</span> List.length (List.append (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) [α])</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>{ val := Nat.succ n<span class="bp">✝</span>, isLt := h&#39; }<span class="bp">.</span>val <span class="bp">&lt;</span> List.length (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>)</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>List.get (List.append (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) [α]) { val := Nat.succ n<span class="bp">✝</span>, isLt := h&#39; }</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">cons.mk.succ</span></span><div class="goal-conclusion">fst<span class="bp">✝</span> :: dropBot (HList.set (extendBot a snd<span class="bp">✝</span>) { val := n<span class="bp">✝</span>, isLt := (_ : Nat.succ n<span class="bp">✝</span> <span class="bp">≤</span> List.length (tail<span class="bp">✝</span> <span class="bp">++</span> [α])) } b) <span class="bp">=</span>
  fst<span class="bp">✝</span> ::
    HList.set snd<span class="bp">✝</span> { val := n<span class="bp">✝</span>, isLt := (_ : Nat.succ n<span class="bp">✝</span> <span class="bp">≤</span> List.length tail<span class="bp">✝</span>) }
      ((_ :
          List.get (head<span class="bp">✝</span> :: tail<span class="bp">✝</span> <span class="bp">++</span> [α])
              { val := { val := Nat.succ n<span class="bp">✝</span>, isLt := h&#39; }<span class="bp">.</span>val,
                isLt := (_ : { val := Nat.succ n<span class="bp">✝</span>, isLt := h&#39; }<span class="bp">.</span>val <span class="bp">&lt;</span> List.length (head<span class="bp">✝</span> :: tail<span class="bp">✝</span> <span class="bp">++</span> [α])) } <span class="bp">=</span>
            List.get (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) { val := { val := Nat.succ n<span class="bp">✝</span>, isLt := h&#39; }<span class="bp">.</span>val, isLt := h }) <span class="bp">▸</span>
        b)</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
    </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk8d" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk8d"><span class="alectryon-token"><span class="k">rw</span></span><span class="alectryon-token"> [</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br><span><var>head✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>tail✝</var><span class="hyp-type"><b>: </b><span>List (<span class="kt">Type</span> u_1)</span></span></span><br><span><var>ih</var><span class="hyp-type"><b>: </b><span><span class="bp">∀</span> {i : Fin (List.length (List.append tail<span class="bp">✝</span> [α]))} (σ : Assg tail<span class="bp">✝</span>) (h : i.val <span class="bp">&lt;</span> List.length tail<span class="bp">✝</span>)
  {b : List.get (List.append tail<span class="bp">✝</span> [α]) i},
  dropBot (HList.set (extendBot a σ) i b) <span class="bp">=</span>
    HList.set σ { val := i.val, isLt := h }
      ((_ :
          List.get (tail<span class="bp">✝</span> <span class="bp">++</span> [α]) { val := i.val, isLt := (_ : i.val <span class="bp">&lt;</span> List.length (tail<span class="bp">✝</span> <span class="bp">++</span> [α])) } <span class="bp">=</span>
            List.get tail<span class="bp">✝</span> { val := i.val, isLt := h }) <span class="bp">▸</span>
        b)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>Fin (List.length (List.append (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) [α]))</span></span></span><br><span><var>fst✝</var><span class="hyp-type"><b>: </b><span>head<span class="bp">✝</span></span></span></span><br><span><var>snd✝</var><span class="hyp-type"><b>: </b><span>HList tail<span class="bp">✝</span></span></span></span><br><span><var>n✝</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>h'</var><span class="hyp-type"><b>: </b><span>Nat.succ n<span class="bp">✝</span> <span class="bp">&lt;</span> List.length (List.append (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) [α])</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>{ val := Nat.succ n<span class="bp">✝</span>, isLt := h&#39; }<span class="bp">.</span>val <span class="bp">&lt;</span> List.length (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>)</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>List.get (List.append (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) [α]) { val := Nat.succ n<span class="bp">✝</span>, isLt := h&#39; }</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">cons.mk.succ</span></span><div class="goal-conclusion">fst<span class="bp">✝</span> :: dropBot (HList.set (extendBot a snd<span class="bp">✝</span>) { val := n<span class="bp">✝</span>, isLt := (_ : Nat.succ n<span class="bp">✝</span> <span class="bp">≤</span> List.length (tail<span class="bp">✝</span> <span class="bp">++</span> [α])) } b) <span class="bp">=</span>
  fst<span class="bp">✝</span> ::
    HList.set snd<span class="bp">✝</span> { val := n<span class="bp">✝</span>, isLt := (_ : Nat.succ n<span class="bp">✝</span> <span class="bp">≤</span> List.length tail<span class="bp">✝</span>) }
      ((_ :
          List.get (head<span class="bp">✝</span> :: tail<span class="bp">✝</span> <span class="bp">++</span> [α])
              { val := { val := Nat.succ n<span class="bp">✝</span>, isLt := h&#39; }<span class="bp">.</span>val,
                isLt := (_ : { val := Nat.succ n<span class="bp">✝</span>, isLt := h&#39; }<span class="bp">.</span>val <span class="bp">&lt;</span> List.length (head<span class="bp">✝</span> :: tail<span class="bp">✝</span> <span class="bp">++</span> [α])) } <span class="bp">=</span>
            List.get (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) { val := { val := Nat.succ n<span class="bp">✝</span>, isLt := h&#39; }<span class="bp">.</span>val, isLt := h }) <span class="bp">▸</span>
        b)</div></blockquote></div></div></small></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk8e" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk8e"><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ih</var><b>: </b><span>∀ {i : Fin (List.length (List.append tail✝ [α]))} (σ : Assg tail✝) (h : i.val &lt; List.length tail✝)
  {b : List.get (List.append tail✝ [α]) i},
  dropBot (HList.set (extendBot a σ) i b) =
    HList.set σ { val := i.val, isLt := h }
      ((_ :
          List.get (tail✝ ++ [α]) { val := i.val, isLt := (_ : i.val &lt; List.length (tail✝ ++ [α])) } =
            List.get tail✝ { val := i.val, isLt := h }) ▸
        b)</span></span></div></blockquote></div></small></div><span class="nv">ih</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br><span><var>head✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>tail✝</var><span class="hyp-type"><b>: </b><span>List (<span class="kt">Type</span> u_1)</span></span></span><br><span><var>ih</var><span class="hyp-type"><b>: </b><span><span class="bp">∀</span> {i : Fin (List.length (List.append tail<span class="bp">✝</span> [α]))} (σ : Assg tail<span class="bp">✝</span>) (h : i.val <span class="bp">&lt;</span> List.length tail<span class="bp">✝</span>)
  {b : List.get (List.append tail<span class="bp">✝</span> [α]) i},
  dropBot (HList.set (extendBot a σ) i b) <span class="bp">=</span>
    HList.set σ { val := i.val, isLt := h }
      ((_ :
          List.get (tail<span class="bp">✝</span> <span class="bp">++</span> [α]) { val := i.val, isLt := (_ : i.val <span class="bp">&lt;</span> List.length (tail<span class="bp">✝</span> <span class="bp">++</span> [α])) } <span class="bp">=</span>
            List.get tail<span class="bp">✝</span> { val := i.val, isLt := h }) <span class="bp">▸</span>
        b)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>Fin (List.length (List.append (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) [α]))</span></span></span><br><span><var>fst✝</var><span class="hyp-type"><b>: </b><span>head<span class="bp">✝</span></span></span></span><br><span><var>snd✝</var><span class="hyp-type"><b>: </b><span>HList tail<span class="bp">✝</span></span></span></span><br><span><var>n✝</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>h'</var><span class="hyp-type"><b>: </b><span>Nat.succ n<span class="bp">✝</span> <span class="bp">&lt;</span> List.length (List.append (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) [α])</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>{ val := Nat.succ n<span class="bp">✝</span>, isLt := h&#39; }<span class="bp">.</span>val <span class="bp">&lt;</span> List.length (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>)</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>List.get (List.append (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) [α]) { val := Nat.succ n<span class="bp">✝</span>, isLt := h&#39; }</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">cons.mk.succ</span></span><div class="goal-conclusion">fst<span class="bp">✝</span> ::
    HList.set snd<span class="bp">✝</span>
      { val := { val := n<span class="bp">✝</span>, isLt := (_ : Nat.succ n<span class="bp">✝</span> <span class="bp">≤</span> List.length (tail<span class="bp">✝</span> <span class="bp">++</span> [α])) }<span class="bp">.</span>val, isLt := <span class="bp">?</span>cons.mk.succ.h }
      ((_ :
          List.get (tail<span class="bp">✝</span> <span class="bp">++</span> [α])
              { val := { val := n<span class="bp">✝</span>, isLt := (_ : Nat.succ n<span class="bp">✝</span> <span class="bp">≤</span> List.length (tail<span class="bp">✝</span> <span class="bp">++</span> [α])) }<span class="bp">.</span>val,
                isLt :=
                  (_ :
                    { val := n<span class="bp">✝</span>, isLt := (_ : Nat.succ n<span class="bp">✝</span> <span class="bp">≤</span> List.length (tail<span class="bp">✝</span> <span class="bp">++</span> [α])) }<span class="bp">.</span>val <span class="bp">&lt;</span>
                      List.length (tail<span class="bp">✝</span> <span class="bp">++</span> [α])) } <span class="bp">=</span>
            List.get tail<span class="bp">✝</span>
              { val := { val := n<span class="bp">✝</span>, isLt := (_ : Nat.succ n<span class="bp">✝</span> <span class="bp">≤</span> List.length (tail<span class="bp">✝</span> <span class="bp">++</span> [α])) }<span class="bp">.</span>val,
                isLt := <span class="bp">?</span>cons.mk.succ.h }) <span class="bp">▸</span>
        b) <span class="bp">=</span>
  fst<span class="bp">✝</span> ::
    HList.set snd<span class="bp">✝</span> { val := n<span class="bp">✝</span>, isLt := (_ : Nat.succ n<span class="bp">✝</span> <span class="bp">≤</span> List.length tail<span class="bp">✝</span>) }
      ((_ :
          List.get (head<span class="bp">✝</span> :: tail<span class="bp">✝</span> <span class="bp">++</span> [α])
              { val := { val := Nat.succ n<span class="bp">✝</span>, isLt := h&#39; }<span class="bp">.</span>val,
                isLt := (_ : { val := Nat.succ n<span class="bp">✝</span>, isLt := h&#39; }<span class="bp">.</span>val <span class="bp">&lt;</span> List.length (head<span class="bp">✝</span> :: tail<span class="bp">✝</span> <span class="bp">++</span> [α])) } <span class="bp">=</span>
            List.get (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) { val := { val := Nat.succ n<span class="bp">✝</span>, isLt := h&#39; }<span class="bp">.</span>val, isLt := h }) <span class="bp">▸</span>
        b)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Formal-lean-chk8f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br><span><var>head✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>tail✝</var><span class="hyp-type"><b>: </b><span>List (<span class="kt">Type</span> u_1)</span></span></span><br><span><var>ih</var><span class="hyp-type"><b>: </b><span><span class="bp">∀</span> {i : Fin (List.length (List.append tail<span class="bp">✝</span> [α]))} (σ : Assg tail<span class="bp">✝</span>) (h : i.val <span class="bp">&lt;</span> List.length tail<span class="bp">✝</span>)
  {b : List.get (List.append tail<span class="bp">✝</span> [α]) i},
  dropBot (HList.set (extendBot a σ) i b) <span class="bp">=</span>
    HList.set σ { val := i.val, isLt := h }
      ((_ :
          List.get (tail<span class="bp">✝</span> <span class="bp">++</span> [α]) { val := i.val, isLt := (_ : i.val <span class="bp">&lt;</span> List.length (tail<span class="bp">✝</span> <span class="bp">++</span> [α])) } <span class="bp">=</span>
            List.get tail<span class="bp">✝</span> { val := i.val, isLt := h }) <span class="bp">▸</span>
        b)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>Fin (List.length (List.append (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) [α]))</span></span></span><br><span><var>fst✝</var><span class="hyp-type"><b>: </b><span>head<span class="bp">✝</span></span></span></span><br><span><var>snd✝</var><span class="hyp-type"><b>: </b><span>HList tail<span class="bp">✝</span></span></span></span><br><span><var>n✝</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>h'</var><span class="hyp-type"><b>: </b><span>Nat.succ n<span class="bp">✝</span> <span class="bp">&lt;</span> List.length (List.append (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) [α])</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>{ val := Nat.succ n<span class="bp">✝</span>, isLt := h&#39; }<span class="bp">.</span>val <span class="bp">&lt;</span> List.length (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>)</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>List.get (List.append (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) [α]) { val := Nat.succ n<span class="bp">✝</span>, isLt := h&#39; }</span></span></span><br></div><label class="goal-separator" for="Formal-lean-chk8f"><hr><span class="goal-name">cons.mk.succ.h</span></label><div class="goal-conclusion">{ val := n<span class="bp">✝</span>, isLt := (_ : Nat.succ n<span class="bp">✝</span> <span class="bp">≤</span> List.length (tail<span class="bp">✝</span> <span class="bp">++</span> [α])) }<span class="bp">.</span>val <span class="bp">&lt;</span> List.length tail<span class="bp">✝</span></div></blockquote></div></div></div></small></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk90" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk90"><span class="alectryon-token">]</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">

<span class="bp">@</span>[</span><span class="alectryon-token"><span class="k">simp</span></span><span class="alectryon-token">] </span><span class="alectryon-token"><span class="kd">theorem</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Assg.bot_set_extendBot_init</var><b>: </b><span>∀ {α : Type u_1} {Γ : List (Type u_1)} {i : Fin (List.length (List.append Γ [α]))} (a : α) (σ : Assg Γ),
  i.val &lt; List.length Γ → ∀ {b : List.get (List.append Γ [α]) i}, bot (HList.set (extendBot a σ) i b) = a</span></span></div></blockquote></div></small></div><span class="nv">Assg.bot_set_extendBot_init</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type u_1</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token">) (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>σ</var><b>: </b><span>Assg Γ</span></span></div></blockquote></div></small></div><span class="nv">σ</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Assg</var><b>: </b><span>List (Type u_1) → Type u_1</span></span></div></blockquote></div></small></div>Assg</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Γ</var><b>: </b><span>List (Type u_1)</span></span></div></blockquote></div></small></div><span class="nv">Γ</span></span><span class="alectryon-token">) (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>h</var><b>: </b><span>i.val &lt; List.length Γ</span></span></div></blockquote></div></small></div><span class="nv">h</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>i</var><b>: </b><span>Fin (List.length (List.append Γ [α]))</span></span></div></blockquote></div></small></div><span class="nv">i</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>1</var><b>: </b><span>{n : Nat} → Fin n → Nat</span></span></div></blockquote></div></small></div><span class="mi">1</span></span><span class="alectryon-token"> <span class="bp">&lt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Γ</var><b>: </b><span>List (Type u_1)</span></span></div></blockquote></div></small></div><span class="nv">Γ</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>length</var><b>: </b><span>{α : Type (u_1 + 1)} → List α → Nat</span></span></div></blockquote></div></small></div>length</span><span class="alectryon-token">) {</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>List.get (List.append Γ [α]) i</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token">} : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Assg.bot</var><b>: </b><span>{α : Type u_1} → {Γ : List (Type u_1)} → Assg (List.append Γ [α]) → α</span></span></div></blockquote></div></small></div>Assg.bot</span><span class="alectryon-token"> ((</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Assg.extendBot</var><b>: </b><span>{α : Type u_1} → α → {Γ : List (Type u_1)} → Assg Γ → Assg (List.append Γ [α])</span></span></div></blockquote></div></small></div>Assg.extendBot</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>σ</var><b>: </b><span>Assg Γ</span></span></div></blockquote></div></small></div><span class="nv">σ</span></span><span class="alectryon-token">)<span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>set</var><b>: </b><span>{αs : List (Type u_1)} → HList αs → (i : Fin (List.length αs)) → List.get αs i → HList αs</span></span></div></blockquote></div></small></div><span class="na">set</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>i</var><b>: </b><span>Fin (List.length (List.append Γ [α]))</span></span></div></blockquote></div></small></div><span class="nv">i</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>List.get (List.append Γ [α]) i</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token">) <span class="bp">=</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"> := </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk91" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk91"><span class="alectryon-token"><span class="kd">by</span></span><span class="alectryon-token"></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>List (<span class="kt">Type</span> u_1)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>Fin (List.length (List.append <span class="bp">Γ</span> [α]))</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br><span><var>σ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ</span></span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>i.val <span class="bp">&lt;</span> List.length <span class="bp">Γ</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>List.get (List.append <span class="bp">Γ</span> [α]) i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bot (HList.set (extendBot a σ) i b) <span class="bp">=</span> a</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk92" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk92"><span class="alectryon-token"><span class="k">induction</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Γ</var><b>: </b><span>List (Type u_1)</span></span></div></blockquote></div></small></div><span class="nv">Γ</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">with</span></span><span class="alectryon-token"></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>List (<span class="kt">Type</span> u_1)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>Fin (List.length (List.append <span class="bp">Γ</span> [α]))</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br><span><var>σ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ</span></span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>i.val <span class="bp">&lt;</span> List.length <span class="bp">Γ</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>List.get (List.append <span class="bp">Γ</span> [α]) i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bot (HList.set (extendBot a σ) i b) <span class="bp">=</span> a</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk93" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk93"><span class="alectryon-token"><span class="bp">|</span> nil <span class="bp">=&gt;</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>Fin (List.length (List.append [] [α]))</span></span></span><br><span><var>σ</var><span class="hyp-type"><b>: </b><span>Assg []</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>i.val <span class="bp">&lt;</span> List.length []</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>List.get (List.append [] [α]) i</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">nil</span></span><div class="goal-conclusion">bot (HList.set (extendBot a σ) i b) <span class="bp">=</span> a</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk94" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk94"><span class="alectryon-token"><span class="k">contradiction</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk95" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk95"><span class="alectryon-token"><span class="bp">|</span> cons  </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>_</var><b>: </b><span>Type u_1</span></span></div></blockquote></div></small></div>_</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>_</var><b>: </b><span>List (Type u_1)</span></span></div></blockquote></div></small></div>_</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ih</var><b>: </b><span>∀ {i : Fin (List.length (List.append tail✝ [α]))} (σ : Assg tail✝),
  i.val &lt; List.length tail✝ → ∀ {b : List.get (List.append tail✝ [α]) i}, bot (HList.set (extendBot a σ) i b) = a</span></span></div></blockquote></div></small></div><span class="nv">ih</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br><span><var>head✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>tail✝</var><span class="hyp-type"><b>: </b><span>List (<span class="kt">Type</span> u_1)</span></span></span><br><span><var>ih</var><span class="hyp-type"><b>: </b><span><span class="bp">∀</span> {i : Fin (List.length (List.append tail<span class="bp">✝</span> [α]))} (σ : Assg tail<span class="bp">✝</span>),
  i.val <span class="bp">&lt;</span> List.length tail<span class="bp">✝</span> <span class="bp">→</span> <span class="bp">∀</span> {b : List.get (List.append tail<span class="bp">✝</span> [α]) i}, bot (HList.set (extendBot a σ) i b) <span class="bp">=</span> a</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>Fin (List.length (List.append (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) [α]))</span></span></span><br><span><var>σ</var><span class="hyp-type"><b>: </b><span>Assg (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>)</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>i.val <span class="bp">&lt;</span> List.length (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>)</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>List.get (List.append (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) [α]) i</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">cons</span></span><div class="goal-conclusion">bot (HList.set (extendBot a σ) i b) <span class="bp">=</span> a</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
    </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk96" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk96"><span class="alectryon-token"><span class="k">cases</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>σ</var><b>: </b><span>Assg (head✝ :: tail✝)</span></span></div></blockquote></div></small></div><span class="nv">σ</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br><span><var>head✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>tail✝</var><span class="hyp-type"><b>: </b><span>List (<span class="kt">Type</span> u_1)</span></span></span><br><span><var>ih</var><span class="hyp-type"><b>: </b><span><span class="bp">∀</span> {i : Fin (List.length (List.append tail<span class="bp">✝</span> [α]))} (σ : Assg tail<span class="bp">✝</span>),
  i.val <span class="bp">&lt;</span> List.length tail<span class="bp">✝</span> <span class="bp">→</span> <span class="bp">∀</span> {b : List.get (List.append tail<span class="bp">✝</span> [α]) i}, bot (HList.set (extendBot a σ) i b) <span class="bp">=</span> a</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>Fin (List.length (List.append (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) [α]))</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>i.val <span class="bp">&lt;</span> List.length (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>)</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>List.get (List.append (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) [α]) i</span></span></span><br><span><var>fst✝</var><span class="hyp-type"><b>: </b><span>head<span class="bp">✝</span></span></span></span><br><span><var>snd✝</var><span class="hyp-type"><b>: </b><span>HList tail<span class="bp">✝</span></span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">cons.mk</span></span><div class="goal-conclusion">bot (HList.set (extendBot a (fst<span class="bp">✝</span>, snd<span class="bp">✝</span>)) i b) <span class="bp">=</span> a</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
    </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk97" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk97"><span class="alectryon-token"><span class="k">have</span></span><span class="alectryon-token"> ⟨</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>i</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">i</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>h'</var><b>: </b><span>i &lt; List.length (List.append (head✝ :: tail✝) [α])</span></span></div></blockquote></div></small></div><span class="nv">h&#39;</span></span><span class="alectryon-token">⟩ := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>i</var><b>: </b><span>Fin (List.length (List.append (head✝ :: tail✝) [α]))</span></span></div></blockquote></div></small></div><span class="nv">i</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br><span><var>head✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>tail✝</var><span class="hyp-type"><b>: </b><span>List (<span class="kt">Type</span> u_1)</span></span></span><br><span><var>ih</var><span class="hyp-type"><b>: </b><span><span class="bp">∀</span> {i : Fin (List.length (List.append tail<span class="bp">✝</span> [α]))} (σ : Assg tail<span class="bp">✝</span>),
  i.val <span class="bp">&lt;</span> List.length tail<span class="bp">✝</span> <span class="bp">→</span> <span class="bp">∀</span> {b : List.get (List.append tail<span class="bp">✝</span> [α]) i}, bot (HList.set (extendBot a σ) i b) <span class="bp">=</span> a</span></span></span><br><span><var>i✝</var><span class="hyp-type"><b>: </b><span>Fin (List.length (List.append (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) [α]))</span></span></span><br><span><var>fst✝</var><span class="hyp-type"><b>: </b><span>head<span class="bp">✝</span></span></span></span><br><span><var>snd✝</var><span class="hyp-type"><b>: </b><span>HList tail<span class="bp">✝</span></span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>h'</var><span class="hyp-type"><b>: </b><span>i <span class="bp">&lt;</span> List.length (List.append (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) [α])</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>{ val := i, isLt := h&#39; }<span class="bp">.</span>val <span class="bp">&lt;</span> List.length (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>)</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>List.get (List.append (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) [α]) { val := i, isLt := h&#39; }</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">cons.mk</span></span><div class="goal-conclusion">bot (HList.set (extendBot a (fst<span class="bp">✝</span>, snd<span class="bp">✝</span>)) { val := i, isLt := h&#39; } b) <span class="bp">=</span> a</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
    </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk98" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk98"><span class="alectryon-token"><span class="k">cases</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>i</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">i</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br><span><var>head✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>tail✝</var><span class="hyp-type"><b>: </b><span>List (<span class="kt">Type</span> u_1)</span></span></span><br><span><var>ih</var><span class="hyp-type"><b>: </b><span><span class="bp">∀</span> {i : Fin (List.length (List.append tail<span class="bp">✝</span> [α]))} (σ : Assg tail<span class="bp">✝</span>),
  i.val <span class="bp">&lt;</span> List.length tail<span class="bp">✝</span> <span class="bp">→</span> <span class="bp">∀</span> {b : List.get (List.append tail<span class="bp">✝</span> [α]) i}, bot (HList.set (extendBot a σ) i b) <span class="bp">=</span> a</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>Fin (List.length (List.append (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) [α]))</span></span></span><br><span><var>fst✝</var><span class="hyp-type"><b>: </b><span>head<span class="bp">✝</span></span></span></span><br><span><var>snd✝</var><span class="hyp-type"><b>: </b><span>HList tail<span class="bp">✝</span></span></span></span><br><span><var>h'</var><span class="hyp-type"><b>: </b><span>Nat.zero <span class="bp">&lt;</span> List.length (List.append (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) [α])</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>{ val := Nat.zero, isLt := h&#39; }<span class="bp">.</span>val <span class="bp">&lt;</span> List.length (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>)</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>List.get (List.append (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) [α]) { val := Nat.zero, isLt := h&#39; }</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">cons.mk.zero</span></span><div class="goal-conclusion">bot (HList.set (extendBot a (fst<span class="bp">✝</span>, snd<span class="bp">✝</span>)) { val := Nat.zero, isLt := h&#39; } b) <span class="bp">=</span> a</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Formal-lean-chk99" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br><span><var>head✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>tail✝</var><span class="hyp-type"><b>: </b><span>List (<span class="kt">Type</span> u_1)</span></span></span><br><span><var>ih</var><span class="hyp-type"><b>: </b><span><span class="bp">∀</span> {i : Fin (List.length (List.append tail<span class="bp">✝</span> [α]))} (σ : Assg tail<span class="bp">✝</span>),
  i.val <span class="bp">&lt;</span> List.length tail<span class="bp">✝</span> <span class="bp">→</span> <span class="bp">∀</span> {b : List.get (List.append tail<span class="bp">✝</span> [α]) i}, bot (HList.set (extendBot a σ) i b) <span class="bp">=</span> a</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>Fin (List.length (List.append (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) [α]))</span></span></span><br><span><var>fst✝</var><span class="hyp-type"><b>: </b><span>head<span class="bp">✝</span></span></span></span><br><span><var>snd✝</var><span class="hyp-type"><b>: </b><span>HList tail<span class="bp">✝</span></span></span></span><br><span><var>n✝</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>h'</var><span class="hyp-type"><b>: </b><span>Nat.succ n<span class="bp">✝</span> <span class="bp">&lt;</span> List.length (List.append (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) [α])</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>{ val := Nat.succ n<span class="bp">✝</span>, isLt := h&#39; }<span class="bp">.</span>val <span class="bp">&lt;</span> List.length (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>)</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>List.get (List.append (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) [α]) { val := Nat.succ n<span class="bp">✝</span>, isLt := h&#39; }</span></span></span><br></div><label class="goal-separator" for="Formal-lean-chk99"><hr><span class="goal-name">cons.mk.succ</span></label><div class="goal-conclusion">bot (HList.set (extendBot a (fst<span class="bp">✝</span>, snd<span class="bp">✝</span>)) { val := Nat.succ n<span class="bp">✝</span>, isLt := h&#39; } b) <span class="bp">=</span> a</div></blockquote></div></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk9a" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk9a"><span class="alectryon-token"><span class="k">&lt;;&gt;</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br><span><var>head✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>tail✝</var><span class="hyp-type"><b>: </b><span>List (<span class="kt">Type</span> u_1)</span></span></span><br><span><var>ih</var><span class="hyp-type"><b>: </b><span><span class="bp">∀</span> {i : Fin (List.length (List.append tail<span class="bp">✝</span> [α]))} (σ : Assg tail<span class="bp">✝</span>),
  i.val <span class="bp">&lt;</span> List.length tail<span class="bp">✝</span> <span class="bp">→</span> <span class="bp">∀</span> {b : List.get (List.append tail<span class="bp">✝</span> [α]) i}, bot (HList.set (extendBot a σ) i b) <span class="bp">=</span> a</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>Fin (List.length (List.append (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) [α]))</span></span></span><br><span><var>fst✝</var><span class="hyp-type"><b>: </b><span>head<span class="bp">✝</span></span></span></span><br><span><var>snd✝</var><span class="hyp-type"><b>: </b><span>HList tail<span class="bp">✝</span></span></span></span><br><span><var>h'</var><span class="hyp-type"><b>: </b><span>Nat.zero <span class="bp">&lt;</span> List.length (List.append (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) [α])</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>{ val := Nat.zero, isLt := h&#39; }<span class="bp">.</span>val <span class="bp">&lt;</span> List.length (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>)</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>List.get (List.append (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) [α]) { val := Nat.zero, isLt := h&#39; }</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">cons.mk.zero</span></span><div class="goal-conclusion">bot (HList.set (extendBot a (fst<span class="bp">✝</span>, snd<span class="bp">✝</span>)) { val := Nat.zero, isLt := h&#39; } b) <span class="bp">=</span> a</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Formal-lean-chk9b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br><span><var>head✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>tail✝</var><span class="hyp-type"><b>: </b><span>List (<span class="kt">Type</span> u_1)</span></span></span><br><span><var>ih</var><span class="hyp-type"><b>: </b><span><span class="bp">∀</span> {i : Fin (List.length (List.append tail<span class="bp">✝</span> [α]))} (σ : Assg tail<span class="bp">✝</span>),
  i.val <span class="bp">&lt;</span> List.length tail<span class="bp">✝</span> <span class="bp">→</span> <span class="bp">∀</span> {b : List.get (List.append tail<span class="bp">✝</span> [α]) i}, bot (HList.set (extendBot a σ) i b) <span class="bp">=</span> a</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>Fin (List.length (List.append (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) [α]))</span></span></span><br><span><var>fst✝</var><span class="hyp-type"><b>: </b><span>head<span class="bp">✝</span></span></span></span><br><span><var>snd✝</var><span class="hyp-type"><b>: </b><span>HList tail<span class="bp">✝</span></span></span></span><br><span><var>n✝</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>h'</var><span class="hyp-type"><b>: </b><span>Nat.succ n<span class="bp">✝</span> <span class="bp">&lt;</span> List.length (List.append (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) [α])</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>{ val := Nat.succ n<span class="bp">✝</span>, isLt := h&#39; }<span class="bp">.</span>val <span class="bp">&lt;</span> List.length (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>)</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>List.get (List.append (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) [α]) { val := Nat.succ n<span class="bp">✝</span>, isLt := h&#39; }</span></span></span><br></div><label class="goal-separator" for="Formal-lean-chk9b"><hr><span class="goal-name">cons.mk.succ</span></label><div class="goal-conclusion">bot (HList.set (extendBot a (fst<span class="bp">✝</span>, snd<span class="bp">✝</span>)) { val := Nat.succ n<span class="bp">✝</span>, isLt := h&#39; } b) <span class="bp">=</span> a</div></blockquote></div></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk9c" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk9c"><span class="alectryon-token"><span class="k">simp</span></span><span class="alectryon-token"> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>HList.set</var><b>: </b><span>{αs : List (Type ?u.547313)} → HList αs → (i : Fin (List.length αs)) → List.get αs i → HList αs</span></span></div></blockquote></div></small></div><span class="k">HList.set</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>dropBot</var><b>: </b><span>{α : Type ?u.547612} → {Γ : List (Type ?u.547612)} → Assg (List.append Γ [α]) → Assg Γ</span></span></div></blockquote></div></small></div><span class="k">dropBot</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>bot</var><b>: </b><span>{α : Type ?u.547627} → {Γ : List (Type ?u.547627)} → Assg (List.append Γ [α]) → α</span></span></div></blockquote></div></small></div><span class="k">bot</span></span><span class="alectryon-token">]</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br><span><var>head✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>tail✝</var><span class="hyp-type"><b>: </b><span>List (<span class="kt">Type</span> u_1)</span></span></span><br><span><var>ih</var><span class="hyp-type"><b>: </b><span><span class="bp">∀</span> {i : Fin (List.length (List.append tail<span class="bp">✝</span> [α]))} (σ : Assg tail<span class="bp">✝</span>),
  i.val <span class="bp">&lt;</span> List.length tail<span class="bp">✝</span> <span class="bp">→</span> <span class="bp">∀</span> {b : List.get (List.append tail<span class="bp">✝</span> [α]) i}, bot (HList.set (extendBot a σ) i b) <span class="bp">=</span> a</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>Fin (List.length (List.append (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) [α]))</span></span></span><br><span><var>fst✝</var><span class="hyp-type"><b>: </b><span>head<span class="bp">✝</span></span></span></span><br><span><var>snd✝</var><span class="hyp-type"><b>: </b><span>HList tail<span class="bp">✝</span></span></span></span><br><span><var>n✝</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>h'</var><span class="hyp-type"><b>: </b><span>Nat.succ n<span class="bp">✝</span> <span class="bp">&lt;</span> List.length (List.append (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) [α])</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>{ val := Nat.succ n<span class="bp">✝</span>, isLt := h&#39; }<span class="bp">.</span>val <span class="bp">&lt;</span> List.length (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>)</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>List.get (List.append (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) [α]) { val := Nat.succ n<span class="bp">✝</span>, isLt := h&#39; }</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">cons.mk.succ</span></span><div class="goal-conclusion">bot (HList.set (extendBot a snd<span class="bp">✝</span>) { val := n<span class="bp">✝</span>, isLt := (_ : Nat.succ n<span class="bp">✝</span> <span class="bp">≤</span> List.length (tail<span class="bp">✝</span> <span class="bp">++</span> [α])) } b) <span class="bp">=</span> a</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
    </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk9d" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk9d"><span class="alectryon-token"><span class="k">rw</span></span><span class="alectryon-token"> [</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br><span><var>head✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>tail✝</var><span class="hyp-type"><b>: </b><span>List (<span class="kt">Type</span> u_1)</span></span></span><br><span><var>ih</var><span class="hyp-type"><b>: </b><span><span class="bp">∀</span> {i : Fin (List.length (List.append tail<span class="bp">✝</span> [α]))} (σ : Assg tail<span class="bp">✝</span>),
  i.val <span class="bp">&lt;</span> List.length tail<span class="bp">✝</span> <span class="bp">→</span> <span class="bp">∀</span> {b : List.get (List.append tail<span class="bp">✝</span> [α]) i}, bot (HList.set (extendBot a σ) i b) <span class="bp">=</span> a</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>Fin (List.length (List.append (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) [α]))</span></span></span><br><span><var>fst✝</var><span class="hyp-type"><b>: </b><span>head<span class="bp">✝</span></span></span></span><br><span><var>snd✝</var><span class="hyp-type"><b>: </b><span>HList tail<span class="bp">✝</span></span></span></span><br><span><var>n✝</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>h'</var><span class="hyp-type"><b>: </b><span>Nat.succ n<span class="bp">✝</span> <span class="bp">&lt;</span> List.length (List.append (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) [α])</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>{ val := Nat.succ n<span class="bp">✝</span>, isLt := h&#39; }<span class="bp">.</span>val <span class="bp">&lt;</span> List.length (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>)</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>List.get (List.append (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) [α]) { val := Nat.succ n<span class="bp">✝</span>, isLt := h&#39; }</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">cons.mk.succ</span></span><div class="goal-conclusion">bot (HList.set (extendBot a snd<span class="bp">✝</span>) { val := n<span class="bp">✝</span>, isLt := (_ : Nat.succ n<span class="bp">✝</span> <span class="bp">≤</span> List.length (tail<span class="bp">✝</span> <span class="bp">++</span> [α])) } b) <span class="bp">=</span> a</div></blockquote></div></div></small></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk9e" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk9e"><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ih</var><b>: </b><span>∀ {i : Fin (List.length (List.append tail✝ [α]))} (σ : Assg tail✝),
  i.val &lt; List.length tail✝ → ∀ {b : List.get (List.append tail✝ [α]) i}, bot (HList.set (extendBot a σ) i b) = a</span></span></div></blockquote></div></small></div><span class="nv">ih</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br><span><var>head✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>tail✝</var><span class="hyp-type"><b>: </b><span>List (<span class="kt">Type</span> u_1)</span></span></span><br><span><var>ih</var><span class="hyp-type"><b>: </b><span><span class="bp">∀</span> {i : Fin (List.length (List.append tail<span class="bp">✝</span> [α]))} (σ : Assg tail<span class="bp">✝</span>),
  i.val <span class="bp">&lt;</span> List.length tail<span class="bp">✝</span> <span class="bp">→</span> <span class="bp">∀</span> {b : List.get (List.append tail<span class="bp">✝</span> [α]) i}, bot (HList.set (extendBot a σ) i b) <span class="bp">=</span> a</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>Fin (List.length (List.append (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) [α]))</span></span></span><br><span><var>fst✝</var><span class="hyp-type"><b>: </b><span>head<span class="bp">✝</span></span></span></span><br><span><var>snd✝</var><span class="hyp-type"><b>: </b><span>HList tail<span class="bp">✝</span></span></span></span><br><span><var>n✝</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>h'</var><span class="hyp-type"><b>: </b><span>Nat.succ n<span class="bp">✝</span> <span class="bp">&lt;</span> List.length (List.append (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) [α])</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>{ val := Nat.succ n<span class="bp">✝</span>, isLt := h&#39; }<span class="bp">.</span>val <span class="bp">&lt;</span> List.length (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>)</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>List.get (List.append (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) [α]) { val := Nat.succ n<span class="bp">✝</span>, isLt := h&#39; }</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">cons.mk.succ</span></span><div class="goal-conclusion">a <span class="bp">=</span> a</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Formal-lean-chk9f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br><span><var>head✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>tail✝</var><span class="hyp-type"><b>: </b><span>List (<span class="kt">Type</span> u_1)</span></span></span><br><span><var>ih</var><span class="hyp-type"><b>: </b><span><span class="bp">∀</span> {i : Fin (List.length (List.append tail<span class="bp">✝</span> [α]))} (σ : Assg tail<span class="bp">✝</span>),
  i.val <span class="bp">&lt;</span> List.length tail<span class="bp">✝</span> <span class="bp">→</span> <span class="bp">∀</span> {b : List.get (List.append tail<span class="bp">✝</span> [α]) i}, bot (HList.set (extendBot a σ) i b) <span class="bp">=</span> a</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>Fin (List.length (List.append (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) [α]))</span></span></span><br><span><var>fst✝</var><span class="hyp-type"><b>: </b><span>head<span class="bp">✝</span></span></span></span><br><span><var>snd✝</var><span class="hyp-type"><b>: </b><span>HList tail<span class="bp">✝</span></span></span></span><br><span><var>n✝</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>h'</var><span class="hyp-type"><b>: </b><span>Nat.succ n<span class="bp">✝</span> <span class="bp">&lt;</span> List.length (List.append (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) [α])</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>{ val := Nat.succ n<span class="bp">✝</span>, isLt := h&#39; }<span class="bp">.</span>val <span class="bp">&lt;</span> List.length (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>)</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>List.get (List.append (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) [α]) { val := Nat.succ n<span class="bp">✝</span>, isLt := h&#39; }</span></span></span><br></div><label class="goal-separator" for="Formal-lean-chk9f"><hr><span class="goal-name">cons.mk.succ.h</span></label><div class="goal-conclusion">{ val := n<span class="bp">✝</span>, isLt := (_ : Nat.succ n<span class="bp">✝</span> <span class="bp">≤</span> List.length (tail<span class="bp">✝</span> <span class="bp">++</span> [α])) }<span class="bp">.</span>val <span class="bp">&lt;</span> List.length tail<span class="bp">✝</span></div></blockquote></div></div></div></small></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chka0" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chka0"><span class="alectryon-token">]</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br><span><var>head✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>tail✝</var><span class="hyp-type"><b>: </b><span>List (<span class="kt">Type</span> u_1)</span></span></span><br><span><var>ih</var><span class="hyp-type"><b>: </b><span><span class="bp">∀</span> {i : Fin (List.length (List.append tail<span class="bp">✝</span> [α]))} (σ : Assg tail<span class="bp">✝</span>),
  i.val <span class="bp">&lt;</span> List.length tail<span class="bp">✝</span> <span class="bp">→</span> <span class="bp">∀</span> {b : List.get (List.append tail<span class="bp">✝</span> [α]) i}, bot (HList.set (extendBot a σ) i b) <span class="bp">=</span> a</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>Fin (List.length (List.append (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) [α]))</span></span></span><br><span><var>fst✝</var><span class="hyp-type"><b>: </b><span>head<span class="bp">✝</span></span></span></span><br><span><var>snd✝</var><span class="hyp-type"><b>: </b><span>HList tail<span class="bp">✝</span></span></span></span><br><span><var>n✝</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>h'</var><span class="hyp-type"><b>: </b><span>Nat.succ n<span class="bp">✝</span> <span class="bp">&lt;</span> List.length (List.append (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) [α])</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>{ val := Nat.succ n<span class="bp">✝</span>, isLt := h&#39; }<span class="bp">.</span>val <span class="bp">&lt;</span> List.length (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>)</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>List.get (List.append (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) [α]) { val := Nat.succ n<span class="bp">✝</span>, isLt := h&#39; }</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">cons.mk.succ.h</span></span><div class="goal-conclusion">{ val := n<span class="bp">✝</span>, isLt := (_ : Nat.succ n<span class="bp">✝</span> <span class="bp">≤</span> List.length (tail<span class="bp">✝</span> <span class="bp">++</span> [α])) }<span class="bp">.</span>val <span class="bp">&lt;</span> List.length tail<span class="bp">✝</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"><span class="bp">;</span></span><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chka1" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chka1"><span class="alectryon-token"><span class="k">apply</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat.lt_of_succ_lt_succ</var><b>: </b><span>∀ {n m : Nat}, Nat.succ n &lt; Nat.succ m → n &lt; m</span></span></div></blockquote></div></small></div>Nat.lt_of_succ_lt_succ</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>h</var><b>: </b><span>{ val := Nat.succ n✝, isLt := h' }.val &lt; List.length (head✝ :: tail✝)</span></span></div></blockquote></div></small></div><span class="nv">h</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">

<span class="bp">@</span>[</span><span class="alectryon-token"><span class="k">simp</span></span><span class="alectryon-token">] </span><span class="alectryon-token"><span class="kd">theorem</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Assg.dropBot_set_extendBot_bottom</var><b>: </b><span>∀ {α : Type u_1} {Γ : List (Type u_1)} {i : Fin (List.length (List.append Γ [α]))} (a : α) (σ : Assg Γ),
  ¬i.val &lt; List.length Γ → ∀ {b : List.get (List.append Γ [α]) i}, dropBot (HList.set (extendBot a σ) i b) = σ</span></span></div></blockquote></div></small></div><span class="nv">Assg.dropBot_set_extendBot_bottom</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type u_1</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token">) (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>σ</var><b>: </b><span>Assg Γ</span></span></div></blockquote></div></small></div><span class="nv">σ</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Assg</var><b>: </b><span>List (Type ?u.548037) → Type ?u.548037</span></span></div></blockquote></div></small></div>Assg</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Γ</var><b>: </b><span>List (Type u_1)</span></span></div></blockquote></div></small></div><span class="nv">Γ</span></span><span class="alectryon-token">) (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>h</var><b>: </b><span>¬i.val &lt; List.length Γ</span></span></div></blockquote></div></small></div><span class="nv">h</span></span><span class="alectryon-token"> : <span class="bp">¬</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>i</var><b>: </b><span>Fin (List.length (List.append Γ [α]))</span></span></div></blockquote></div></small></div><span class="nv">i</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>1</var><b>: </b><span>{n : Nat} → Fin n → Nat</span></span></div></blockquote></div></small></div><span class="mi">1</span></span><span class="alectryon-token"> <span class="bp">&lt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Γ</var><b>: </b><span>List (Type u_1)</span></span></div></blockquote></div></small></div><span class="nv">Γ</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>length</var><b>: </b><span>{α : Type (u_1 + 1)} → List α → Nat</span></span></div></blockquote></div></small></div>length</span><span class="alectryon-token">) {</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>List.get (List.append Γ [α]) i</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token">} : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Assg.dropBot</var><b>: </b><span>{α : Type u_1} → {Γ : List (Type u_1)} → Assg (List.append Γ [α]) → Assg Γ</span></span></div></blockquote></div></small></div>Assg.dropBot</span><span class="alectryon-token"> ((</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Assg.extendBot</var><b>: </b><span>{α : Type u_1} → α → {Γ : List (Type u_1)} → Assg Γ → Assg (List.append Γ [α])</span></span></div></blockquote></div></small></div>Assg.extendBot</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>σ</var><b>: </b><span>Assg Γ</span></span></div></blockquote></div></small></div><span class="nv">σ</span></span><span class="alectryon-token">)<span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>set</var><b>: </b><span>{αs : List (Type u_1)} → HList αs → (i : Fin (List.length αs)) → List.get αs i → HList αs</span></span></div></blockquote></div></small></div><span class="na">set</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>i</var><b>: </b><span>Fin (List.length (List.append Γ [α]))</span></span></div></blockquote></div></small></div><span class="nv">i</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>List.get (List.append Γ [α]) i</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token">) <span class="bp">=</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>σ</var><b>: </b><span>Assg Γ</span></span></div></blockquote></div></small></div><span class="nv">σ</span></span><span class="alectryon-token"> := </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chka2" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chka2"><span class="alectryon-token"><span class="kd">by</span></span><span class="alectryon-token"></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>List (<span class="kt">Type</span> u_1)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>Fin (List.length (List.append <span class="bp">Γ</span> [α]))</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br><span><var>σ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ</span></span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span><span class="bp">¬</span>i.val <span class="bp">&lt;</span> List.length <span class="bp">Γ</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>List.get (List.append <span class="bp">Γ</span> [α]) i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dropBot (HList.set (extendBot a σ) i b) <span class="bp">=</span> σ</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chka3" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chka3"><span class="alectryon-token"><span class="k">induction</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Γ</var><b>: </b><span>List (Type u_1)</span></span></div></blockquote></div></small></div><span class="nv">Γ</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">with</span></span><span class="alectryon-token"></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>List (<span class="kt">Type</span> u_1)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>Fin (List.length (List.append <span class="bp">Γ</span> [α]))</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br><span><var>σ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ</span></span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span><span class="bp">¬</span>i.val <span class="bp">&lt;</span> List.length <span class="bp">Γ</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>List.get (List.append <span class="bp">Γ</span> [α]) i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dropBot (HList.set (extendBot a σ) i b) <span class="bp">=</span> σ</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chka4" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chka4"><span class="alectryon-token"><span class="bp">|</span> nil <span class="bp">=&gt;</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>Fin (List.length (List.append [] [α]))</span></span></span><br><span><var>σ</var><span class="hyp-type"><b>: </b><span>Assg []</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span><span class="bp">¬</span>i.val <span class="bp">&lt;</span> List.length []</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>List.get (List.append [] [α]) i</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">nil</span></span><div class="goal-conclusion">dropBot (HList.set (extendBot a σ) i b) <span class="bp">=</span> σ</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chka5" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chka5"><span class="alectryon-token"><span class="k">rfl</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chka6" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chka6"><span class="alectryon-token"><span class="bp">|</span> cons  </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>_</var><b>: </b><span>Type u_1</span></span></div></blockquote></div></small></div>_</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>_</var><b>: </b><span>List (Type u_1)</span></span></div></blockquote></div></small></div>_</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ih</var><b>: </b><span>∀ {i : Fin (List.length (List.append tail✝ [α]))} (σ : Assg tail✝),
  ¬i.val &lt; List.length tail✝ → ∀ {b : List.get (List.append tail✝ [α]) i}, dropBot (HList.set (extendBot a σ) i b) = σ</span></span></div></blockquote></div></small></div><span class="nv">ih</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br><span><var>head✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>tail✝</var><span class="hyp-type"><b>: </b><span>List (<span class="kt">Type</span> u_1)</span></span></span><br><span><var>ih</var><span class="hyp-type"><b>: </b><span><span class="bp">∀</span> {i : Fin (List.length (List.append tail<span class="bp">✝</span> [α]))} (σ : Assg tail<span class="bp">✝</span>),
  <span class="bp">¬</span>i.val <span class="bp">&lt;</span> List.length tail<span class="bp">✝</span> <span class="bp">→</span> <span class="bp">∀</span> {b : List.get (List.append tail<span class="bp">✝</span> [α]) i}, dropBot (HList.set (extendBot a σ) i b) <span class="bp">=</span> σ</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>Fin (List.length (List.append (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) [α]))</span></span></span><br><span><var>σ</var><span class="hyp-type"><b>: </b><span>Assg (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>)</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span><span class="bp">¬</span>i.val <span class="bp">&lt;</span> List.length (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>)</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>List.get (List.append (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) [α]) i</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">cons</span></span><div class="goal-conclusion">dropBot (HList.set (extendBot a σ) i b) <span class="bp">=</span> σ</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
    </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chka7" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chka7"><span class="alectryon-token"><span class="k">cases</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>σ</var><b>: </b><span>Assg (head✝ :: tail✝)</span></span></div></blockquote></div></small></div><span class="nv">σ</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br><span><var>head✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>tail✝</var><span class="hyp-type"><b>: </b><span>List (<span class="kt">Type</span> u_1)</span></span></span><br><span><var>ih</var><span class="hyp-type"><b>: </b><span><span class="bp">∀</span> {i : Fin (List.length (List.append tail<span class="bp">✝</span> [α]))} (σ : Assg tail<span class="bp">✝</span>),
  <span class="bp">¬</span>i.val <span class="bp">&lt;</span> List.length tail<span class="bp">✝</span> <span class="bp">→</span> <span class="bp">∀</span> {b : List.get (List.append tail<span class="bp">✝</span> [α]) i}, dropBot (HList.set (extendBot a σ) i b) <span class="bp">=</span> σ</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>Fin (List.length (List.append (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) [α]))</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span><span class="bp">¬</span>i.val <span class="bp">&lt;</span> List.length (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>)</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>List.get (List.append (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) [α]) i</span></span></span><br><span><var>fst✝</var><span class="hyp-type"><b>: </b><span>head<span class="bp">✝</span></span></span></span><br><span><var>snd✝</var><span class="hyp-type"><b>: </b><span>HList tail<span class="bp">✝</span></span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">cons.mk</span></span><div class="goal-conclusion">dropBot (HList.set (extendBot a (fst<span class="bp">✝</span>, snd<span class="bp">✝</span>)) i b) <span class="bp">=</span> (fst<span class="bp">✝</span>, snd<span class="bp">✝</span>)</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
    </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chka8" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chka8"><span class="alectryon-token"><span class="k">have</span></span><span class="alectryon-token"> ⟨</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>i</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">i</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>h'</var><b>: </b><span>i &lt; List.length (List.append (head✝ :: tail✝) [α])</span></span></div></blockquote></div></small></div><span class="nv">h&#39;</span></span><span class="alectryon-token">⟩ := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>i</var><b>: </b><span>Fin (List.length (List.append (head✝ :: tail✝) [α]))</span></span></div></blockquote></div></small></div><span class="nv">i</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br><span><var>head✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>tail✝</var><span class="hyp-type"><b>: </b><span>List (<span class="kt">Type</span> u_1)</span></span></span><br><span><var>ih</var><span class="hyp-type"><b>: </b><span><span class="bp">∀</span> {i : Fin (List.length (List.append tail<span class="bp">✝</span> [α]))} (σ : Assg tail<span class="bp">✝</span>),
  <span class="bp">¬</span>i.val <span class="bp">&lt;</span> List.length tail<span class="bp">✝</span> <span class="bp">→</span> <span class="bp">∀</span> {b : List.get (List.append tail<span class="bp">✝</span> [α]) i}, dropBot (HList.set (extendBot a σ) i b) <span class="bp">=</span> σ</span></span></span><br><span><var>i✝</var><span class="hyp-type"><b>: </b><span>Fin (List.length (List.append (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) [α]))</span></span></span><br><span><var>fst✝</var><span class="hyp-type"><b>: </b><span>head<span class="bp">✝</span></span></span></span><br><span><var>snd✝</var><span class="hyp-type"><b>: </b><span>HList tail<span class="bp">✝</span></span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>h'</var><span class="hyp-type"><b>: </b><span>i <span class="bp">&lt;</span> List.length (List.append (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) [α])</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span><span class="bp">¬</span>{ val := i, isLt := h&#39; }<span class="bp">.</span>val <span class="bp">&lt;</span> List.length (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>)</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>List.get (List.append (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) [α]) { val := i, isLt := h&#39; }</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">cons.mk</span></span><div class="goal-conclusion">dropBot (HList.set (extendBot a (fst<span class="bp">✝</span>, snd<span class="bp">✝</span>)) { val := i, isLt := h&#39; } b) <span class="bp">=</span> (fst<span class="bp">✝</span>, snd<span class="bp">✝</span>)</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
    </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chka9" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chka9"><span class="alectryon-token"><span class="k">cases</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>i</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">i</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br><span><var>head✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>tail✝</var><span class="hyp-type"><b>: </b><span>List (<span class="kt">Type</span> u_1)</span></span></span><br><span><var>ih</var><span class="hyp-type"><b>: </b><span><span class="bp">∀</span> {i : Fin (List.length (List.append tail<span class="bp">✝</span> [α]))} (σ : Assg tail<span class="bp">✝</span>),
  <span class="bp">¬</span>i.val <span class="bp">&lt;</span> List.length tail<span class="bp">✝</span> <span class="bp">→</span> <span class="bp">∀</span> {b : List.get (List.append tail<span class="bp">✝</span> [α]) i}, dropBot (HList.set (extendBot a σ) i b) <span class="bp">=</span> σ</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>Fin (List.length (List.append (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) [α]))</span></span></span><br><span><var>fst✝</var><span class="hyp-type"><b>: </b><span>head<span class="bp">✝</span></span></span></span><br><span><var>snd✝</var><span class="hyp-type"><b>: </b><span>HList tail<span class="bp">✝</span></span></span></span><br><span><var>h'</var><span class="hyp-type"><b>: </b><span>Nat.zero <span class="bp">&lt;</span> List.length (List.append (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) [α])</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span><span class="bp">¬</span>{ val := Nat.zero, isLt := h&#39; }<span class="bp">.</span>val <span class="bp">&lt;</span> List.length (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>)</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>List.get (List.append (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) [α]) { val := Nat.zero, isLt := h&#39; }</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">cons.mk.zero</span></span><div class="goal-conclusion">dropBot (HList.set (extendBot a (fst<span class="bp">✝</span>, snd<span class="bp">✝</span>)) { val := Nat.zero, isLt := h&#39; } b) <span class="bp">=</span> (fst<span class="bp">✝</span>, snd<span class="bp">✝</span>)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Formal-lean-chkaa" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br><span><var>head✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>tail✝</var><span class="hyp-type"><b>: </b><span>List (<span class="kt">Type</span> u_1)</span></span></span><br><span><var>ih</var><span class="hyp-type"><b>: </b><span><span class="bp">∀</span> {i : Fin (List.length (List.append tail<span class="bp">✝</span> [α]))} (σ : Assg tail<span class="bp">✝</span>),
  <span class="bp">¬</span>i.val <span class="bp">&lt;</span> List.length tail<span class="bp">✝</span> <span class="bp">→</span> <span class="bp">∀</span> {b : List.get (List.append tail<span class="bp">✝</span> [α]) i}, dropBot (HList.set (extendBot a σ) i b) <span class="bp">=</span> σ</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>Fin (List.length (List.append (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) [α]))</span></span></span><br><span><var>fst✝</var><span class="hyp-type"><b>: </b><span>head<span class="bp">✝</span></span></span></span><br><span><var>snd✝</var><span class="hyp-type"><b>: </b><span>HList tail<span class="bp">✝</span></span></span></span><br><span><var>n✝</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>h'</var><span class="hyp-type"><b>: </b><span>Nat.succ n<span class="bp">✝</span> <span class="bp">&lt;</span> List.length (List.append (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) [α])</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span><span class="bp">¬</span>{ val := Nat.succ n<span class="bp">✝</span>, isLt := h&#39; }<span class="bp">.</span>val <span class="bp">&lt;</span> List.length (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>)</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>List.get (List.append (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) [α]) { val := Nat.succ n<span class="bp">✝</span>, isLt := h&#39; }</span></span></span><br></div><label class="goal-separator" for="Formal-lean-chkaa"><hr><span class="goal-name">cons.mk.succ</span></label><div class="goal-conclusion">dropBot (HList.set (extendBot a (fst<span class="bp">✝</span>, snd<span class="bp">✝</span>)) { val := Nat.succ n<span class="bp">✝</span>, isLt := h&#39; } b) <span class="bp">=</span> (fst<span class="bp">✝</span>, snd<span class="bp">✝</span>)</div></blockquote></div></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
    </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chkab" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chkab"><span class="alectryon-token"><span class="bp">·</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br><span><var>head✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>tail✝</var><span class="hyp-type"><b>: </b><span>List (<span class="kt">Type</span> u_1)</span></span></span><br><span><var>ih</var><span class="hyp-type"><b>: </b><span><span class="bp">∀</span> {i : Fin (List.length (List.append tail<span class="bp">✝</span> [α]))} (σ : Assg tail<span class="bp">✝</span>),
  <span class="bp">¬</span>i.val <span class="bp">&lt;</span> List.length tail<span class="bp">✝</span> <span class="bp">→</span> <span class="bp">∀</span> {b : List.get (List.append tail<span class="bp">✝</span> [α]) i}, dropBot (HList.set (extendBot a σ) i b) <span class="bp">=</span> σ</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>Fin (List.length (List.append (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) [α]))</span></span></span><br><span><var>fst✝</var><span class="hyp-type"><b>: </b><span>head<span class="bp">✝</span></span></span></span><br><span><var>snd✝</var><span class="hyp-type"><b>: </b><span>HList tail<span class="bp">✝</span></span></span></span><br><span><var>h'</var><span class="hyp-type"><b>: </b><span>Nat.zero <span class="bp">&lt;</span> List.length (List.append (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) [α])</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span><span class="bp">¬</span>{ val := Nat.zero, isLt := h&#39; }<span class="bp">.</span>val <span class="bp">&lt;</span> List.length (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>)</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>List.get (List.append (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) [α]) { val := Nat.zero, isLt := h&#39; }</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">cons.mk.zero</span></span><div class="goal-conclusion">dropBot (HList.set (extendBot a (fst<span class="bp">✝</span>, snd<span class="bp">✝</span>)) { val := Nat.zero, isLt := h&#39; } b) <span class="bp">=</span> (fst<span class="bp">✝</span>, snd<span class="bp">✝</span>)</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chkac" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chkac"><span class="alectryon-token"><span class="k">apply</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>False.elim</var><b>: </b><span>∀ {C : Prop}, False → C</span></span></div></blockquote></div></small></div>False.elim</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>h</var><b>: </b><span>¬{ val := Nat.zero, isLt := h' }.val &lt; List.length (head✝ :: tail✝)</span></span></div></blockquote></div></small></div><span class="nv">h</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat.zero_lt_succ</var><b>: </b><span>∀ (n : Nat), 0 &lt; Nat.succ n</span></span></div></blockquote></div></small></div>Nat.zero_lt_succ</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>_</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div>_</span><span class="alectryon-token">))</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
    </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chkad" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chkad"><span class="alectryon-token"><span class="bp">·</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br><span><var>head✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>tail✝</var><span class="hyp-type"><b>: </b><span>List (<span class="kt">Type</span> u_1)</span></span></span><br><span><var>ih</var><span class="hyp-type"><b>: </b><span><span class="bp">∀</span> {i : Fin (List.length (List.append tail<span class="bp">✝</span> [α]))} (σ : Assg tail<span class="bp">✝</span>),
  <span class="bp">¬</span>i.val <span class="bp">&lt;</span> List.length tail<span class="bp">✝</span> <span class="bp">→</span> <span class="bp">∀</span> {b : List.get (List.append tail<span class="bp">✝</span> [α]) i}, dropBot (HList.set (extendBot a σ) i b) <span class="bp">=</span> σ</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>Fin (List.length (List.append (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) [α]))</span></span></span><br><span><var>fst✝</var><span class="hyp-type"><b>: </b><span>head<span class="bp">✝</span></span></span></span><br><span><var>snd✝</var><span class="hyp-type"><b>: </b><span>HList tail<span class="bp">✝</span></span></span></span><br><span><var>n✝</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>h'</var><span class="hyp-type"><b>: </b><span>Nat.succ n<span class="bp">✝</span> <span class="bp">&lt;</span> List.length (List.append (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) [α])</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span><span class="bp">¬</span>{ val := Nat.succ n<span class="bp">✝</span>, isLt := h&#39; }<span class="bp">.</span>val <span class="bp">&lt;</span> List.length (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>)</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>List.get (List.append (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) [α]) { val := Nat.succ n<span class="bp">✝</span>, isLt := h&#39; }</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">cons.mk.succ</span></span><div class="goal-conclusion">dropBot (HList.set (extendBot a (fst<span class="bp">✝</span>, snd<span class="bp">✝</span>)) { val := Nat.succ n<span class="bp">✝</span>, isLt := h&#39; } b) <span class="bp">=</span> (fst<span class="bp">✝</span>, snd<span class="bp">✝</span>)</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chkae" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chkae"><span class="alectryon-token"><span class="k">simp</span></span><span class="alectryon-token"> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>HList.set</var><b>: </b><span>{αs : List (Type ?u.548613)} → HList αs → (i : Fin (List.length αs)) → List.get αs i → HList αs</span></span></div></blockquote></div></small></div>HList.set</span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>dropBot</var><b>: </b><span>{α : Type ?u.548670} → {Γ : List (Type ?u.548670)} → Assg (List.append Γ [α]) → Assg Γ</span></span></div></blockquote></div></small></div>dropBot</span><span class="alectryon-token">]</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br><span><var>head✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>tail✝</var><span class="hyp-type"><b>: </b><span>List (<span class="kt">Type</span> u_1)</span></span></span><br><span><var>ih</var><span class="hyp-type"><b>: </b><span><span class="bp">∀</span> {i : Fin (List.length (List.append tail<span class="bp">✝</span> [α]))} (σ : Assg tail<span class="bp">✝</span>),
  <span class="bp">¬</span>i.val <span class="bp">&lt;</span> List.length tail<span class="bp">✝</span> <span class="bp">→</span> <span class="bp">∀</span> {b : List.get (List.append tail<span class="bp">✝</span> [α]) i}, dropBot (HList.set (extendBot a σ) i b) <span class="bp">=</span> σ</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>Fin (List.length (List.append (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) [α]))</span></span></span><br><span><var>fst✝</var><span class="hyp-type"><b>: </b><span>head<span class="bp">✝</span></span></span></span><br><span><var>snd✝</var><span class="hyp-type"><b>: </b><span>HList tail<span class="bp">✝</span></span></span></span><br><span><var>n✝</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>h'</var><span class="hyp-type"><b>: </b><span>Nat.succ n<span class="bp">✝</span> <span class="bp">&lt;</span> List.length (List.append (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) [α])</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span><span class="bp">¬</span>{ val := Nat.succ n<span class="bp">✝</span>, isLt := h&#39; }<span class="bp">.</span>val <span class="bp">&lt;</span> List.length (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>)</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>List.get (List.append (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) [α]) { val := Nat.succ n<span class="bp">✝</span>, isLt := h&#39; }</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">cons.mk.succ</span></span><div class="goal-conclusion">fst<span class="bp">✝</span> :: dropBot (HList.set (extendBot a snd<span class="bp">✝</span>) { val := n<span class="bp">✝</span>, isLt := (_ : Nat.succ n<span class="bp">✝</span> <span class="bp">≤</span> List.length (tail<span class="bp">✝</span> <span class="bp">++</span> [α])) } b) <span class="bp">=</span>
  (fst<span class="bp">✝</span>, snd<span class="bp">✝</span>)</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
      </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chkaf" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chkaf"><span class="alectryon-token"><span class="k">rw</span></span><span class="alectryon-token"> [</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br><span><var>head✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>tail✝</var><span class="hyp-type"><b>: </b><span>List (<span class="kt">Type</span> u_1)</span></span></span><br><span><var>ih</var><span class="hyp-type"><b>: </b><span><span class="bp">∀</span> {i : Fin (List.length (List.append tail<span class="bp">✝</span> [α]))} (σ : Assg tail<span class="bp">✝</span>),
  <span class="bp">¬</span>i.val <span class="bp">&lt;</span> List.length tail<span class="bp">✝</span> <span class="bp">→</span> <span class="bp">∀</span> {b : List.get (List.append tail<span class="bp">✝</span> [α]) i}, dropBot (HList.set (extendBot a σ) i b) <span class="bp">=</span> σ</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>Fin (List.length (List.append (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) [α]))</span></span></span><br><span><var>fst✝</var><span class="hyp-type"><b>: </b><span>head<span class="bp">✝</span></span></span></span><br><span><var>snd✝</var><span class="hyp-type"><b>: </b><span>HList tail<span class="bp">✝</span></span></span></span><br><span><var>n✝</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>h'</var><span class="hyp-type"><b>: </b><span>Nat.succ n<span class="bp">✝</span> <span class="bp">&lt;</span> List.length (List.append (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) [α])</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span><span class="bp">¬</span>{ val := Nat.succ n<span class="bp">✝</span>, isLt := h&#39; }<span class="bp">.</span>val <span class="bp">&lt;</span> List.length (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>)</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>List.get (List.append (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) [α]) { val := Nat.succ n<span class="bp">✝</span>, isLt := h&#39; }</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">cons.mk.succ</span></span><div class="goal-conclusion">fst<span class="bp">✝</span> :: dropBot (HList.set (extendBot a snd<span class="bp">✝</span>) { val := n<span class="bp">✝</span>, isLt := (_ : Nat.succ n<span class="bp">✝</span> <span class="bp">≤</span> List.length (tail<span class="bp">✝</span> <span class="bp">++</span> [α])) } b) <span class="bp">=</span>
  (fst<span class="bp">✝</span>, snd<span class="bp">✝</span>)</div></blockquote></div></div></small></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chkb0" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chkb0"><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ih</var><b>: </b><span>∀ {i : Fin (List.length (List.append tail✝ [α]))} (σ : Assg tail✝),
  ¬i.val &lt; List.length tail✝ → ∀ {b : List.get (List.append tail✝ [α]) i}, dropBot (HList.set (extendBot a σ) i b) = σ</span></span></div></blockquote></div></small></div><span class="nv">ih</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br><span><var>head✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>tail✝</var><span class="hyp-type"><b>: </b><span>List (<span class="kt">Type</span> u_1)</span></span></span><br><span><var>ih</var><span class="hyp-type"><b>: </b><span><span class="bp">∀</span> {i : Fin (List.length (List.append tail<span class="bp">✝</span> [α]))} (σ : Assg tail<span class="bp">✝</span>),
  <span class="bp">¬</span>i.val <span class="bp">&lt;</span> List.length tail<span class="bp">✝</span> <span class="bp">→</span> <span class="bp">∀</span> {b : List.get (List.append tail<span class="bp">✝</span> [α]) i}, dropBot (HList.set (extendBot a σ) i b) <span class="bp">=</span> σ</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>Fin (List.length (List.append (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) [α]))</span></span></span><br><span><var>fst✝</var><span class="hyp-type"><b>: </b><span>head<span class="bp">✝</span></span></span></span><br><span><var>snd✝</var><span class="hyp-type"><b>: </b><span>HList tail<span class="bp">✝</span></span></span></span><br><span><var>n✝</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>h'</var><span class="hyp-type"><b>: </b><span>Nat.succ n<span class="bp">✝</span> <span class="bp">&lt;</span> List.length (List.append (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) [α])</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span><span class="bp">¬</span>{ val := Nat.succ n<span class="bp">✝</span>, isLt := h&#39; }<span class="bp">.</span>val <span class="bp">&lt;</span> List.length (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>)</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>List.get (List.append (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) [α]) { val := Nat.succ n<span class="bp">✝</span>, isLt := h&#39; }</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">cons.mk.succ</span></span><div class="goal-conclusion">fst<span class="bp">✝</span> :: snd<span class="bp">✝</span> <span class="bp">=</span> (fst<span class="bp">✝</span>, snd<span class="bp">✝</span>)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Formal-lean-chkb1" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br><span><var>head✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>tail✝</var><span class="hyp-type"><b>: </b><span>List (<span class="kt">Type</span> u_1)</span></span></span><br><span><var>ih</var><span class="hyp-type"><b>: </b><span><span class="bp">∀</span> {i : Fin (List.length (List.append tail<span class="bp">✝</span> [α]))} (σ : Assg tail<span class="bp">✝</span>),
  <span class="bp">¬</span>i.val <span class="bp">&lt;</span> List.length tail<span class="bp">✝</span> <span class="bp">→</span> <span class="bp">∀</span> {b : List.get (List.append tail<span class="bp">✝</span> [α]) i}, dropBot (HList.set (extendBot a σ) i b) <span class="bp">=</span> σ</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>Fin (List.length (List.append (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) [α]))</span></span></span><br><span><var>fst✝</var><span class="hyp-type"><b>: </b><span>head<span class="bp">✝</span></span></span></span><br><span><var>snd✝</var><span class="hyp-type"><b>: </b><span>HList tail<span class="bp">✝</span></span></span></span><br><span><var>n✝</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>h'</var><span class="hyp-type"><b>: </b><span>Nat.succ n<span class="bp">✝</span> <span class="bp">&lt;</span> List.length (List.append (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) [α])</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span><span class="bp">¬</span>{ val := Nat.succ n<span class="bp">✝</span>, isLt := h&#39; }<span class="bp">.</span>val <span class="bp">&lt;</span> List.length (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>)</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>List.get (List.append (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) [α]) { val := Nat.succ n<span class="bp">✝</span>, isLt := h&#39; }</span></span></span><br></div><label class="goal-separator" for="Formal-lean-chkb1"><hr><span class="goal-name">cons.mk.succ.h</span></label><div class="goal-conclusion"><span class="bp">¬</span>{ val := n<span class="bp">✝</span>, isLt := (_ : Nat.succ n<span class="bp">✝</span> <span class="bp">≤</span> List.length (tail<span class="bp">✝</span> <span class="bp">++</span> [α])) }<span class="bp">.</span>val <span class="bp">&lt;</span> List.length tail<span class="bp">✝</span></div></blockquote></div></div></div></small></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chkb2" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chkb2"><span class="alectryon-token">]</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br><span><var>head✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>tail✝</var><span class="hyp-type"><b>: </b><span>List (<span class="kt">Type</span> u_1)</span></span></span><br><span><var>ih</var><span class="hyp-type"><b>: </b><span><span class="bp">∀</span> {i : Fin (List.length (List.append tail<span class="bp">✝</span> [α]))} (σ : Assg tail<span class="bp">✝</span>),
  <span class="bp">¬</span>i.val <span class="bp">&lt;</span> List.length tail<span class="bp">✝</span> <span class="bp">→</span> <span class="bp">∀</span> {b : List.get (List.append tail<span class="bp">✝</span> [α]) i}, dropBot (HList.set (extendBot a σ) i b) <span class="bp">=</span> σ</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>Fin (List.length (List.append (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) [α]))</span></span></span><br><span><var>fst✝</var><span class="hyp-type"><b>: </b><span>head<span class="bp">✝</span></span></span></span><br><span><var>snd✝</var><span class="hyp-type"><b>: </b><span>HList tail<span class="bp">✝</span></span></span></span><br><span><var>n✝</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>h'</var><span class="hyp-type"><b>: </b><span>Nat.succ n<span class="bp">✝</span> <span class="bp">&lt;</span> List.length (List.append (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) [α])</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span><span class="bp">¬</span>{ val := Nat.succ n<span class="bp">✝</span>, isLt := h&#39; }<span class="bp">.</span>val <span class="bp">&lt;</span> List.length (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>)</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>List.get (List.append (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) [α]) { val := Nat.succ n<span class="bp">✝</span>, isLt := h&#39; }</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">cons.mk.succ.h</span></span><div class="goal-conclusion"><span class="bp">¬</span>{ val := n<span class="bp">✝</span>, isLt := (_ : Nat.succ n<span class="bp">✝</span> <span class="bp">≤</span> List.length (tail<span class="bp">✝</span> <span class="bp">++</span> [α])) }<span class="bp">.</span>val <span class="bp">&lt;</span> List.length tail<span class="bp">✝</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
      </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chkb3" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chkb3"><span class="alectryon-token"><span class="k">intro</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>h''</var><b>: </b><span>{ val := n✝, isLt := (_ : Nat.succ n✝ ≤ List.length (tail✝ ++ [α])) }.val &lt; List.length tail✝</span></span></div></blockquote></div></small></div><span class="nv">h&#39;&#39;</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br><span><var>head✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>tail✝</var><span class="hyp-type"><b>: </b><span>List (<span class="kt">Type</span> u_1)</span></span></span><br><span><var>ih</var><span class="hyp-type"><b>: </b><span><span class="bp">∀</span> {i : Fin (List.length (List.append tail<span class="bp">✝</span> [α]))} (σ : Assg tail<span class="bp">✝</span>),
  <span class="bp">¬</span>i.val <span class="bp">&lt;</span> List.length tail<span class="bp">✝</span> <span class="bp">→</span> <span class="bp">∀</span> {b : List.get (List.append tail<span class="bp">✝</span> [α]) i}, dropBot (HList.set (extendBot a σ) i b) <span class="bp">=</span> σ</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>Fin (List.length (List.append (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) [α]))</span></span></span><br><span><var>fst✝</var><span class="hyp-type"><b>: </b><span>head<span class="bp">✝</span></span></span></span><br><span><var>snd✝</var><span class="hyp-type"><b>: </b><span>HList tail<span class="bp">✝</span></span></span></span><br><span><var>n✝</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>h'</var><span class="hyp-type"><b>: </b><span>Nat.succ n<span class="bp">✝</span> <span class="bp">&lt;</span> List.length (List.append (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) [α])</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span><span class="bp">¬</span>{ val := Nat.succ n<span class="bp">✝</span>, isLt := h&#39; }<span class="bp">.</span>val <span class="bp">&lt;</span> List.length (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>)</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>List.get (List.append (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) [α]) { val := Nat.succ n<span class="bp">✝</span>, isLt := h&#39; }</span></span></span><br><span><var>h''</var><span class="hyp-type"><b>: </b><span>{ val := n<span class="bp">✝</span>, isLt := (_ : Nat.succ n<span class="bp">✝</span> <span class="bp">≤</span> List.length (tail<span class="bp">✝</span> <span class="bp">++</span> [α])) }<span class="bp">.</span>val <span class="bp">&lt;</span> List.length tail<span class="bp">✝</span></span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">cons.mk.succ.h</span></span><div class="goal-conclusion">False</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
      </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chkb4" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chkb4"><span class="alectryon-token"><span class="k">apply</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>False.elim</var><b>: </b><span>∀ {C : Prop}, False → C</span></span></div></blockquote></div></small></div>False.elim</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>h</var><b>: </b><span>¬{ val := Nat.succ n✝, isLt := h' }.val &lt; List.length (head✝ :: tail✝)</span></span></div></blockquote></div></small></div><span class="nv">h</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat.succ_lt_succ</var><b>: </b><span>∀ {n m : Nat}, n &lt; m → Nat.succ n &lt; Nat.succ m</span></span></div></blockquote></div></small></div>Nat.succ_lt_succ</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>h''</var><b>: </b><span>{ val := n✝, isLt := (_ : Nat.succ n✝ ≤ List.length (tail✝ ++ [α])) }.val &lt; List.length tail✝</span></span></div></blockquote></div></small></div><span class="nv">h&#39;&#39;</span></span><span class="alectryon-token">))</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">

<span class="bp">@</span>[</span><span class="alectryon-token"><span class="k">simp</span></span><span class="alectryon-token">] </span><span class="alectryon-token"><span class="kd">theorem</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Assg.bot_set_extendBot_bottom</var><b>: </b><span>∀ {α : Type u_1} {Γ : List (Type u_1)} {i : Fin (List.length (List.append Γ [α]))} (a : α) (σ : Assg Γ),
  ¬i.val &lt; List.length Γ →
    ∀ {b : List.get (List.append Γ [α]) i}, bot (HList.set (extendBot a σ) i b) = cast (_ : List.get (Γ ++ [α]) i = α) b</span></span></div></blockquote></div></small></div><span class="nv">Assg.bot_set_extendBot_bottom</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type u_1</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token">) (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>σ</var><b>: </b><span>Assg Γ</span></span></div></blockquote></div></small></div><span class="nv">σ</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Assg</var><b>: </b><span>List (Type u_1) → Type u_1</span></span></div></blockquote></div></small></div>Assg</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Γ</var><b>: </b><span>List (Type u_1)</span></span></div></blockquote></div></small></div><span class="nv">Γ</span></span><span class="alectryon-token">) (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>h</var><b>: </b><span>¬i.val &lt; List.length Γ</span></span></div></blockquote></div></small></div><span class="nv">h</span></span><span class="alectryon-token"> : <span class="bp">¬</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>i</var><b>: </b><span>Fin (List.length (List.append Γ [α]))</span></span></div></blockquote></div></small></div><span class="nv">i</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>1</var><b>: </b><span>{n : Nat} → Fin n → Nat</span></span></div></blockquote></div></small></div><span class="mi">1</span></span><span class="alectryon-token"> <span class="bp">&lt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Γ</var><b>: </b><span>List (Type u_1)</span></span></div></blockquote></div></small></div><span class="nv">Γ</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>length</var><b>: </b><span>{α : Type (u_1 + 1)} → List α → Nat</span></span></div></blockquote></div></small></div>length</span><span class="alectryon-token">) {</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>List.get (List.append Γ [α]) i</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token">} : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Assg.bot</var><b>: </b><span>{α : Type u_1} → {Γ : List (Type u_1)} → Assg (List.append Γ [α]) → α</span></span></div></blockquote></div></small></div>Assg.bot</span><span class="alectryon-token"> ((</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Assg.extendBot</var><b>: </b><span>{α : Type u_1} → α → {Γ : List (Type u_1)} → Assg Γ → Assg (List.append Γ [α])</span></span></div></blockquote></div></small></div>Assg.extendBot</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>σ</var><b>: </b><span>Assg Γ</span></span></div></blockquote></div></small></div><span class="nv">σ</span></span><span class="alectryon-token">)<span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>set</var><b>: </b><span>{αs : List (Type u_1)} → HList αs → (i : Fin (List.length αs)) → List.get αs i → HList αs</span></span></div></blockquote></div></small></div><span class="na">set</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>i</var><b>: </b><span>Fin (List.length (List.append Γ [α]))</span></span></div></blockquote></div></small></div><span class="nv">i</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>List.get (List.append Γ [α]) i</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token">) <span class="bp">=</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>cast</var><b>: </b><span>{α β : Type u_1} → α = β → α → β</span></span></div></blockquote></div></small></div>cast</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>List.get_last</var><b>: </b><span>∀ {α : Type (u_1 + 1)} {a : α} {as : List α} {i : Fin (List.length (as ++ [a]))},
  ¬i.val &lt; List.length as → List.get (as ++ [a]) i = a</span></span></div></blockquote></div></small></div>List.get_last</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>h</var><b>: </b><span>¬i.val &lt; List.length Γ</span></span></div></blockquote></div></small></div><span class="nv">h</span></span><span class="alectryon-token">) </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>List.get (List.append Γ [α]) i</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token"> := </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chkb5" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chkb5"><span class="alectryon-token"><span class="kd">by</span></span><span class="alectryon-token"></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>List (<span class="kt">Type</span> u_1)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>Fin (List.length (List.append <span class="bp">Γ</span> [α]))</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br><span><var>σ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ</span></span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span><span class="bp">¬</span>i.val <span class="bp">&lt;</span> List.length <span class="bp">Γ</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>List.get (List.append <span class="bp">Γ</span> [α]) i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bot (HList.set (extendBot a σ) i b) <span class="bp">=</span> cast (_ : List.get (<span class="bp">Γ</span> <span class="bp">++</span> [α]) i <span class="bp">=</span> α) b</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chkb6" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chkb6"><span class="alectryon-token"><span class="k">induction</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Γ</var><b>: </b><span>List (Type u_1)</span></span></div></blockquote></div></small></div><span class="nv">Γ</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">with</span></span><span class="alectryon-token"></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>List (<span class="kt">Type</span> u_1)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>Fin (List.length (List.append <span class="bp">Γ</span> [α]))</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br><span><var>σ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ</span></span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span><span class="bp">¬</span>i.val <span class="bp">&lt;</span> List.length <span class="bp">Γ</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>List.get (List.append <span class="bp">Γ</span> [α]) i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bot (HList.set (extendBot a σ) i b) <span class="bp">=</span> cast (_ : List.get (<span class="bp">Γ</span> <span class="bp">++</span> [α]) i <span class="bp">=</span> α) b</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chkb7" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chkb7"><span class="alectryon-token"><span class="bp">|</span> nil <span class="bp">=&gt;</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>Fin (List.length (List.append [] [α]))</span></span></span><br><span><var>σ</var><span class="hyp-type"><b>: </b><span>Assg []</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span><span class="bp">¬</span>i.val <span class="bp">&lt;</span> List.length []</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>List.get (List.append [] [α]) i</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">nil</span></span><div class="goal-conclusion">bot (HList.set (extendBot a σ) i b) <span class="bp">=</span> cast (_ : List.get ([] <span class="bp">++</span> [α]) i <span class="bp">=</span> α) b</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
    </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chkb8" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chkb8"><span class="alectryon-token"><span class="k">have</span></span><span class="alectryon-token"> ⟨</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>i</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">i</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>h'</var><b>: </b><span>i &lt; List.length (List.append [] [α])</span></span></div></blockquote></div></small></div><span class="nv">h&#39;</span></span><span class="alectryon-token">⟩ := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>i</var><b>: </b><span>Fin (List.length (List.append [] [α]))</span></span></div></blockquote></div></small></div><span class="nv">i</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br><span><var>i✝</var><span class="hyp-type"><b>: </b><span>Fin (List.length (List.append [] [α]))</span></span></span><br><span><var>σ</var><span class="hyp-type"><b>: </b><span>Assg []</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>h'</var><span class="hyp-type"><b>: </b><span>i <span class="bp">&lt;</span> List.length (List.append [] [α])</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span><span class="bp">¬</span>{ val := i, isLt := h&#39; }<span class="bp">.</span>val <span class="bp">&lt;</span> List.length []</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>List.get (List.append [] [α]) { val := i, isLt := h&#39; }</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">nil</span></span><div class="goal-conclusion">bot (HList.set (extendBot a σ) { val := i, isLt := h&#39; } b) <span class="bp">=</span>
  cast (_ : List.get ([] <span class="bp">++</span> [α]) { val := i, isLt := h&#39; } <span class="bp">=</span> α) b</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
    </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chkb9" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chkb9"><span class="alectryon-token"><span class="k">cases</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>i</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">i</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>Fin (List.length (List.append [] [α]))</span></span></span><br><span><var>σ</var><span class="hyp-type"><b>: </b><span>Assg []</span></span></span><br><span><var>h'</var><span class="hyp-type"><b>: </b><span>Nat.zero <span class="bp">&lt;</span> List.length (List.append [] [α])</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span><span class="bp">¬</span>{ val := Nat.zero, isLt := h&#39; }<span class="bp">.</span>val <span class="bp">&lt;</span> List.length []</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>List.get (List.append [] [α]) { val := Nat.zero, isLt := h&#39; }</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">nil.zero</span></span><div class="goal-conclusion">bot (HList.set (extendBot a σ) { val := Nat.zero, isLt := h&#39; } b) <span class="bp">=</span>
  cast (_ : List.get ([] <span class="bp">++</span> [α]) { val := Nat.zero, isLt := h&#39; } <span class="bp">=</span> α) b</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Formal-lean-chkba" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>Fin (List.length (List.append [] [α]))</span></span></span><br><span><var>σ</var><span class="hyp-type"><b>: </b><span>Assg []</span></span></span><br><span><var>n✝</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>h'</var><span class="hyp-type"><b>: </b><span>Nat.succ n<span class="bp">✝</span> <span class="bp">&lt;</span> List.length (List.append [] [α])</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span><span class="bp">¬</span>{ val := Nat.succ n<span class="bp">✝</span>, isLt := h&#39; }<span class="bp">.</span>val <span class="bp">&lt;</span> List.length []</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>List.get (List.append [] [α]) { val := Nat.succ n<span class="bp">✝</span>, isLt := h&#39; }</span></span></span><br></div><label class="goal-separator" for="Formal-lean-chkba"><hr><span class="goal-name">nil.succ</span></label><div class="goal-conclusion">bot (HList.set (extendBot a σ) { val := Nat.succ n<span class="bp">✝</span>, isLt := h&#39; } b) <span class="bp">=</span>
  cast (_ : List.get ([] <span class="bp">++</span> [α]) { val := Nat.succ n<span class="bp">✝</span>, isLt := h&#39; } <span class="bp">=</span> α) b</div></blockquote></div></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
    </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chkbb" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chkbb"><span class="alectryon-token"><span class="bp">·</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>Fin (List.length (List.append [] [α]))</span></span></span><br><span><var>σ</var><span class="hyp-type"><b>: </b><span>Assg []</span></span></span><br><span><var>h'</var><span class="hyp-type"><b>: </b><span>Nat.zero <span class="bp">&lt;</span> List.length (List.append [] [α])</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span><span class="bp">¬</span>{ val := Nat.zero, isLt := h&#39; }<span class="bp">.</span>val <span class="bp">&lt;</span> List.length []</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>List.get (List.append [] [α]) { val := Nat.zero, isLt := h&#39; }</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">nil.zero</span></span><div class="goal-conclusion">bot (HList.set (extendBot a σ) { val := Nat.zero, isLt := h&#39; } b) <span class="bp">=</span>
  cast (_ : List.get ([] <span class="bp">++</span> [α]) { val := Nat.zero, isLt := h&#39; } <span class="bp">=</span> α) b</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chkbc" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chkbc"><span class="alectryon-token"><span class="k">simp</span></span><span class="alectryon-token"> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>HList.set</var><b>: </b><span>{αs : List (Type ?u.550219)} → HList αs → (i : Fin (List.length αs)) → List.get αs i → HList αs</span></span></div></blockquote></div></small></div>HList.set</span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>extendBot</var><b>: </b><span>{α : Type ?u.550276} → α → {Γ : List (Type ?u.550276)} → Assg Γ → Assg (List.append Γ [α])</span></span></div></blockquote></div></small></div>extendBot</span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>bot</var><b>: </b><span>{α : Type ?u.550308} → {Γ : List (Type ?u.550308)} → Assg (List.append Γ [α]) → α</span></span></div></blockquote></div></small></div>bot</span><span class="alectryon-token">]</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>Fin (List.length (List.append [] [α]))</span></span></span><br><span><var>σ</var><span class="hyp-type"><b>: </b><span>Assg []</span></span></span><br><span><var>h'</var><span class="hyp-type"><b>: </b><span>Nat.zero <span class="bp">&lt;</span> List.length (List.append [] [α])</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span><span class="bp">¬</span>{ val := Nat.zero, isLt := h&#39; }<span class="bp">.</span>val <span class="bp">&lt;</span> List.length []</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>List.get (List.append [] [α]) { val := Nat.zero, isLt := h&#39; }</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">nil.zero</span></span><div class="goal-conclusion">b <span class="bp">=</span> cast (_ : List.get ([] <span class="bp">++</span> [α]) { val := Nat.zero, isLt := h&#39; } <span class="bp">=</span> α) b</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"><span class="bp">;</span></span><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chkbd" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chkbd"><span class="alectryon-token"><span class="k">rfl</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
    </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chkbe" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chkbe"><span class="alectryon-token"><span class="bp">·</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>Fin (List.length (List.append [] [α]))</span></span></span><br><span><var>σ</var><span class="hyp-type"><b>: </b><span>Assg []</span></span></span><br><span><var>n✝</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>h'</var><span class="hyp-type"><b>: </b><span>Nat.succ n<span class="bp">✝</span> <span class="bp">&lt;</span> List.length (List.append [] [α])</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span><span class="bp">¬</span>{ val := Nat.succ n<span class="bp">✝</span>, isLt := h&#39; }<span class="bp">.</span>val <span class="bp">&lt;</span> List.length []</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>List.get (List.append [] [α]) { val := Nat.succ n<span class="bp">✝</span>, isLt := h&#39; }</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">nil.succ</span></span><div class="goal-conclusion">bot (HList.set (extendBot a σ) { val := Nat.succ n<span class="bp">✝</span>, isLt := h&#39; } b) <span class="bp">=</span>
  cast (_ : List.get ([] <span class="bp">++</span> [α]) { val := Nat.succ n<span class="bp">✝</span>, isLt := h&#39; } <span class="bp">=</span> α) b</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chkbf" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chkbf"><span class="alectryon-token"><span class="k">apply</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>False.elim</var><b>: </b><span>∀ {C : Prop}, False → C</span></span></div></blockquote></div></small></div>False.elim</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat.not_lt_zero</var><b>: </b><span>∀ (n : Nat), ¬n &lt; 0</span></span></div></blockquote></div></small></div>Nat.not_lt_zero</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>_</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div>_</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat.lt_of_succ_lt_succ</var><b>: </b><span>∀ {n m : Nat}, Nat.succ n &lt; Nat.succ m → n &lt; m</span></span></div></blockquote></div></small></div>Nat.lt_of_succ_lt_succ</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>h'</var><b>: </b><span>Nat.succ n✝ &lt; List.length (List.append [] [α])</span></span></div></blockquote></div></small></div><span class="nv">h&#39;</span></span><span class="alectryon-token">))</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chkc0" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chkc0"><span class="alectryon-token"><span class="bp">|</span> cons  </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>_</var><b>: </b><span>Type u_1</span></span></div></blockquote></div></small></div>_</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>_</var><b>: </b><span>List (Type u_1)</span></span></div></blockquote></div></small></div>_</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ih</var><b>: </b><span>∀ {i : Fin (List.length (List.append tail✝ [α]))} (σ : Assg tail✝),
  ¬i.val &lt; List.length tail✝ →
    ∀ {b : List.get (List.append tail✝ [α]) i},
      bot (HList.set (extendBot a σ) i b) = cast (_ : List.get (tail✝ ++ [α]) i = α) b</span></span></div></blockquote></div></small></div><span class="nv">ih</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br><span><var>head✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>tail✝</var><span class="hyp-type"><b>: </b><span>List (<span class="kt">Type</span> u_1)</span></span></span><br><span><var>ih</var><span class="hyp-type"><b>: </b><span><span class="bp">∀</span> {i : Fin (List.length (List.append tail<span class="bp">✝</span> [α]))} (σ : Assg tail<span class="bp">✝</span>),
  <span class="bp">¬</span>i.val <span class="bp">&lt;</span> List.length tail<span class="bp">✝</span> <span class="bp">→</span>
    <span class="bp">∀</span> {b : List.get (List.append tail<span class="bp">✝</span> [α]) i},
      bot (HList.set (extendBot a σ) i b) <span class="bp">=</span> cast (_ : List.get (tail<span class="bp">✝</span> <span class="bp">++</span> [α]) i <span class="bp">=</span> α) b</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>Fin (List.length (List.append (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) [α]))</span></span></span><br><span><var>σ</var><span class="hyp-type"><b>: </b><span>Assg (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>)</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span><span class="bp">¬</span>i.val <span class="bp">&lt;</span> List.length (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>)</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>List.get (List.append (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) [α]) i</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">cons</span></span><div class="goal-conclusion">bot (HList.set (extendBot a σ) i b) <span class="bp">=</span> cast (_ : List.get (head<span class="bp">✝</span> :: tail<span class="bp">✝</span> <span class="bp">++</span> [α]) i <span class="bp">=</span> α) b</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
    </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chkc1" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chkc1"><span class="alectryon-token"><span class="k">cases</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>σ</var><b>: </b><span>Assg (head✝ :: tail✝)</span></span></div></blockquote></div></small></div><span class="nv">σ</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br><span><var>head✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>tail✝</var><span class="hyp-type"><b>: </b><span>List (<span class="kt">Type</span> u_1)</span></span></span><br><span><var>ih</var><span class="hyp-type"><b>: </b><span><span class="bp">∀</span> {i : Fin (List.length (List.append tail<span class="bp">✝</span> [α]))} (σ : Assg tail<span class="bp">✝</span>),
  <span class="bp">¬</span>i.val <span class="bp">&lt;</span> List.length tail<span class="bp">✝</span> <span class="bp">→</span>
    <span class="bp">∀</span> {b : List.get (List.append tail<span class="bp">✝</span> [α]) i},
      bot (HList.set (extendBot a σ) i b) <span class="bp">=</span> cast (_ : List.get (tail<span class="bp">✝</span> <span class="bp">++</span> [α]) i <span class="bp">=</span> α) b</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>Fin (List.length (List.append (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) [α]))</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span><span class="bp">¬</span>i.val <span class="bp">&lt;</span> List.length (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>)</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>List.get (List.append (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) [α]) i</span></span></span><br><span><var>fst✝</var><span class="hyp-type"><b>: </b><span>head<span class="bp">✝</span></span></span></span><br><span><var>snd✝</var><span class="hyp-type"><b>: </b><span>HList tail<span class="bp">✝</span></span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">cons.mk</span></span><div class="goal-conclusion">bot (HList.set (extendBot a (fst<span class="bp">✝</span>, snd<span class="bp">✝</span>)) i b) <span class="bp">=</span> cast (_ : List.get (head<span class="bp">✝</span> :: tail<span class="bp">✝</span> <span class="bp">++</span> [α]) i <span class="bp">=</span> α) b</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
    </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chkc2" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chkc2"><span class="alectryon-token"><span class="k">have</span></span><span class="alectryon-token"> ⟨</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>i</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">i</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>h'</var><b>: </b><span>i &lt; List.length (List.append (head✝ :: tail✝) [α])</span></span></div></blockquote></div></small></div><span class="nv">h&#39;</span></span><span class="alectryon-token">⟩ := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>i</var><b>: </b><span>Fin (List.length (List.append (head✝ :: tail✝) [α]))</span></span></div></blockquote></div></small></div><span class="nv">i</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br><span><var>head✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>tail✝</var><span class="hyp-type"><b>: </b><span>List (<span class="kt">Type</span> u_1)</span></span></span><br><span><var>ih</var><span class="hyp-type"><b>: </b><span><span class="bp">∀</span> {i : Fin (List.length (List.append tail<span class="bp">✝</span> [α]))} (σ : Assg tail<span class="bp">✝</span>),
  <span class="bp">¬</span>i.val <span class="bp">&lt;</span> List.length tail<span class="bp">✝</span> <span class="bp">→</span>
    <span class="bp">∀</span> {b : List.get (List.append tail<span class="bp">✝</span> [α]) i},
      bot (HList.set (extendBot a σ) i b) <span class="bp">=</span> cast (_ : List.get (tail<span class="bp">✝</span> <span class="bp">++</span> [α]) i <span class="bp">=</span> α) b</span></span></span><br><span><var>i✝</var><span class="hyp-type"><b>: </b><span>Fin (List.length (List.append (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) [α]))</span></span></span><br><span><var>fst✝</var><span class="hyp-type"><b>: </b><span>head<span class="bp">✝</span></span></span></span><br><span><var>snd✝</var><span class="hyp-type"><b>: </b><span>HList tail<span class="bp">✝</span></span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>h'</var><span class="hyp-type"><b>: </b><span>i <span class="bp">&lt;</span> List.length (List.append (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) [α])</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span><span class="bp">¬</span>{ val := i, isLt := h&#39; }<span class="bp">.</span>val <span class="bp">&lt;</span> List.length (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>)</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>List.get (List.append (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) [α]) { val := i, isLt := h&#39; }</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">cons.mk</span></span><div class="goal-conclusion">bot (HList.set (extendBot a (fst<span class="bp">✝</span>, snd<span class="bp">✝</span>)) { val := i, isLt := h&#39; } b) <span class="bp">=</span>
  cast (_ : List.get (head<span class="bp">✝</span> :: tail<span class="bp">✝</span> <span class="bp">++</span> [α]) { val := i, isLt := h&#39; } <span class="bp">=</span> α) b</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
    </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chkc3" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chkc3"><span class="alectryon-token"><span class="k">cases</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>i</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">i</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br><span><var>head✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>tail✝</var><span class="hyp-type"><b>: </b><span>List (<span class="kt">Type</span> u_1)</span></span></span><br><span><var>ih</var><span class="hyp-type"><b>: </b><span><span class="bp">∀</span> {i : Fin (List.length (List.append tail<span class="bp">✝</span> [α]))} (σ : Assg tail<span class="bp">✝</span>),
  <span class="bp">¬</span>i.val <span class="bp">&lt;</span> List.length tail<span class="bp">✝</span> <span class="bp">→</span>
    <span class="bp">∀</span> {b : List.get (List.append tail<span class="bp">✝</span> [α]) i},
      bot (HList.set (extendBot a σ) i b) <span class="bp">=</span> cast (_ : List.get (tail<span class="bp">✝</span> <span class="bp">++</span> [α]) i <span class="bp">=</span> α) b</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>Fin (List.length (List.append (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) [α]))</span></span></span><br><span><var>fst✝</var><span class="hyp-type"><b>: </b><span>head<span class="bp">✝</span></span></span></span><br><span><var>snd✝</var><span class="hyp-type"><b>: </b><span>HList tail<span class="bp">✝</span></span></span></span><br><span><var>h'</var><span class="hyp-type"><b>: </b><span>Nat.zero <span class="bp">&lt;</span> List.length (List.append (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) [α])</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span><span class="bp">¬</span>{ val := Nat.zero, isLt := h&#39; }<span class="bp">.</span>val <span class="bp">&lt;</span> List.length (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>)</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>List.get (List.append (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) [α]) { val := Nat.zero, isLt := h&#39; }</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">cons.mk.zero</span></span><div class="goal-conclusion">bot (HList.set (extendBot a (fst<span class="bp">✝</span>, snd<span class="bp">✝</span>)) { val := Nat.zero, isLt := h&#39; } b) <span class="bp">=</span>
  cast (_ : List.get (head<span class="bp">✝</span> :: tail<span class="bp">✝</span> <span class="bp">++</span> [α]) { val := Nat.zero, isLt := h&#39; } <span class="bp">=</span> α) b</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Formal-lean-chkc4" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br><span><var>head✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>tail✝</var><span class="hyp-type"><b>: </b><span>List (<span class="kt">Type</span> u_1)</span></span></span><br><span><var>ih</var><span class="hyp-type"><b>: </b><span><span class="bp">∀</span> {i : Fin (List.length (List.append tail<span class="bp">✝</span> [α]))} (σ : Assg tail<span class="bp">✝</span>),
  <span class="bp">¬</span>i.val <span class="bp">&lt;</span> List.length tail<span class="bp">✝</span> <span class="bp">→</span>
    <span class="bp">∀</span> {b : List.get (List.append tail<span class="bp">✝</span> [α]) i},
      bot (HList.set (extendBot a σ) i b) <span class="bp">=</span> cast (_ : List.get (tail<span class="bp">✝</span> <span class="bp">++</span> [α]) i <span class="bp">=</span> α) b</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>Fin (List.length (List.append (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) [α]))</span></span></span><br><span><var>fst✝</var><span class="hyp-type"><b>: </b><span>head<span class="bp">✝</span></span></span></span><br><span><var>snd✝</var><span class="hyp-type"><b>: </b><span>HList tail<span class="bp">✝</span></span></span></span><br><span><var>n✝</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>h'</var><span class="hyp-type"><b>: </b><span>Nat.succ n<span class="bp">✝</span> <span class="bp">&lt;</span> List.length (List.append (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) [α])</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span><span class="bp">¬</span>{ val := Nat.succ n<span class="bp">✝</span>, isLt := h&#39; }<span class="bp">.</span>val <span class="bp">&lt;</span> List.length (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>)</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>List.get (List.append (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) [α]) { val := Nat.succ n<span class="bp">✝</span>, isLt := h&#39; }</span></span></span><br></div><label class="goal-separator" for="Formal-lean-chkc4"><hr><span class="goal-name">cons.mk.succ</span></label><div class="goal-conclusion">bot (HList.set (extendBot a (fst<span class="bp">✝</span>, snd<span class="bp">✝</span>)) { val := Nat.succ n<span class="bp">✝</span>, isLt := h&#39; } b) <span class="bp">=</span>
  cast (_ : List.get (head<span class="bp">✝</span> :: tail<span class="bp">✝</span> <span class="bp">++</span> [α]) { val := Nat.succ n<span class="bp">✝</span>, isLt := h&#39; } <span class="bp">=</span> α) b</div></blockquote></div></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
    </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chkc5" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chkc5"><span class="alectryon-token"><span class="bp">·</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br><span><var>head✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>tail✝</var><span class="hyp-type"><b>: </b><span>List (<span class="kt">Type</span> u_1)</span></span></span><br><span><var>ih</var><span class="hyp-type"><b>: </b><span><span class="bp">∀</span> {i : Fin (List.length (List.append tail<span class="bp">✝</span> [α]))} (σ : Assg tail<span class="bp">✝</span>),
  <span class="bp">¬</span>i.val <span class="bp">&lt;</span> List.length tail<span class="bp">✝</span> <span class="bp">→</span>
    <span class="bp">∀</span> {b : List.get (List.append tail<span class="bp">✝</span> [α]) i},
      bot (HList.set (extendBot a σ) i b) <span class="bp">=</span> cast (_ : List.get (tail<span class="bp">✝</span> <span class="bp">++</span> [α]) i <span class="bp">=</span> α) b</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>Fin (List.length (List.append (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) [α]))</span></span></span><br><span><var>fst✝</var><span class="hyp-type"><b>: </b><span>head<span class="bp">✝</span></span></span></span><br><span><var>snd✝</var><span class="hyp-type"><b>: </b><span>HList tail<span class="bp">✝</span></span></span></span><br><span><var>h'</var><span class="hyp-type"><b>: </b><span>Nat.zero <span class="bp">&lt;</span> List.length (List.append (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) [α])</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span><span class="bp">¬</span>{ val := Nat.zero, isLt := h&#39; }<span class="bp">.</span>val <span class="bp">&lt;</span> List.length (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>)</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>List.get (List.append (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) [α]) { val := Nat.zero, isLt := h&#39; }</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">cons.mk.zero</span></span><div class="goal-conclusion">bot (HList.set (extendBot a (fst<span class="bp">✝</span>, snd<span class="bp">✝</span>)) { val := Nat.zero, isLt := h&#39; } b) <span class="bp">=</span>
  cast (_ : List.get (head<span class="bp">✝</span> :: tail<span class="bp">✝</span> <span class="bp">++</span> [α]) { val := Nat.zero, isLt := h&#39; } <span class="bp">=</span> α) b</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chkc6" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chkc6"><span class="alectryon-token"><span class="k">apply</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>False.elim</var><b>: </b><span>∀ {C : Prop}, False → C</span></span></div></blockquote></div></small></div>False.elim</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>h</var><b>: </b><span>¬{ val := Nat.zero, isLt := h' }.val &lt; List.length (head✝ :: tail✝)</span></span></div></blockquote></div></small></div><span class="nv">h</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat.zero_lt_succ</var><b>: </b><span>∀ (n : Nat), 0 &lt; Nat.succ n</span></span></div></blockquote></div></small></div>Nat.zero_lt_succ</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>_</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div>_</span><span class="alectryon-token">))</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
    </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chkc7" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chkc7"><span class="alectryon-token"><span class="bp">·</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br><span><var>head✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>tail✝</var><span class="hyp-type"><b>: </b><span>List (<span class="kt">Type</span> u_1)</span></span></span><br><span><var>ih</var><span class="hyp-type"><b>: </b><span><span class="bp">∀</span> {i : Fin (List.length (List.append tail<span class="bp">✝</span> [α]))} (σ : Assg tail<span class="bp">✝</span>),
  <span class="bp">¬</span>i.val <span class="bp">&lt;</span> List.length tail<span class="bp">✝</span> <span class="bp">→</span>
    <span class="bp">∀</span> {b : List.get (List.append tail<span class="bp">✝</span> [α]) i},
      bot (HList.set (extendBot a σ) i b) <span class="bp">=</span> cast (_ : List.get (tail<span class="bp">✝</span> <span class="bp">++</span> [α]) i <span class="bp">=</span> α) b</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>Fin (List.length (List.append (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) [α]))</span></span></span><br><span><var>fst✝</var><span class="hyp-type"><b>: </b><span>head<span class="bp">✝</span></span></span></span><br><span><var>snd✝</var><span class="hyp-type"><b>: </b><span>HList tail<span class="bp">✝</span></span></span></span><br><span><var>n✝</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>h'</var><span class="hyp-type"><b>: </b><span>Nat.succ n<span class="bp">✝</span> <span class="bp">&lt;</span> List.length (List.append (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) [α])</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span><span class="bp">¬</span>{ val := Nat.succ n<span class="bp">✝</span>, isLt := h&#39; }<span class="bp">.</span>val <span class="bp">&lt;</span> List.length (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>)</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>List.get (List.append (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) [α]) { val := Nat.succ n<span class="bp">✝</span>, isLt := h&#39; }</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">cons.mk.succ</span></span><div class="goal-conclusion">bot (HList.set (extendBot a (fst<span class="bp">✝</span>, snd<span class="bp">✝</span>)) { val := Nat.succ n<span class="bp">✝</span>, isLt := h&#39; } b) <span class="bp">=</span>
  cast (_ : List.get (head<span class="bp">✝</span> :: tail<span class="bp">✝</span> <span class="bp">++</span> [α]) { val := Nat.succ n<span class="bp">✝</span>, isLt := h&#39; } <span class="bp">=</span> α) b</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chkc8" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chkc8"><span class="alectryon-token"><span class="k">simp</span></span><span class="alectryon-token"> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>bot</var><b>: </b><span>{α : Type ?u.550838} → {Γ : List (Type ?u.550838)} → Assg (List.append Γ [α]) → α</span></span></div></blockquote></div></small></div>bot</span><span class="alectryon-token">]</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br><span><var>head✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>tail✝</var><span class="hyp-type"><b>: </b><span>List (<span class="kt">Type</span> u_1)</span></span></span><br><span><var>ih</var><span class="hyp-type"><b>: </b><span><span class="bp">∀</span> {i : Fin (List.length (List.append tail<span class="bp">✝</span> [α]))} (σ : Assg tail<span class="bp">✝</span>),
  <span class="bp">¬</span>i.val <span class="bp">&lt;</span> List.length tail<span class="bp">✝</span> <span class="bp">→</span>
    <span class="bp">∀</span> {b : List.get (List.append tail<span class="bp">✝</span> [α]) i},
      bot (HList.set (extendBot a σ) i b) <span class="bp">=</span> cast (_ : List.get (tail<span class="bp">✝</span> <span class="bp">++</span> [α]) i <span class="bp">=</span> α) b</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>Fin (List.length (List.append (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) [α]))</span></span></span><br><span><var>fst✝</var><span class="hyp-type"><b>: </b><span>head<span class="bp">✝</span></span></span></span><br><span><var>snd✝</var><span class="hyp-type"><b>: </b><span>HList tail<span class="bp">✝</span></span></span></span><br><span><var>n✝</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>h'</var><span class="hyp-type"><b>: </b><span>Nat.succ n<span class="bp">✝</span> <span class="bp">&lt;</span> List.length (List.append (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) [α])</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span><span class="bp">¬</span>{ val := Nat.succ n<span class="bp">✝</span>, isLt := h&#39; }<span class="bp">.</span>val <span class="bp">&lt;</span> List.length (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>)</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>List.get (List.append (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) [α]) { val := Nat.succ n<span class="bp">✝</span>, isLt := h&#39; }</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">cons.mk.succ</span></span><div class="goal-conclusion">bot (HList.set (extendBot a snd<span class="bp">✝</span>) { val := n<span class="bp">✝</span>, isLt := (_ : Nat.succ n<span class="bp">✝</span> <span class="bp">≤</span> List.length (tail<span class="bp">✝</span> <span class="bp">++</span> [α])) } b) <span class="bp">=</span>
  cast (_ : List.get (head<span class="bp">✝</span> :: tail<span class="bp">✝</span> <span class="bp">++</span> [α]) { val := Nat.succ n<span class="bp">✝</span>, isLt := h&#39; } <span class="bp">=</span> α) b</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
      </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chkc9" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chkc9"><span class="alectryon-token"><span class="k">rw</span></span><span class="alectryon-token"> [</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br><span><var>head✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>tail✝</var><span class="hyp-type"><b>: </b><span>List (<span class="kt">Type</span> u_1)</span></span></span><br><span><var>ih</var><span class="hyp-type"><b>: </b><span><span class="bp">∀</span> {i : Fin (List.length (List.append tail<span class="bp">✝</span> [α]))} (σ : Assg tail<span class="bp">✝</span>),
  <span class="bp">¬</span>i.val <span class="bp">&lt;</span> List.length tail<span class="bp">✝</span> <span class="bp">→</span>
    <span class="bp">∀</span> {b : List.get (List.append tail<span class="bp">✝</span> [α]) i},
      bot (HList.set (extendBot a σ) i b) <span class="bp">=</span> cast (_ : List.get (tail<span class="bp">✝</span> <span class="bp">++</span> [α]) i <span class="bp">=</span> α) b</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>Fin (List.length (List.append (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) [α]))</span></span></span><br><span><var>fst✝</var><span class="hyp-type"><b>: </b><span>head<span class="bp">✝</span></span></span></span><br><span><var>snd✝</var><span class="hyp-type"><b>: </b><span>HList tail<span class="bp">✝</span></span></span></span><br><span><var>n✝</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>h'</var><span class="hyp-type"><b>: </b><span>Nat.succ n<span class="bp">✝</span> <span class="bp">&lt;</span> List.length (List.append (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) [α])</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span><span class="bp">¬</span>{ val := Nat.succ n<span class="bp">✝</span>, isLt := h&#39; }<span class="bp">.</span>val <span class="bp">&lt;</span> List.length (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>)</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>List.get (List.append (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) [α]) { val := Nat.succ n<span class="bp">✝</span>, isLt := h&#39; }</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">cons.mk.succ</span></span><div class="goal-conclusion">bot (HList.set (extendBot a snd<span class="bp">✝</span>) { val := n<span class="bp">✝</span>, isLt := (_ : Nat.succ n<span class="bp">✝</span> <span class="bp">≤</span> List.length (tail<span class="bp">✝</span> <span class="bp">++</span> [α])) } b) <span class="bp">=</span>
  cast (_ : List.get (head<span class="bp">✝</span> :: tail<span class="bp">✝</span> <span class="bp">++</span> [α]) { val := Nat.succ n<span class="bp">✝</span>, isLt := h&#39; } <span class="bp">=</span> α) b</div></blockquote></div></div></small></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chkca" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chkca"><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ih</var><b>: </b><span>∀ {i : Fin (List.length (List.append tail✝ [α]))} (σ : Assg tail✝),
  ¬i.val &lt; List.length tail✝ →
    ∀ {b : List.get (List.append tail✝ [α]) i},
      bot (HList.set (extendBot a σ) i b) = cast (_ : List.get (tail✝ ++ [α]) i = α) b</span></span></div></blockquote></div></small></div><span class="nv">ih</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br><span><var>head✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>tail✝</var><span class="hyp-type"><b>: </b><span>List (<span class="kt">Type</span> u_1)</span></span></span><br><span><var>ih</var><span class="hyp-type"><b>: </b><span><span class="bp">∀</span> {i : Fin (List.length (List.append tail<span class="bp">✝</span> [α]))} (σ : Assg tail<span class="bp">✝</span>),
  <span class="bp">¬</span>i.val <span class="bp">&lt;</span> List.length tail<span class="bp">✝</span> <span class="bp">→</span>
    <span class="bp">∀</span> {b : List.get (List.append tail<span class="bp">✝</span> [α]) i},
      bot (HList.set (extendBot a σ) i b) <span class="bp">=</span> cast (_ : List.get (tail<span class="bp">✝</span> <span class="bp">++</span> [α]) i <span class="bp">=</span> α) b</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>Fin (List.length (List.append (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) [α]))</span></span></span><br><span><var>fst✝</var><span class="hyp-type"><b>: </b><span>head<span class="bp">✝</span></span></span></span><br><span><var>snd✝</var><span class="hyp-type"><b>: </b><span>HList tail<span class="bp">✝</span></span></span></span><br><span><var>n✝</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>h'</var><span class="hyp-type"><b>: </b><span>Nat.succ n<span class="bp">✝</span> <span class="bp">&lt;</span> List.length (List.append (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) [α])</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span><span class="bp">¬</span>{ val := Nat.succ n<span class="bp">✝</span>, isLt := h&#39; }<span class="bp">.</span>val <span class="bp">&lt;</span> List.length (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>)</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>List.get (List.append (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) [α]) { val := Nat.succ n<span class="bp">✝</span>, isLt := h&#39; }</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">cons.mk.succ</span></span><div class="goal-conclusion">cast (_ : List.get (tail<span class="bp">✝</span> <span class="bp">++</span> [α]) { val := n<span class="bp">✝</span>, isLt := (_ : Nat.succ n<span class="bp">✝</span> <span class="bp">≤</span> List.length (tail<span class="bp">✝</span> <span class="bp">++</span> [α])) } <span class="bp">=</span> α) b <span class="bp">=</span>
  cast (_ : List.get (head<span class="bp">✝</span> :: tail<span class="bp">✝</span> <span class="bp">++</span> [α]) { val := Nat.succ n<span class="bp">✝</span>, isLt := h&#39; } <span class="bp">=</span> α) b</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Formal-lean-chkcb" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br><span><var>head✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>tail✝</var><span class="hyp-type"><b>: </b><span>List (<span class="kt">Type</span> u_1)</span></span></span><br><span><var>ih</var><span class="hyp-type"><b>: </b><span><span class="bp">∀</span> {i : Fin (List.length (List.append tail<span class="bp">✝</span> [α]))} (σ : Assg tail<span class="bp">✝</span>),
  <span class="bp">¬</span>i.val <span class="bp">&lt;</span> List.length tail<span class="bp">✝</span> <span class="bp">→</span>
    <span class="bp">∀</span> {b : List.get (List.append tail<span class="bp">✝</span> [α]) i},
      bot (HList.set (extendBot a σ) i b) <span class="bp">=</span> cast (_ : List.get (tail<span class="bp">✝</span> <span class="bp">++</span> [α]) i <span class="bp">=</span> α) b</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>Fin (List.length (List.append (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) [α]))</span></span></span><br><span><var>fst✝</var><span class="hyp-type"><b>: </b><span>head<span class="bp">✝</span></span></span></span><br><span><var>snd✝</var><span class="hyp-type"><b>: </b><span>HList tail<span class="bp">✝</span></span></span></span><br><span><var>n✝</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>h'</var><span class="hyp-type"><b>: </b><span>Nat.succ n<span class="bp">✝</span> <span class="bp">&lt;</span> List.length (List.append (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) [α])</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span><span class="bp">¬</span>{ val := Nat.succ n<span class="bp">✝</span>, isLt := h&#39; }<span class="bp">.</span>val <span class="bp">&lt;</span> List.length (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>)</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>List.get (List.append (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) [α]) { val := Nat.succ n<span class="bp">✝</span>, isLt := h&#39; }</span></span></span><br></div><label class="goal-separator" for="Formal-lean-chkcb"><hr><span class="goal-name">cons.mk.succ.h</span></label><div class="goal-conclusion"><span class="bp">¬</span>{ val := n<span class="bp">✝</span>, isLt := (_ : Nat.succ n<span class="bp">✝</span> <span class="bp">≤</span> List.length (tail<span class="bp">✝</span> <span class="bp">++</span> [α])) }<span class="bp">.</span>val <span class="bp">&lt;</span> List.length tail<span class="bp">✝</span></div></blockquote></div></div></div></small></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chkcc" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chkcc"><span class="alectryon-token">]</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br><span><var>head✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>tail✝</var><span class="hyp-type"><b>: </b><span>List (<span class="kt">Type</span> u_1)</span></span></span><br><span><var>ih</var><span class="hyp-type"><b>: </b><span><span class="bp">∀</span> {i : Fin (List.length (List.append tail<span class="bp">✝</span> [α]))} (σ : Assg tail<span class="bp">✝</span>),
  <span class="bp">¬</span>i.val <span class="bp">&lt;</span> List.length tail<span class="bp">✝</span> <span class="bp">→</span>
    <span class="bp">∀</span> {b : List.get (List.append tail<span class="bp">✝</span> [α]) i},
      bot (HList.set (extendBot a σ) i b) <span class="bp">=</span> cast (_ : List.get (tail<span class="bp">✝</span> <span class="bp">++</span> [α]) i <span class="bp">=</span> α) b</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>Fin (List.length (List.append (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) [α]))</span></span></span><br><span><var>fst✝</var><span class="hyp-type"><b>: </b><span>head<span class="bp">✝</span></span></span></span><br><span><var>snd✝</var><span class="hyp-type"><b>: </b><span>HList tail<span class="bp">✝</span></span></span></span><br><span><var>n✝</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>h'</var><span class="hyp-type"><b>: </b><span>Nat.succ n<span class="bp">✝</span> <span class="bp">&lt;</span> List.length (List.append (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) [α])</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span><span class="bp">¬</span>{ val := Nat.succ n<span class="bp">✝</span>, isLt := h&#39; }<span class="bp">.</span>val <span class="bp">&lt;</span> List.length (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>)</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>List.get (List.append (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) [α]) { val := Nat.succ n<span class="bp">✝</span>, isLt := h&#39; }</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">cons.mk.succ.h</span></span><div class="goal-conclusion"><span class="bp">¬</span>{ val := n<span class="bp">✝</span>, isLt := (_ : Nat.succ n<span class="bp">✝</span> <span class="bp">≤</span> List.length (tail<span class="bp">✝</span> <span class="bp">++</span> [α])) }<span class="bp">.</span>val <span class="bp">&lt;</span> List.length tail<span class="bp">✝</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
      </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chkcd" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chkcd"><span class="alectryon-token"><span class="k">intro</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>h''</var><b>: </b><span>{ val := n✝, isLt := (_ : Nat.succ n✝ ≤ List.length (tail✝ ++ [α])) }.val &lt; List.length tail✝</span></span></div></blockquote></div></small></div><span class="nv">h&#39;&#39;</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br><span><var>head✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>tail✝</var><span class="hyp-type"><b>: </b><span>List (<span class="kt">Type</span> u_1)</span></span></span><br><span><var>ih</var><span class="hyp-type"><b>: </b><span><span class="bp">∀</span> {i : Fin (List.length (List.append tail<span class="bp">✝</span> [α]))} (σ : Assg tail<span class="bp">✝</span>),
  <span class="bp">¬</span>i.val <span class="bp">&lt;</span> List.length tail<span class="bp">✝</span> <span class="bp">→</span>
    <span class="bp">∀</span> {b : List.get (List.append tail<span class="bp">✝</span> [α]) i},
      bot (HList.set (extendBot a σ) i b) <span class="bp">=</span> cast (_ : List.get (tail<span class="bp">✝</span> <span class="bp">++</span> [α]) i <span class="bp">=</span> α) b</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>Fin (List.length (List.append (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) [α]))</span></span></span><br><span><var>fst✝</var><span class="hyp-type"><b>: </b><span>head<span class="bp">✝</span></span></span></span><br><span><var>snd✝</var><span class="hyp-type"><b>: </b><span>HList tail<span class="bp">✝</span></span></span></span><br><span><var>n✝</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>h'</var><span class="hyp-type"><b>: </b><span>Nat.succ n<span class="bp">✝</span> <span class="bp">&lt;</span> List.length (List.append (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) [α])</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span><span class="bp">¬</span>{ val := Nat.succ n<span class="bp">✝</span>, isLt := h&#39; }<span class="bp">.</span>val <span class="bp">&lt;</span> List.length (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>)</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>List.get (List.append (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) [α]) { val := Nat.succ n<span class="bp">✝</span>, isLt := h&#39; }</span></span></span><br><span><var>h''</var><span class="hyp-type"><b>: </b><span>{ val := n<span class="bp">✝</span>, isLt := (_ : Nat.succ n<span class="bp">✝</span> <span class="bp">≤</span> List.length (tail<span class="bp">✝</span> <span class="bp">++</span> [α])) }<span class="bp">.</span>val <span class="bp">&lt;</span> List.length tail<span class="bp">✝</span></span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">cons.mk.succ.h</span></span><div class="goal-conclusion">False</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
      </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chkce" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chkce"><span class="alectryon-token"><span class="k">apply</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>False.elim</var><b>: </b><span>∀ {C : Prop}, False → C</span></span></div></blockquote></div></small></div>False.elim</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>h</var><b>: </b><span>¬{ val := Nat.succ n✝, isLt := h' }.val &lt; List.length (head✝ :: tail✝)</span></span></div></blockquote></div></small></div><span class="nv">h</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat.succ_lt_succ</var><b>: </b><span>∀ {n m : Nat}, n &lt; m → Nat.succ n &lt; Nat.succ m</span></span></div></blockquote></div></small></div>Nat.succ_lt_succ</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>h''</var><b>: </b><span>{ val := n✝, isLt := (_ : Nat.succ n✝ ≤ List.length (tail✝ ++ [α])) }.val &lt; List.length tail✝</span></span></div></blockquote></div></small></div><span class="nv">h&#39;&#39;</span></span><span class="alectryon-token">))</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">

</span><span class="alectryon-token"><span class="kd">theorem</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>eval_S</var><b>: </b><span>∀ {m : Type → Type} {ω : Type} {Γ Δ : List Type} {α : Type} {b c : Bool} {β : Type} {a : α} {ρ : HList Γ} {σ : Assg Δ}
  [inst : Monad m] [inst_1 : LawfulMonad m] (s : Stmt m ω Γ (List.append Δ [α]) b c β),
  StateT.run (Stmt.eval (a :: ρ) (S s) σ) a = do
    let x ← Stmt.eval ρ s (Assg.extendBot a σ)
    match x with
      | (r, σ) =&gt; pure (r :: Assg.dropBot σ, Assg.bot σ)</span></span></div></blockquote></div></small></div><span class="nv">eval_S</span></span><span class="alectryon-token"> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Monad</var><b>: </b><span>(Type ?u.552273 → Type ?u.552272) → Type (max (?u.552273 + 1) ?u.552272)</span></span></div></blockquote></div></small></div>Monad</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>Type → Type</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token">] [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>LawfulMonad</var><b>: </b><span>(m : Type → Type) → [inst : Monad m] → Prop</span></span></div></blockquote></div></small></div>LawfulMonad</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>Type → Type</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token">] : <span class="bp">∀</span> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>Stmt m ω Γ (List.append Δ [α]) b c β</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt</var><b>: </b><span>(Type → Type) → Type → List Type → List Type → Bool → Bool → Type → Type 1</span></span></div></blockquote></div></small></div>Stmt</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>Type → Type</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ω</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">ω</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Γ</var><b>: </b><span>List Type</span></span></div></blockquote></div></small></div><span class="nv">Γ</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Δ</var><b>: </b><span>List Type</span></span></div></blockquote></div></small></div><span class="nv">Δ</span></span><span class="alectryon-token"> <span class="bp">++</span> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token">]) </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>c</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div><span class="nv">c</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>β</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">β</span></span><span class="alectryon-token">), </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>StateT.run</var><b>: </b><span>{σ : Type} → {m : Type → Type} → {α : Type} → StateT σ m α → σ → m (α × σ)</span></span></div></blockquote></div></small></div>StateT.run</span><span class="alectryon-token"> ((</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>S</var><b>: </b><span>{m : Type → Type} →
  {ω : Type} →
    {Γ Δ : List Type} →
      {α : Type} →
        {b c : Bool} →
          {β : Type} → [inst : Monad m] → Stmt m ω Γ (List.append Δ [α]) b c β → Stmt (StateT α m) ω (α :: Γ) Δ b c β</span></span></div></blockquote></div></small></div>S</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>Stmt m ω Γ (List.append Δ [α]) b c β</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token">)<span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>eval</var><b>: </b><span>{m : Type → Type} →
  {Γ : List Type} →
    {ω : Type} →
      {Δ : List Type} →
        {b c : Bool} → {α : Type} → [inst : Monad m] → Assg Γ → Stmt m ω Γ Δ b c α → Assg Δ → m (Neut ω α b c × Assg Δ)</span></span></div></blockquote></div></small></div><span class="na">eval</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"> :: </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ρ</var><b>: </b><span>HList Γ</span></span></div></blockquote></div></small></div><span class="nv">ρ</span></span><span class="alectryon-token">) </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>σ</var><b>: </b><span>Assg Δ</span></span></div></blockquote></div></small></div><span class="nv">σ</span></span><span class="alectryon-token">) </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"> <span class="bp">=</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>Stmt m ω Γ (List.append Δ [α]) b c β</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>eval</var><b>: </b><span>{m : Type → Type} →
  {Γ : List Type} →
    {ω : Type} →
      {Δ : List Type} →
        {b c : Bool} → {α : Type} → [inst : Monad m] → Assg Γ → Stmt m ω Γ Δ b c α → Assg Δ → m (Neut ω α b c × Assg Δ)</span></span></div></blockquote></div></small></div>eval</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ρ</var><b>: </b><span>HList Γ</span></span></div></blockquote></div></small></div><span class="nv">ρ</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Assg.extendBot</var><b>: </b><span>{α : Type} → α → {Γ : List Type} → Assg Γ → Assg (List.append Γ [α])</span></span></div></blockquote></div></small></div>Assg.extendBot</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>σ</var><b>: </b><span>Assg Δ</span></span></div></blockquote></div></small></div><span class="nv">σ</span></span><span class="alectryon-token">) <span class="bp">&gt;&gt;=</span> </span><span class="alectryon-token"><span class="k">fun</span></span><span class="alectryon-token">
    <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>r</var><b>: </b><span>Neut ω β b c</span></span></div></blockquote></div></small></div><span class="nv">r</span></span><span class="alectryon-token"> :: </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>σ</var><b>: </b><span>HList (List.append Δ [α])</span></span></div></blockquote></div></small></div><span class="nv">σ</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>pure</var><b>: </b><span>{f : Type → Type} → [self : Pure f] → {α : Type} → α → f α</span></span></div></blockquote></div></small></div>pure</span><span class="alectryon-token"> ((</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>r</var><b>: </b><span>Neut ω β b c</span></span></div></blockquote></div></small></div><span class="nv">r</span></span><span class="alectryon-token"> :: </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Assg.dropBot</var><b>: </b><span>{α : Type} → {Γ : List Type} → Assg (List.append Γ [α]) → Assg Γ</span></span></div></blockquote></div></small></div>Assg.dropBot</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>σ</var><b>: </b><span>HList (List.append Δ [α])</span></span></div></blockquote></div></small></div><span class="nv">σ</span></span><span class="alectryon-token">), </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Assg.bot</var><b>: </b><span>{α : Type} → {Γ : List Type} → Assg (List.append Γ [α]) → α</span></span></div></blockquote></div></small></div>Assg.bot</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>σ</var><b>: </b><span>HList (List.append Δ [α])</span></span></div></blockquote></div></small></div><span class="nv">σ</span></span><span class="alectryon-token">) := </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chkcf" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chkcf"><span class="alectryon-token"><span class="kd">by</span></span><span class="alectryon-token"></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span></span></span></span><br><span><var>ω</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Γ, Δ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b, c</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br><span><var>ρ</var><span class="hyp-type"><b>: </b><span>HList <span class="bp">Γ</span></span></span></span><br><span><var>σ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Δ</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="bp">∀</span> (s : Stmt m ω <span class="bp">Γ</span> (List.append <span class="bp">Δ</span> [α]) b c β),
  StateT.run (Stmt.eval (a :: ρ) (S s) σ) a <span class="bp">=</span> <span class="k">do</span>
    <span class="k">let</span> x <span class="bp">←</span> Stmt.eval ρ s (Assg.extendBot a σ)
    <span class="k">match</span> x <span class="k">with</span>
      <span class="bp">|</span> (r, σ) <span class="bp">=&gt;</span> pure (r :: Assg.dropBot σ, Assg.bot σ)</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chkd0" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chkd0"><span class="alectryon-token"><span class="k">suffices</span></span><span class="alectryon-token"> {</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Δ'</var><b>: </b><span>List Type</span></span></div></blockquote></div></small></div><span class="nv">Δ&#39;</span></span><span class="alectryon-token">: </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>_</var><b>: </b><span>Type 1</span></span></div></blockquote></div></small></div>_</span><span class="alectryon-token"> } <span class="bp">→</span> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>Stmt m ω Γ Δ' b c β</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt</var><b>: </b><span>(Type → Type) → Type → List Type → List Type → Bool → Bool → Type → Type 1</span></span></div></blockquote></div></small></div>Stmt</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>Type → Type</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ω</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">ω</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Γ</var><b>: </b><span>List Type</span></span></div></blockquote></div></small></div><span class="nv">Γ</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Δ'</var><b>: </b><span>List Type</span></span></div></blockquote></div></small></div><span class="nv">Δ&#39;</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>c</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div><span class="nv">c</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>β</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">β</span></span><span class="alectryon-token">) <span class="bp">→</span> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>h</var><b>: </b><span>Δ' = List.append Δ [α]</span></span></div></blockquote></div></small></div><span class="nv">h</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Δ'</var><b>: </b><span>List Type</span></span></div></blockquote></div></small></div><span class="nv">Δ&#39;</span></span><span class="alectryon-token"> <span class="bp">=</span> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Δ</var><b>: </b><span>List Type</span></span></div></blockquote></div></small></div><span class="nv">Δ</span></span><span class="alectryon-token"> <span class="bp">++</span> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token">])) <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>StateT.run</var><b>: </b><span>{σ : Type} → {m : Type → Type} → {α : Type} → StateT σ m α → σ → m (α × σ)</span></span></div></blockquote></div></small></div>StateT.run</span><span class="alectryon-token"> ((</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>S</var><b>: </b><span>{m : Type → Type} →
  {ω : Type} →
    {Γ Δ : List Type} →
      {α : Type} →
        {b c : Bool} →
          {β : Type} → [inst : Monad m] → Stmt m ω Γ (List.append Δ [α]) b c β → Stmt (StateT α m) ω (α :: Γ) Δ b c β</span></span></div></blockquote></div></small></div>S</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>h</var><b>: </b><span>Δ' = List.append Δ [α]</span></span></div></blockquote></div></small></div><span class="nv">h</span></span><span class="alectryon-token"> <span class="bp">▸</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>Stmt m ω Γ Δ' b c β</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token">))<span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>eval</var><b>: </b><span>{m : Type → Type} →
  {Γ : List Type} →
    {ω : Type} →
      {Δ : List Type} →
        {b c : Bool} → {α : Type} → [inst : Monad m] → Assg Γ → Stmt m ω Γ Δ b c α → Assg Δ → m (Neut ω α b c × Assg Δ)</span></span></div></blockquote></div></small></div><span class="na">eval</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"> :: </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ρ</var><b>: </b><span>HList Γ</span></span></div></blockquote></div></small></div><span class="nv">ρ</span></span><span class="alectryon-token">) </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>σ</var><b>: </b><span>Assg Δ</span></span></div></blockquote></div></small></div><span class="nv">σ</span></span><span class="alectryon-token">) </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"> <span class="bp">=</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>Stmt m ω Γ Δ' b c β</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>eval</var><b>: </b><span>{m : Type → Type} →
  {Γ : List Type} →
    {ω : Type} →
      {Δ : List Type} →
        {b c : Bool} → {α : Type} → [inst : Monad m] → Assg Γ → Stmt m ω Γ Δ b c α → Assg Δ → m (Neut ω α b c × Assg Δ)</span></span></div></blockquote></div></small></div>eval</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ρ</var><b>: </b><span>HList Γ</span></span></div></blockquote></div></small></div><span class="nv">ρ</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>h</var><b>: </b><span>Δ' = List.append Δ [α]</span></span></div></blockquote></div></small></div><span class="nv">h</span></span><span class="alectryon-token"> <span class="bp">▸</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Assg.extendBot</var><b>: </b><span>{α : Type} → α → {Γ : List Type} → Assg Γ → Assg (List.append Γ [α])</span></span></div></blockquote></div></small></div>Assg.extendBot</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>σ</var><b>: </b><span>Assg Δ</span></span></div></blockquote></div></small></div><span class="nv">σ</span></span><span class="alectryon-token">) <span class="bp">&gt;&gt;=</span> </span><span class="alectryon-token"><span class="k">fun</span></span><span class="alectryon-token">
    <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>r</var><b>: </b><span>Neut ω β b c</span></span></div></blockquote></div></small></div><span class="nv">r</span></span><span class="alectryon-token"> :: </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>σ</var><b>: </b><span>HList Δ'</span></span></div></blockquote></div></small></div><span class="nv">σ</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>pure</var><b>: </b><span>{f : Type → Type} → [self : Pure f] → {α : Type} → α → f α</span></span></div></blockquote></div></small></div>pure</span><span class="alectryon-token"> ((</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>r</var><b>: </b><span>Neut ω β b c</span></span></div></blockquote></div></small></div><span class="nv">r</span></span><span class="alectryon-token"> :: </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Assg.dropBot</var><b>: </b><span>{α : Type} → {Γ : List Type} → Assg (List.append Γ [α]) → Assg Γ</span></span></div></blockquote></div></small></div>Assg.dropBot</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>h</var><b>: </b><span>Δ' = List.append Δ [α]</span></span></div></blockquote></div></small></div><span class="nv">h</span></span><span class="alectryon-token"> <span class="bp">▸</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>σ</var><b>: </b><span>HList Δ'</span></span></div></blockquote></div></small></div><span class="nv">σ</span></span><span class="alectryon-token">)), </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Assg.bot</var><b>: </b><span>{α : Type} → {Γ : List Type} → Assg (List.append Γ [α]) → α</span></span></div></blockquote></div></small></div>Assg.bot</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>h</var><b>: </b><span>Δ' = List.append Δ [α]</span></span></div></blockquote></div></small></div><span class="nv">h</span></span><span class="alectryon-token"> <span class="bp">▸</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>σ</var><b>: </b><span>HList Δ'</span></span></div></blockquote></div></small></div><span class="nv">σ</span></span><span class="alectryon-token">))
    </span><span class="alectryon-token"><span class="k">from</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">fun</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>Stmt m ω Γ (List.append Δ [α]) b c β</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>this</var><b>: </b><span>∀ {Δ' : List Type} (s : Stmt m ω Γ Δ' b c β) (h : Δ' = List.append Δ [α]),
  StateT.run (Stmt.eval (a :: ρ) (S (h ▸ s)) σ) a = do
    let x ← Stmt.eval ρ s ((_ : List.append Δ [α] = Δ') ▸ Assg.extendBot a σ)
    match x with
      | (r, σ) =&gt; pure (r :: Assg.dropBot (h ▸ σ), Assg.bot (h ▸ σ))</span></span></div></blockquote></div></small></div><span class="k">this</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>Stmt m ω Γ (List.append Δ [α]) b c β</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>rfl</var><b>: </b><span>∀ {α : Type 1} {a : α}, a = a</span></span></div></blockquote></div></small></div>rfl</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span></span></span></span><br><span><var>ω</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Γ, Δ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b, c</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br><span><var>ρ</var><span class="hyp-type"><b>: </b><span>HList <span class="bp">Γ</span></span></span></span><br><span><var>σ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Δ</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="bp">∀</span> {<span class="bp">Δ&#39;</span> : List <span class="kt">Type</span>} (s : Stmt m ω <span class="bp">Γ</span> <span class="bp">Δ&#39;</span> b c β) (h : <span class="bp">Δ&#39;</span> <span class="bp">=</span> List.append <span class="bp">Δ</span> [α]),
  StateT.run (Stmt.eval (a :: ρ) (S (h <span class="bp">▸</span> s)) σ) a <span class="bp">=</span> <span class="k">do</span>
    <span class="k">let</span> x <span class="bp">←</span> Stmt.eval ρ s ((_ : List.append <span class="bp">Δ</span> [α] <span class="bp">=</span> <span class="bp">Δ&#39;</span>) <span class="bp">▸</span> Assg.extendBot a σ)
    <span class="k">match</span> x <span class="k">with</span>
      <span class="bp">|</span> (r, σ) <span class="bp">=&gt;</span> pure (r :: Assg.dropBot (h <span class="bp">▸</span> σ), Assg.bot (h <span class="bp">▸</span> σ))</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chkd1" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chkd1"><span class="alectryon-token"><span class="k">intro</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Δ'</var><b>: </b><span>List Type</span></span></div></blockquote></div></small></div><span class="nv">Δ&#39;</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>Stmt m ω Γ Δ' b c β</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>h</var><b>: </b><span>Δ' = List.append Δ [α]</span></span></div></blockquote></div></small></div><span class="nv">h</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span></span></span></span><br><span><var>ω</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Γ, Δ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b, c</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br><span><var>ρ</var><span class="hyp-type"><b>: </b><span>HList <span class="bp">Γ</span></span></span></span><br><span><var>σ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Δ</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>Δ'</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>Stmt m ω <span class="bp">Γ</span> <span class="bp">Δ&#39;</span> b c β</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span><span class="bp">Δ&#39;</span> <span class="bp">=</span> List.append <span class="bp">Δ</span> [α]</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">StateT.run (Stmt.eval (a :: ρ) (S (h <span class="bp">▸</span> s)) σ) a <span class="bp">=</span> <span class="k">do</span>
  <span class="k">let</span> x <span class="bp">←</span> Stmt.eval ρ s ((_ : List.append <span class="bp">Δ</span> [α] <span class="bp">=</span> <span class="bp">Δ&#39;</span>) <span class="bp">▸</span> Assg.extendBot a σ)
  <span class="k">match</span> x <span class="k">with</span>
    <span class="bp">|</span> (r, σ) <span class="bp">=&gt;</span> pure (r :: Assg.dropBot (h <span class="bp">▸</span> σ), Assg.bot (h <span class="bp">▸</span> σ))</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chkd2" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chkd2"><span class="alectryon-token"><span class="k">induction</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>Stmt m ω Γ Δ' b c β</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">generalizing</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Δ</var><b>: </b><span>List Type</span></span></div></blockquote></div></small></div><span class="nv">Δ</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">with</span></span><span class="alectryon-token"></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span></span></span></span><br><span><var>ω</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Γ, Δ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b, c</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br><span><var>ρ</var><span class="hyp-type"><b>: </b><span>HList <span class="bp">Γ</span></span></span></span><br><span><var>σ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Δ</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>Δ'</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>Stmt m ω <span class="bp">Γ</span> <span class="bp">Δ&#39;</span> b c β</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span><span class="bp">Δ&#39;</span> <span class="bp">=</span> List.append <span class="bp">Δ</span> [α]</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">StateT.run (Stmt.eval (a :: ρ) (S (h <span class="bp">▸</span> s)) σ) a <span class="bp">=</span> <span class="k">do</span>
  <span class="k">let</span> x <span class="bp">←</span> Stmt.eval ρ s ((_ : List.append <span class="bp">Δ</span> [α] <span class="bp">=</span> <span class="bp">Δ&#39;</span>) <span class="bp">▸</span> Assg.extendBot a σ)
  <span class="k">match</span> x <span class="k">with</span>
    <span class="bp">|</span> (r, σ) <span class="bp">=&gt;</span> pure (r :: Assg.dropBot (h <span class="bp">▸</span> σ), Assg.bot (h <span class="bp">▸</span> σ))</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
    </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chkd3" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chkd3"><span class="alectryon-token"><span class="k">subst</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>h</var><b>: </b><span>Δ✝ = List.append Δ [α]</span></span></div></blockquote></div></small></div><span class="nv">h</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span></span></span></span><br><span><var>ω</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b, c</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>Δ', Γ✝</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>b✝, c✝</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>α✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br><span><var>ρ</var><span class="hyp-type"><b>: </b><span>HList <span class="bp">Γ✝</span></span></span></span><br><span><var>σ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Δ</span></span></span></span><br><span><var>e✝</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ✝</span> <span class="bp">→</span> Assg (List.append <span class="bp">Δ</span> [α]) <span class="bp">→</span> Bool</span></span></span><br><span><var>s₁✝, s₂✝</var><span class="hyp-type"><b>: </b><span>Stmt m ω <span class="bp">Γ✝</span> (List.append <span class="bp">Δ</span> [α]) b<span class="bp">✝</span> c<span class="bp">✝</span> α<span class="bp">✝</span></span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">ite</span></span><div class="goal-conclusion">StateT.run (Stmt.eval (a :: ρ) (S ((_ : List.append <span class="bp">Δ</span> [α] <span class="bp">=</span> List.append <span class="bp">Δ</span> [α]) <span class="bp">▸</span> Stmt.ite e<span class="bp">✝</span> s₁<span class="bp">✝</span> s₂<span class="bp">✝</span>)) σ) a <span class="bp">=</span> <span class="k">do</span>
  <span class="k">let</span> x <span class="bp">←</span> Stmt.eval ρ (Stmt.ite e<span class="bp">✝</span> s₁<span class="bp">✝</span> s₂<span class="bp">✝</span>) ((_ : List.append <span class="bp">Δ</span> [α] <span class="bp">=</span> List.append <span class="bp">Δ</span> [α]) <span class="bp">▸</span> Assg.extendBot a σ)
  <span class="k">match</span> x <span class="k">with</span>
    <span class="bp">|</span> (r, σ) <span class="bp">=&gt;</span>
      pure
        (r :: Assg.dropBot ((_ : List.append <span class="bp">Δ</span> [α] <span class="bp">=</span> List.append <span class="bp">Δ</span> [α]) <span class="bp">▸</span> σ),
          Assg.bot ((_ : List.append <span class="bp">Δ</span> [α] <span class="bp">=</span> List.append <span class="bp">Δ</span> [α]) <span class="bp">▸</span> σ))</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chkd4" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chkd4"><span class="alectryon-token"><span class="bp">|</span> bind </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s₁</var><b>: </b><span>Stmt m ω Γ✝ Δ✝ b✝ c✝ α✝</span></span></div></blockquote></div></small></div><span class="nv">s₁</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s₂</var><b>: </b><span>Stmt m ω (α✝ :: Γ✝) Δ✝ b✝ c✝ β✝</span></span></div></blockquote></div></small></div><span class="nv">s₂</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ih₁</var><b>: </b><span>∀ {Δ : List Type} {a : α} {ρ : HList Γ✝} {σ : Assg Δ} (h : Δ✝ = List.append Δ [α]),
  StateT.run (Stmt.eval (a :: ρ) (S (h ▸ s₁)) σ) a = do
    let x ← Stmt.eval ρ s₁ ((_ : List.append Δ [α] = Δ✝) ▸ Assg.extendBot a σ)
    match x with
      | (r, σ) =&gt; pure (r :: Assg.dropBot (h ▸ σ), Assg.bot (h ▸ σ))</span></span></div></blockquote></div></small></div><span class="nv">ih₁</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ih₂</var><b>: </b><span>∀ {Δ : List Type} {a : α} {ρ : HList (α✝ :: Γ✝)} {σ : Assg Δ} (h : Δ✝ = List.append Δ [α]),
  StateT.run (Stmt.eval (a :: ρ) (S (h ▸ s₂)) σ) a = do
    let x ← Stmt.eval ρ s₂ ((_ : List.append Δ [α] = Δ✝) ▸ Assg.extendBot a σ)
    match x with
      | (r, σ) =&gt; pure (r :: Assg.dropBot (h ▸ σ), Assg.bot (h ▸ σ))</span></span></div></blockquote></div></small></div><span class="nv">ih₂</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span></span></span></span><br><span><var>ω</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b, c</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>Δ', Γ✝</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>b✝, c✝</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>α✝, β✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br><span><var>ρ</var><span class="hyp-type"><b>: </b><span>HList <span class="bp">Γ✝</span></span></span></span><br><span><var>σ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Δ</span></span></span></span><br><span><var>s₁</var><span class="hyp-type"><b>: </b><span>Stmt m ω <span class="bp">Γ✝</span> (List.append <span class="bp">Δ</span> [α]) b<span class="bp">✝</span> c<span class="bp">✝</span> α<span class="bp">✝</span></span></span></span><br><span><var>s₂</var><span class="hyp-type"><b>: </b><span>Stmt m ω (α<span class="bp">✝</span> :: <span class="bp">Γ✝</span>) (List.append <span class="bp">Δ</span> [α]) b<span class="bp">✝</span> c<span class="bp">✝</span> β<span class="bp">✝</span></span></span></span><br><span><var>ih₁</var><span class="hyp-type"><b>: </b><span><span class="bp">∀</span> {<span class="bp">Δ</span>_1 : List <span class="kt">Type</span>} {a : α} {ρ : HList <span class="bp">Γ✝</span>} {σ : Assg <span class="bp">Δ</span>_1} (h : List.append <span class="bp">Δ</span> [α] <span class="bp">=</span> List.append <span class="bp">Δ</span>_1 [α]),
  StateT.run (Stmt.eval (a :: ρ) (S (h <span class="bp">▸</span> s₁)) σ) a <span class="bp">=</span> <span class="k">do</span>
    <span class="k">let</span> x <span class="bp">←</span> Stmt.eval ρ s₁ ((_ : List.append <span class="bp">Δ</span>_1 [α] <span class="bp">=</span> List.append <span class="bp">Δ</span> [α]) <span class="bp">▸</span> Assg.extendBot a σ)
    <span class="k">match</span> x <span class="k">with</span>
      <span class="bp">|</span> (r, σ) <span class="bp">=&gt;</span> pure (r :: Assg.dropBot (h <span class="bp">▸</span> σ), Assg.bot (h <span class="bp">▸</span> σ))</span></span></span><br><span><var>ih₂</var><span class="hyp-type"><b>: </b><span><span class="bp">∀</span> {<span class="bp">Δ</span>_1 : List <span class="kt">Type</span>} {a : α} {ρ : HList (α<span class="bp">✝</span> :: <span class="bp">Γ✝</span>)} {σ : Assg <span class="bp">Δ</span>_1} (h : List.append <span class="bp">Δ</span> [α] <span class="bp">=</span> List.append <span class="bp">Δ</span>_1 [α]),
  StateT.run (Stmt.eval (a :: ρ) (S (h <span class="bp">▸</span> s₂)) σ) a <span class="bp">=</span> <span class="k">do</span>
    <span class="k">let</span> x <span class="bp">←</span> Stmt.eval ρ s₂ ((_ : List.append <span class="bp">Δ</span>_1 [α] <span class="bp">=</span> List.append <span class="bp">Δ</span> [α]) <span class="bp">▸</span> Assg.extendBot a σ)
    <span class="k">match</span> x <span class="k">with</span>
      <span class="bp">|</span> (r, σ) <span class="bp">=&gt;</span> pure (r :: Assg.dropBot (h <span class="bp">▸</span> σ), Assg.bot (h <span class="bp">▸</span> σ))</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">bind</span></span><div class="goal-conclusion">StateT.run (Stmt.eval (a :: ρ) (S ((_ : List.append <span class="bp">Δ</span> [α] <span class="bp">=</span> List.append <span class="bp">Δ</span> [α]) <span class="bp">▸</span> Stmt.bind s₁ s₂)) σ) a <span class="bp">=</span> <span class="k">do</span>
  <span class="k">let</span> x <span class="bp">←</span> Stmt.eval ρ (Stmt.bind s₁ s₂) ((_ : List.append <span class="bp">Δ</span> [α] <span class="bp">=</span> List.append <span class="bp">Δ</span> [α]) <span class="bp">▸</span> Assg.extendBot a σ)
  <span class="k">match</span> x <span class="k">with</span>
    <span class="bp">|</span> (r, σ) <span class="bp">=&gt;</span>
      pure
        (r :: Assg.dropBot ((_ : List.append <span class="bp">Δ</span> [α] <span class="bp">=</span> List.append <span class="bp">Δ</span> [α]) <span class="bp">▸</span> σ),
          Assg.bot ((_ : List.append <span class="bp">Δ</span> [α] <span class="bp">=</span> List.append <span class="bp">Δ</span> [α]) <span class="bp">▸</span> σ))</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
    </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chkd5" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chkd5"><span class="alectryon-token"><span class="k">have</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ih₁</var><b>: </b><span>∀ (a : α) (ρ : HList Γ✝) (σ : Assg Δ),
  StateT.run (Stmt.eval (a :: ρ) (S ((_ : List.append Δ [α] = List.append Δ [α]) ▸ s₁)) σ) a = do
    let x ← Stmt.eval ρ s₁ ((_ : List.append Δ [α] = List.append Δ [α]) ▸ Assg.extendBot a σ)
    match x with
      | (r, σ) =&gt;
        pure
          (r :: Assg.dropBot ((_ : List.append Δ [α] = List.append Δ [α]) ▸ σ),
            Assg.bot ((_ : List.append Δ [α] = List.append Δ [α]) ▸ σ))</span></span></div></blockquote></div></small></div><span class="nv">ih₁</span></span><span class="alectryon-token"> := <span class="bp">@</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ih₁</var><b>: </b><span>∀ {Δ_1 : List Type} {a : α} {ρ : HList Γ✝} {σ : Assg Δ_1} (h : List.append Δ [α] = List.append Δ_1 [α]),
  StateT.run (Stmt.eval (a :: ρ) (S (h ▸ s₁)) σ) a = do
    let x ← Stmt.eval ρ s₁ ((_ : List.append Δ_1 [α] = List.append Δ [α]) ▸ Assg.extendBot a σ)
    match x with
      | (r, σ) =&gt; pure (r :: Assg.dropBot (h ▸ σ), Assg.bot (h ▸ σ))</span></span></div></blockquote></div></small></div><span class="nv">ih₁</span></span><span class="alectryon-token"> (h := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>rfl</var><b>: </b><span>∀ {α : Type 1} {a : α}, a = a</span></span></div></blockquote></div></small></div>rfl</span><span class="alectryon-token">)</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span></span></span></span><br><span><var>ω</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b, c</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>Δ', Γ✝</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>b✝, c✝</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>α✝, β✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br><span><var>ρ</var><span class="hyp-type"><b>: </b><span>HList <span class="bp">Γ✝</span></span></span></span><br><span><var>σ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Δ</span></span></span></span><br><span><var>s₁</var><span class="hyp-type"><b>: </b><span>Stmt m ω <span class="bp">Γ✝</span> (List.append <span class="bp">Δ</span> [α]) b<span class="bp">✝</span> c<span class="bp">✝</span> α<span class="bp">✝</span></span></span></span><br><span><var>s₂</var><span class="hyp-type"><b>: </b><span>Stmt m ω (α<span class="bp">✝</span> :: <span class="bp">Γ✝</span>) (List.append <span class="bp">Δ</span> [α]) b<span class="bp">✝</span> c<span class="bp">✝</span> β<span class="bp">✝</span></span></span></span><br><span><var>ih₂</var><span class="hyp-type"><b>: </b><span><span class="bp">∀</span> {<span class="bp">Δ</span>_1 : List <span class="kt">Type</span>} {a : α} {ρ : HList (α<span class="bp">✝</span> :: <span class="bp">Γ✝</span>)} {σ : Assg <span class="bp">Δ</span>_1} (h : List.append <span class="bp">Δ</span> [α] <span class="bp">=</span> List.append <span class="bp">Δ</span>_1 [α]),
  StateT.run (Stmt.eval (a :: ρ) (S (h <span class="bp">▸</span> s₂)) σ) a <span class="bp">=</span> <span class="k">do</span>
    <span class="k">let</span> x <span class="bp">←</span> Stmt.eval ρ s₂ ((_ : List.append <span class="bp">Δ</span>_1 [α] <span class="bp">=</span> List.append <span class="bp">Δ</span> [α]) <span class="bp">▸</span> Assg.extendBot a σ)
    <span class="k">match</span> x <span class="k">with</span>
      <span class="bp">|</span> (r, σ) <span class="bp">=&gt;</span> pure (r :: Assg.dropBot (h <span class="bp">▸</span> σ), Assg.bot (h <span class="bp">▸</span> σ))</span></span></span><br><span><var>ih₁</var><span class="hyp-type"><b>: </b><span><span class="bp">∀</span> (a : α) (ρ : HList <span class="bp">Γ✝</span>) (σ : Assg <span class="bp">Δ</span>),
  StateT.run (Stmt.eval (a :: ρ) (S ((_ : List.append <span class="bp">Δ</span> [α] <span class="bp">=</span> List.append <span class="bp">Δ</span> [α]) <span class="bp">▸</span> s₁)) σ) a <span class="bp">=</span> <span class="k">do</span>
    <span class="k">let</span> x <span class="bp">←</span> Stmt.eval ρ s₁ ((_ : List.append <span class="bp">Δ</span> [α] <span class="bp">=</span> List.append <span class="bp">Δ</span> [α]) <span class="bp">▸</span> Assg.extendBot a σ)
    <span class="k">match</span> x <span class="k">with</span>
      <span class="bp">|</span> (r, σ) <span class="bp">=&gt;</span>
        pure
          (r :: Assg.dropBot ((_ : List.append <span class="bp">Δ</span> [α] <span class="bp">=</span> List.append <span class="bp">Δ</span> [α]) <span class="bp">▸</span> σ),
            Assg.bot ((_ : List.append <span class="bp">Δ</span> [α] <span class="bp">=</span> List.append <span class="bp">Δ</span> [α]) <span class="bp">▸</span> σ))</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">bind</span></span><div class="goal-conclusion">StateT.run (Stmt.eval (a :: ρ) (S ((_ : List.append <span class="bp">Δ</span> [α] <span class="bp">=</span> List.append <span class="bp">Δ</span> [α]) <span class="bp">▸</span> Stmt.bind s₁ s₂)) σ) a <span class="bp">=</span> <span class="k">do</span>
  <span class="k">let</span> x <span class="bp">←</span> Stmt.eval ρ (Stmt.bind s₁ s₂) ((_ : List.append <span class="bp">Δ</span> [α] <span class="bp">=</span> List.append <span class="bp">Δ</span> [α]) <span class="bp">▸</span> Assg.extendBot a σ)
  <span class="k">match</span> x <span class="k">with</span>
    <span class="bp">|</span> (r, σ) <span class="bp">=&gt;</span>
      pure
        (r :: Assg.dropBot ((_ : List.append <span class="bp">Δ</span> [α] <span class="bp">=</span> List.append <span class="bp">Δ</span> [α]) <span class="bp">▸</span> σ),
          Assg.bot ((_ : List.append <span class="bp">Δ</span> [α] <span class="bp">=</span> List.append <span class="bp">Δ</span> [α]) <span class="bp">▸</span> σ))</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
    </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chkd6" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chkd6"><span class="alectryon-token"><span class="k">have</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ih₂</var><b>: </b><span>∀ (a : α) (ρ : HList (α✝ :: Γ✝)) (σ : Assg Δ),
  StateT.run (Stmt.eval (a :: ρ) (S ((_ : List.append Δ [α] = List.append Δ [α]) ▸ s₂)) σ) a = do
    let x ← Stmt.eval ρ s₂ ((_ : List.append Δ [α] = List.append Δ [α]) ▸ Assg.extendBot a σ)
    match x with
      | (r, σ) =&gt;
        pure
          (r :: Assg.dropBot ((_ : List.append Δ [α] = List.append Δ [α]) ▸ σ),
            Assg.bot ((_ : List.append Δ [α] = List.append Δ [α]) ▸ σ))</span></span></div></blockquote></div></small></div><span class="nv">ih₂</span></span><span class="alectryon-token"> := <span class="bp">@</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ih₂</var><b>: </b><span>∀ {Δ_1 : List Type} {a : α} {ρ : HList (α✝ :: Γ✝)} {σ : Assg Δ_1} (h : List.append Δ [α] = List.append Δ_1 [α]),
  StateT.run (Stmt.eval (a :: ρ) (S (h ▸ s₂)) σ) a = do
    let x ← Stmt.eval ρ s₂ ((_ : List.append Δ_1 [α] = List.append Δ [α]) ▸ Assg.extendBot a σ)
    match x with
      | (r, σ) =&gt; pure (r :: Assg.dropBot (h ▸ σ), Assg.bot (h ▸ σ))</span></span></div></blockquote></div></small></div><span class="nv">ih₂</span></span><span class="alectryon-token"> (h := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>rfl</var><b>: </b><span>∀ {α : Type 1} {a : α}, a = a</span></span></div></blockquote></div></small></div>rfl</span><span class="alectryon-token">)</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span></span></span></span><br><span><var>ω</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b, c</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>Δ', Γ✝</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>b✝, c✝</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>α✝, β✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br><span><var>ρ</var><span class="hyp-type"><b>: </b><span>HList <span class="bp">Γ✝</span></span></span></span><br><span><var>σ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Δ</span></span></span></span><br><span><var>s₁</var><span class="hyp-type"><b>: </b><span>Stmt m ω <span class="bp">Γ✝</span> (List.append <span class="bp">Δ</span> [α]) b<span class="bp">✝</span> c<span class="bp">✝</span> α<span class="bp">✝</span></span></span></span><br><span><var>s₂</var><span class="hyp-type"><b>: </b><span>Stmt m ω (α<span class="bp">✝</span> :: <span class="bp">Γ✝</span>) (List.append <span class="bp">Δ</span> [α]) b<span class="bp">✝</span> c<span class="bp">✝</span> β<span class="bp">✝</span></span></span></span><br><span><var>ih₁</var><span class="hyp-type"><b>: </b><span><span class="bp">∀</span> (a : α) (ρ : HList <span class="bp">Γ✝</span>) (σ : Assg <span class="bp">Δ</span>),
  StateT.run (Stmt.eval (a :: ρ) (S ((_ : List.append <span class="bp">Δ</span> [α] <span class="bp">=</span> List.append <span class="bp">Δ</span> [α]) <span class="bp">▸</span> s₁)) σ) a <span class="bp">=</span> <span class="k">do</span>
    <span class="k">let</span> x <span class="bp">←</span> Stmt.eval ρ s₁ ((_ : List.append <span class="bp">Δ</span> [α] <span class="bp">=</span> List.append <span class="bp">Δ</span> [α]) <span class="bp">▸</span> Assg.extendBot a σ)
    <span class="k">match</span> x <span class="k">with</span>
      <span class="bp">|</span> (r, σ) <span class="bp">=&gt;</span>
        pure
          (r :: Assg.dropBot ((_ : List.append <span class="bp">Δ</span> [α] <span class="bp">=</span> List.append <span class="bp">Δ</span> [α]) <span class="bp">▸</span> σ),
            Assg.bot ((_ : List.append <span class="bp">Δ</span> [α] <span class="bp">=</span> List.append <span class="bp">Δ</span> [α]) <span class="bp">▸</span> σ))</span></span></span><br><span><var>ih₂</var><span class="hyp-type"><b>: </b><span><span class="bp">∀</span> (a : α) (ρ : HList (α<span class="bp">✝</span> :: <span class="bp">Γ✝</span>)) (σ : Assg <span class="bp">Δ</span>),
  StateT.run (Stmt.eval (a :: ρ) (S ((_ : List.append <span class="bp">Δ</span> [α] <span class="bp">=</span> List.append <span class="bp">Δ</span> [α]) <span class="bp">▸</span> s₂)) σ) a <span class="bp">=</span> <span class="k">do</span>
    <span class="k">let</span> x <span class="bp">←</span> Stmt.eval ρ s₂ ((_ : List.append <span class="bp">Δ</span> [α] <span class="bp">=</span> List.append <span class="bp">Δ</span> [α]) <span class="bp">▸</span> Assg.extendBot a σ)
    <span class="k">match</span> x <span class="k">with</span>
      <span class="bp">|</span> (r, σ) <span class="bp">=&gt;</span>
        pure
          (r :: Assg.dropBot ((_ : List.append <span class="bp">Δ</span> [α] <span class="bp">=</span> List.append <span class="bp">Δ</span> [α]) <span class="bp">▸</span> σ),
            Assg.bot ((_ : List.append <span class="bp">Δ</span> [α] <span class="bp">=</span> List.append <span class="bp">Δ</span> [α]) <span class="bp">▸</span> σ))</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">bind</span></span><div class="goal-conclusion">StateT.run (Stmt.eval (a :: ρ) (S ((_ : List.append <span class="bp">Δ</span> [α] <span class="bp">=</span> List.append <span class="bp">Δ</span> [α]) <span class="bp">▸</span> Stmt.bind s₁ s₂)) σ) a <span class="bp">=</span> <span class="k">do</span>
  <span class="k">let</span> x <span class="bp">←</span> Stmt.eval ρ (Stmt.bind s₁ s₂) ((_ : List.append <span class="bp">Δ</span> [α] <span class="bp">=</span> List.append <span class="bp">Δ</span> [α]) <span class="bp">▸</span> Assg.extendBot a σ)
  <span class="k">match</span> x <span class="k">with</span>
    <span class="bp">|</span> (r, σ) <span class="bp">=&gt;</span>
      pure
        (r :: Assg.dropBot ((_ : List.append <span class="bp">Δ</span> [α] <span class="bp">=</span> List.append <span class="bp">Δ</span> [α]) <span class="bp">▸</span> σ),
          Assg.bot ((_ : List.append <span class="bp">Δ</span> [α] <span class="bp">=</span> List.append <span class="bp">Δ</span> [α]) <span class="bp">▸</span> σ))</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
    </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chkd7" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chkd7"><span class="alectryon-token"><span class="k">aesop</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><span class="k">add</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">safe</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">cases</span></span><span class="alectryon-token"> Neut)</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chkd8" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chkd8"><span class="alectryon-token"><span class="bp">|</span> letmut </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>Assg Γ✝ → Assg Δ✝ → α✝</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>Stmt m ω Γ✝ (α✝ :: Δ✝) b✝ c✝ β✝</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ih</var><b>: </b><span>∀ {Δ : List Type} {a : α} {ρ : HList Γ✝} {σ : Assg Δ} (h : α✝ :: Δ✝ = List.append Δ [α]),
  StateT.run (Stmt.eval (a :: ρ) (S (h ▸ s)) σ) a = do
    let x ← Stmt.eval ρ s ((_ : List.append Δ [α] = α✝ :: Δ✝) ▸ Assg.extendBot a σ)
    match x with
      | (r, σ) =&gt; pure (r :: Assg.dropBot (h ▸ σ), Assg.bot (h ▸ σ))</span></span></div></blockquote></div></small></div><span class="nv">ih</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span></span></span></span><br><span><var>ω</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b, c</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>Δ', Γ✝</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>α✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b✝, c✝</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>β✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br><span><var>ρ</var><span class="hyp-type"><b>: </b><span>HList <span class="bp">Γ✝</span></span></span></span><br><span><var>σ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Δ</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ✝</span> <span class="bp">→</span> Assg (List.append <span class="bp">Δ</span> [α]) <span class="bp">→</span> α<span class="bp">✝</span></span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>Stmt m ω <span class="bp">Γ✝</span> (α<span class="bp">✝</span> :: List.append <span class="bp">Δ</span> [α]) b<span class="bp">✝</span> c<span class="bp">✝</span> β<span class="bp">✝</span></span></span></span><br><span><var>ih</var><span class="hyp-type"><b>: </b><span><span class="bp">∀</span> {<span class="bp">Δ</span>_1 : List <span class="kt">Type</span>} {a : α} {ρ : HList <span class="bp">Γ✝</span>} {σ : Assg <span class="bp">Δ</span>_1} (h : α<span class="bp">✝</span> :: List.append <span class="bp">Δ</span> [α] <span class="bp">=</span> List.append <span class="bp">Δ</span>_1 [α]),
  StateT.run (Stmt.eval (a :: ρ) (S (h <span class="bp">▸</span> s)) σ) a <span class="bp">=</span> <span class="k">do</span>
    <span class="k">let</span> x <span class="bp">←</span> Stmt.eval ρ s ((_ : List.append <span class="bp">Δ</span>_1 [α] <span class="bp">=</span> α<span class="bp">✝</span> :: List.append <span class="bp">Δ</span> [α]) <span class="bp">▸</span> Assg.extendBot a σ)
    <span class="k">match</span> x <span class="k">with</span>
      <span class="bp">|</span> (r, σ) <span class="bp">=&gt;</span> pure (r :: Assg.dropBot (h <span class="bp">▸</span> σ), Assg.bot (h <span class="bp">▸</span> σ))</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">letmut</span></span><div class="goal-conclusion">StateT.run (Stmt.eval (a :: ρ) (S ((_ : List.append <span class="bp">Δ</span> [α] <span class="bp">=</span> List.append <span class="bp">Δ</span> [α]) <span class="bp">▸</span> Stmt.letmut e s)) σ) a <span class="bp">=</span> <span class="k">do</span>
  <span class="k">let</span> x <span class="bp">←</span> Stmt.eval ρ (Stmt.letmut e s) ((_ : List.append <span class="bp">Δ</span> [α] <span class="bp">=</span> List.append <span class="bp">Δ</span> [α]) <span class="bp">▸</span> Assg.extendBot a σ)
  <span class="k">match</span> x <span class="k">with</span>
    <span class="bp">|</span> (r, σ) <span class="bp">=&gt;</span>
      pure
        (r :: Assg.dropBot ((_ : List.append <span class="bp">Δ</span> [α] <span class="bp">=</span> List.append <span class="bp">Δ</span> [α]) <span class="bp">▸</span> σ),
          Assg.bot ((_ : List.append <span class="bp">Δ</span> [α] <span class="bp">=</span> List.append <span class="bp">Δ</span> [α]) <span class="bp">▸</span> σ))</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
    </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chkd9" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chkd9"><span class="alectryon-token"><span class="k">have</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ih</var><b>: </b><span>∀ (a : α) (ρ : HList Γ✝) (σ : Assg (α✝ :: Δ)),
  StateT.run (Stmt.eval (a :: ρ) (S ((_ : α✝ :: List.append Δ [α] = α✝ :: List.append Δ [α]) ▸ s)) σ) a = do
    let x ← Stmt.eval ρ s ((_ : List.append (α✝ :: Δ) [α] = α✝ :: List.append Δ [α]) ▸ Assg.extendBot a σ)
    match x with
      | (r, σ) =&gt;
        pure
          (r :: Assg.dropBot ((_ : α✝ :: List.append Δ [α] = α✝ :: List.append Δ [α]) ▸ σ),
            Assg.bot ((_ : α✝ :: List.append Δ [α] = α✝ :: List.append Δ [α]) ▸ σ))</span></span></div></blockquote></div></small></div><span class="nv">ih</span></span><span class="alectryon-token"> := <span class="bp">@</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ih</var><b>: </b><span>∀ {Δ_1 : List Type} {a : α} {ρ : HList Γ✝} {σ : Assg Δ_1} (h : α✝ :: List.append Δ [α] = List.append Δ_1 [α]),
  StateT.run (Stmt.eval (a :: ρ) (S (h ▸ s)) σ) a = do
    let x ← Stmt.eval ρ s ((_ : List.append Δ_1 [α] = α✝ :: List.append Δ [α]) ▸ Assg.extendBot a σ)
    match x with
      | (r, σ) =&gt; pure (r :: Assg.dropBot (h ▸ σ), Assg.bot (h ▸ σ))</span></span></div></blockquote></div></small></div><span class="nv">ih</span></span><span class="alectryon-token"> (<span class="bp">Δ</span> := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>_</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>_</span><span class="alectryon-token"> :: </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Δ</var><b>: </b><span>List Type</span></span></div></blockquote></div></small></div><span class="nv">Δ</span></span><span class="alectryon-token">) (h := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>rfl</var><b>: </b><span>∀ {α : Type 1} {a : α}, a = a</span></span></div></blockquote></div></small></div>rfl</span><span class="alectryon-token">)</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span></span></span></span><br><span><var>ω</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b, c</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>Δ', Γ✝</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>α✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b✝, c✝</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>β✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br><span><var>ρ</var><span class="hyp-type"><b>: </b><span>HList <span class="bp">Γ✝</span></span></span></span><br><span><var>σ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Δ</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ✝</span> <span class="bp">→</span> Assg (List.append <span class="bp">Δ</span> [α]) <span class="bp">→</span> α<span class="bp">✝</span></span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>Stmt m ω <span class="bp">Γ✝</span> (α<span class="bp">✝</span> :: List.append <span class="bp">Δ</span> [α]) b<span class="bp">✝</span> c<span class="bp">✝</span> β<span class="bp">✝</span></span></span></span><br><span><var>ih</var><span class="hyp-type"><b>: </b><span><span class="bp">∀</span> (a : α) (ρ : HList <span class="bp">Γ✝</span>) (σ : Assg (α<span class="bp">✝</span> :: <span class="bp">Δ</span>)),
  StateT.run (Stmt.eval (a :: ρ) (S ((_ : α<span class="bp">✝</span> :: List.append <span class="bp">Δ</span> [α] <span class="bp">=</span> α<span class="bp">✝</span> :: List.append <span class="bp">Δ</span> [α]) <span class="bp">▸</span> s)) σ) a <span class="bp">=</span> <span class="k">do</span>
    <span class="k">let</span> x <span class="bp">←</span> Stmt.eval ρ s ((_ : List.append (α<span class="bp">✝</span> :: <span class="bp">Δ</span>) [α] <span class="bp">=</span> α<span class="bp">✝</span> :: List.append <span class="bp">Δ</span> [α]) <span class="bp">▸</span> Assg.extendBot a σ)
    <span class="k">match</span> x <span class="k">with</span>
      <span class="bp">|</span> (r, σ) <span class="bp">=&gt;</span>
        pure
          (r :: Assg.dropBot ((_ : α<span class="bp">✝</span> :: List.append <span class="bp">Δ</span> [α] <span class="bp">=</span> α<span class="bp">✝</span> :: List.append <span class="bp">Δ</span> [α]) <span class="bp">▸</span> σ),
            Assg.bot ((_ : α<span class="bp">✝</span> :: List.append <span class="bp">Δ</span> [α] <span class="bp">=</span> α<span class="bp">✝</span> :: List.append <span class="bp">Δ</span> [α]) <span class="bp">▸</span> σ))</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">letmut</span></span><div class="goal-conclusion">StateT.run (Stmt.eval (a :: ρ) (S ((_ : List.append <span class="bp">Δ</span> [α] <span class="bp">=</span> List.append <span class="bp">Δ</span> [α]) <span class="bp">▸</span> Stmt.letmut e s)) σ) a <span class="bp">=</span> <span class="k">do</span>
  <span class="k">let</span> x <span class="bp">←</span> Stmt.eval ρ (Stmt.letmut e s) ((_ : List.append <span class="bp">Δ</span> [α] <span class="bp">=</span> List.append <span class="bp">Δ</span> [α]) <span class="bp">▸</span> Assg.extendBot a σ)
  <span class="k">match</span> x <span class="k">with</span>
    <span class="bp">|</span> (r, σ) <span class="bp">=&gt;</span>
      pure
        (r :: Assg.dropBot ((_ : List.append <span class="bp">Δ</span> [α] <span class="bp">=</span> List.append <span class="bp">Δ</span> [α]) <span class="bp">▸</span> σ),
          Assg.bot ((_ : List.append <span class="bp">Δ</span> [α] <span class="bp">=</span> List.append <span class="bp">Δ</span> [α]) <span class="bp">▸</span> σ))</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
    </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chkda" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chkda"><span class="alectryon-token"><span class="k">aesop</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chkdb" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chkdb"><span class="alectryon-token"><span class="bp">|</span> sfor </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>Assg Γ✝ → Assg Δ✝ → List α✝</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>Stmt m ω (α✝ :: Γ✝) Δ✝ true true Unit</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ih</var><b>: </b><span>∀ {Δ : List Type} {a : α} {ρ : HList (α✝ :: Γ✝)} {σ : Assg Δ} (h : Δ✝ = List.append Δ [α]),
  StateT.run (Stmt.eval (a :: ρ) (S (h ▸ s)) σ) a = do
    let x ← Stmt.eval ρ s ((_ : List.append Δ [α] = Δ✝) ▸ Assg.extendBot a σ)
    match x with
      | (r, σ) =&gt; pure (r :: Assg.dropBot (h ▸ σ), Assg.bot (h ▸ σ))</span></span></div></blockquote></div></small></div><span class="nv">ih</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span></span></span></span><br><span><var>ω</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b, c</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>Δ', Γ✝</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>α✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b✝, c✝</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br><span><var>ρ</var><span class="hyp-type"><b>: </b><span>HList <span class="bp">Γ✝</span></span></span></span><br><span><var>σ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Δ</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ✝</span> <span class="bp">→</span> Assg (List.append <span class="bp">Δ</span> [α]) <span class="bp">→</span> List α<span class="bp">✝</span></span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>Stmt m ω (α<span class="bp">✝</span> :: <span class="bp">Γ✝</span>) (List.append <span class="bp">Δ</span> [α]) true true Unit</span></span></span><br><span><var>ih</var><span class="hyp-type"><b>: </b><span><span class="bp">∀</span> {<span class="bp">Δ</span>_1 : List <span class="kt">Type</span>} {a : α} {ρ : HList (α<span class="bp">✝</span> :: <span class="bp">Γ✝</span>)} {σ : Assg <span class="bp">Δ</span>_1} (h : List.append <span class="bp">Δ</span> [α] <span class="bp">=</span> List.append <span class="bp">Δ</span>_1 [α]),
  StateT.run (Stmt.eval (a :: ρ) (S (h <span class="bp">▸</span> s)) σ) a <span class="bp">=</span> <span class="k">do</span>
    <span class="k">let</span> x <span class="bp">←</span> Stmt.eval ρ s ((_ : List.append <span class="bp">Δ</span>_1 [α] <span class="bp">=</span> List.append <span class="bp">Δ</span> [α]) <span class="bp">▸</span> Assg.extendBot a σ)
    <span class="k">match</span> x <span class="k">with</span>
      <span class="bp">|</span> (r, σ) <span class="bp">=&gt;</span> pure (r :: Assg.dropBot (h <span class="bp">▸</span> σ), Assg.bot (h <span class="bp">▸</span> σ))</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">sfor</span></span><div class="goal-conclusion">StateT.run (Stmt.eval (a :: ρ) (S ((_ : List.append <span class="bp">Δ</span> [α] <span class="bp">=</span> List.append <span class="bp">Δ</span> [α]) <span class="bp">▸</span> Stmt.sfor e s)) σ) a <span class="bp">=</span> <span class="k">do</span>
  <span class="k">let</span> x <span class="bp">←</span> Stmt.eval ρ (Stmt.sfor e s) ((_ : List.append <span class="bp">Δ</span> [α] <span class="bp">=</span> List.append <span class="bp">Δ</span> [α]) <span class="bp">▸</span> Assg.extendBot a σ)
  <span class="k">match</span> x <span class="k">with</span>
    <span class="bp">|</span> (r, σ) <span class="bp">=&gt;</span>
      pure
        (r :: Assg.dropBot ((_ : List.append <span class="bp">Δ</span> [α] <span class="bp">=</span> List.append <span class="bp">Δ</span> [α]) <span class="bp">▸</span> σ),
          Assg.bot ((_ : List.append <span class="bp">Δ</span> [α] <span class="bp">=</span> List.append <span class="bp">Δ</span> [α]) <span class="bp">▸</span> σ))</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
    </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chkdc" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chkdc"><span class="alectryon-token"><span class="k">have</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ih</var><b>: </b><span>∀ (a : α) (ρ : HList (α✝ :: Γ✝)) (σ : Assg Δ),
  StateT.run (Stmt.eval (a :: ρ) (S ((_ : List.append Δ [α] = List.append Δ [α]) ▸ s)) σ) a = do
    let x ← Stmt.eval ρ s ((_ : List.append Δ [α] = List.append Δ [α]) ▸ Assg.extendBot a σ)
    match x with
      | (r, σ) =&gt;
        pure
          (r :: Assg.dropBot ((_ : List.append Δ [α] = List.append Δ [α]) ▸ σ),
            Assg.bot ((_ : List.append Δ [α] = List.append Δ [α]) ▸ σ))</span></span></div></blockquote></div></small></div><span class="nv">ih</span></span><span class="alectryon-token"> := <span class="bp">@</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ih</var><b>: </b><span>∀ {Δ_1 : List Type} {a : α} {ρ : HList (α✝ :: Γ✝)} {σ : Assg Δ_1} (h : List.append Δ [α] = List.append Δ_1 [α]),
  StateT.run (Stmt.eval (a :: ρ) (S (h ▸ s)) σ) a = do
    let x ← Stmt.eval ρ s ((_ : List.append Δ_1 [α] = List.append Δ [α]) ▸ Assg.extendBot a σ)
    match x with
      | (r, σ) =&gt; pure (r :: Assg.dropBot (h ▸ σ), Assg.bot (h ▸ σ))</span></span></div></blockquote></div></small></div><span class="nv">ih</span></span><span class="alectryon-token"> (h := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>rfl</var><b>: </b><span>∀ {α : Type 1} {a : α}, a = a</span></span></div></blockquote></div></small></div>rfl</span><span class="alectryon-token">)</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span></span></span></span><br><span><var>ω</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b, c</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>Δ', Γ✝</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>α✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b✝, c✝</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br><span><var>ρ</var><span class="hyp-type"><b>: </b><span>HList <span class="bp">Γ✝</span></span></span></span><br><span><var>σ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Δ</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ✝</span> <span class="bp">→</span> Assg (List.append <span class="bp">Δ</span> [α]) <span class="bp">→</span> List α<span class="bp">✝</span></span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>Stmt m ω (α<span class="bp">✝</span> :: <span class="bp">Γ✝</span>) (List.append <span class="bp">Δ</span> [α]) true true Unit</span></span></span><br><span><var>ih</var><span class="hyp-type"><b>: </b><span><span class="bp">∀</span> (a : α) (ρ : HList (α<span class="bp">✝</span> :: <span class="bp">Γ✝</span>)) (σ : Assg <span class="bp">Δ</span>),
  StateT.run (Stmt.eval (a :: ρ) (S ((_ : List.append <span class="bp">Δ</span> [α] <span class="bp">=</span> List.append <span class="bp">Δ</span> [α]) <span class="bp">▸</span> s)) σ) a <span class="bp">=</span> <span class="k">do</span>
    <span class="k">let</span> x <span class="bp">←</span> Stmt.eval ρ s ((_ : List.append <span class="bp">Δ</span> [α] <span class="bp">=</span> List.append <span class="bp">Δ</span> [α]) <span class="bp">▸</span> Assg.extendBot a σ)
    <span class="k">match</span> x <span class="k">with</span>
      <span class="bp">|</span> (r, σ) <span class="bp">=&gt;</span>
        pure
          (r :: Assg.dropBot ((_ : List.append <span class="bp">Δ</span> [α] <span class="bp">=</span> List.append <span class="bp">Δ</span> [α]) <span class="bp">▸</span> σ),
            Assg.bot ((_ : List.append <span class="bp">Δ</span> [α] <span class="bp">=</span> List.append <span class="bp">Δ</span> [α]) <span class="bp">▸</span> σ))</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">sfor</span></span><div class="goal-conclusion">StateT.run (Stmt.eval (a :: ρ) (S ((_ : List.append <span class="bp">Δ</span> [α] <span class="bp">=</span> List.append <span class="bp">Δ</span> [α]) <span class="bp">▸</span> Stmt.sfor e s)) σ) a <span class="bp">=</span> <span class="k">do</span>
  <span class="k">let</span> x <span class="bp">←</span> Stmt.eval ρ (Stmt.sfor e s) ((_ : List.append <span class="bp">Δ</span> [α] <span class="bp">=</span> List.append <span class="bp">Δ</span> [α]) <span class="bp">▸</span> Assg.extendBot a σ)
  <span class="k">match</span> x <span class="k">with</span>
    <span class="bp">|</span> (r, σ) <span class="bp">=&gt;</span>
      pure
        (r :: Assg.dropBot ((_ : List.append <span class="bp">Δ</span> [α] <span class="bp">=</span> List.append <span class="bp">Δ</span> [α]) <span class="bp">▸</span> σ),
          Assg.bot ((_ : List.append <span class="bp">Δ</span> [α] <span class="bp">=</span> List.append <span class="bp">Δ</span> [α]) <span class="bp">▸</span> σ))</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
    </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chkdd" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chkdd"><span class="alectryon-token"><span class="k">simp</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">only</span></span><span class="alectryon-token"> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>S</var><b>: </b><span>{m : Type → Type} →
  {ω : Type} →
    {Γ Δ : List Type} →
      {α : Type} →
        {b c : Bool} →
          {β : Type} → [inst : Monad m] → Stmt m ω Γ (List.append Δ [α]) b c β → Stmt (StateT α m) ω (α :: Γ) Δ b c β</span></span></div></blockquote></div></small></div>S</span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt.eval</var><b>: </b><span>{m : Type → Type ?u.595108} →
  {Γ : List Type} →
    {ω : Type} →
      {Δ : List Type} →
        {b c : Bool} → {α : Type} → [inst : Monad m] → Assg Γ → Stmt m ω Γ Δ b c α → Assg Δ → m (Neut ω α b c × Assg Δ)</span></span></div></blockquote></div></small></div>Stmt.eval</span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>S.unmut</var><b>: </b><span>{Γ Δ : List Type} → {α β : Type} → (Assg Γ → Assg (List.append Δ [α]) → β) → Assg (α :: Γ) → Assg Δ → β</span></span></div></blockquote></div></small></div>S.unmut</span><span class="alectryon-token">]</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span></span></span></span><br><span><var>ω</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b, c</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>Δ', Γ✝</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>α✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b✝, c✝</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br><span><var>ρ</var><span class="hyp-type"><b>: </b><span>HList <span class="bp">Γ✝</span></span></span></span><br><span><var>σ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Δ</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ✝</span> <span class="bp">→</span> Assg (List.append <span class="bp">Δ</span> [α]) <span class="bp">→</span> List α<span class="bp">✝</span></span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>Stmt m ω (α<span class="bp">✝</span> :: <span class="bp">Γ✝</span>) (List.append <span class="bp">Δ</span> [α]) true true Unit</span></span></span><br><span><var>ih</var><span class="hyp-type"><b>: </b><span><span class="bp">∀</span> (a : α) (ρ : HList (α<span class="bp">✝</span> :: <span class="bp">Γ✝</span>)) (σ : Assg <span class="bp">Δ</span>),
  StateT.run (Stmt.eval (a :: ρ) (S ((_ : List.append <span class="bp">Δ</span> [α] <span class="bp">=</span> List.append <span class="bp">Δ</span> [α]) <span class="bp">▸</span> s)) σ) a <span class="bp">=</span> <span class="k">do</span>
    <span class="k">let</span> x <span class="bp">←</span> Stmt.eval ρ s ((_ : List.append <span class="bp">Δ</span> [α] <span class="bp">=</span> List.append <span class="bp">Δ</span> [α]) <span class="bp">▸</span> Assg.extendBot a σ)
    <span class="k">match</span> x <span class="k">with</span>
      <span class="bp">|</span> (r, σ) <span class="bp">=&gt;</span>
        pure
          (r :: Assg.dropBot ((_ : List.append <span class="bp">Δ</span> [α] <span class="bp">=</span> List.append <span class="bp">Δ</span> [α]) <span class="bp">▸</span> σ),
            Assg.bot ((_ : List.append <span class="bp">Δ</span> [α] <span class="bp">=</span> List.append <span class="bp">Δ</span> [α]) <span class="bp">▸</span> σ))</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">sfor</span></span><div class="goal-conclusion">StateT.run
    (Stmt.eval.go (a :: ρ) c<span class="bp">✝</span> b<span class="bp">✝</span> α<span class="bp">✝</span> (Stmt.bind (Stmt.expr <span class="k">fun</span> x x <span class="bp">=&gt;</span> get) (Stmt.mapAssg S.shadowSnd (S s))) σ
      (e ρ (Assg.extendBot a σ)))
    a <span class="bp">=</span>
  <span class="k">do</span>
  <span class="k">let</span> x <span class="bp">←</span> Stmt.eval.go ρ c<span class="bp">✝</span> b<span class="bp">✝</span> α<span class="bp">✝</span> s (Assg.extendBot a σ) (e ρ (Assg.extendBot a σ))
  pure (x.fst :: Assg.dropBot x.snd, Assg.bot x.snd)</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
    </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chkde" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chkde"><span class="alectryon-token"><span class="c1">-- surgical generalization</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span></span></span></span><br><span><var>ω</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b, c</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>Δ', Γ✝</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>α✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b✝, c✝</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br><span><var>ρ</var><span class="hyp-type"><b>: </b><span>HList <span class="bp">Γ✝</span></span></span></span><br><span><var>σ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Δ</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ✝</span> <span class="bp">→</span> Assg (List.append <span class="bp">Δ</span> [α]) <span class="bp">→</span> List α<span class="bp">✝</span></span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>Stmt m ω (α<span class="bp">✝</span> :: <span class="bp">Γ✝</span>) (List.append <span class="bp">Δ</span> [α]) true true Unit</span></span></span><br><span><var>ih</var><span class="hyp-type"><b>: </b><span><span class="bp">∀</span> {<span class="bp">Δ</span>_1 : List <span class="kt">Type</span>} {a : α} {ρ : HList (α<span class="bp">✝</span> :: <span class="bp">Γ✝</span>)} {σ : Assg <span class="bp">Δ</span>_1} (h : List.append <span class="bp">Δ</span> [α] <span class="bp">=</span> List.append <span class="bp">Δ</span>_1 [α]),
  StateT.run (Stmt.eval (a :: ρ) (S (h <span class="bp">▸</span> s)) σ) a <span class="bp">=</span> <span class="k">do</span>
    <span class="k">let</span> x <span class="bp">←</span> Stmt.eval ρ s ((_ : List.append <span class="bp">Δ</span>_1 [α] <span class="bp">=</span> List.append <span class="bp">Δ</span> [α]) <span class="bp">▸</span> Assg.extendBot a σ)
    <span class="k">match</span> x <span class="k">with</span>
      <span class="bp">|</span> (r, σ) <span class="bp">=&gt;</span> pure (r :: Assg.dropBot (h <span class="bp">▸</span> σ), Assg.bot (h <span class="bp">▸</span> σ))</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">sfor</span></span><div class="goal-conclusion">StateT.run (Stmt.eval (a :: ρ) (S ((_ : List.append <span class="bp">Δ</span> [α] <span class="bp">=</span> List.append <span class="bp">Δ</span> [α]) <span class="bp">▸</span> Stmt.sfor e s)) σ) a <span class="bp">=</span> <span class="k">do</span>
  <span class="k">let</span> x <span class="bp">←</span> Stmt.eval ρ (Stmt.sfor e s) ((_ : List.append <span class="bp">Δ</span> [α] <span class="bp">=</span> List.append <span class="bp">Δ</span> [α]) <span class="bp">▸</span> Assg.extendBot a σ)
  <span class="k">match</span> x <span class="k">with</span>
    <span class="bp">|</span> (r, σ) <span class="bp">=&gt;</span>
      pure
        (r :: Assg.dropBot ((_ : List.append <span class="bp">Δ</span> [α] <span class="bp">=</span> List.append <span class="bp">Δ</span> [α]) <span class="bp">▸</span> σ),
          Assg.bot ((_ : List.append <span class="bp">Δ</span> [α] <span class="bp">=</span> List.append <span class="bp">Δ</span> [α]) <span class="bp">▸</span> σ))</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
    </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chkdf" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chkdf"><span class="alectryon-token"><span class="k">generalize</span></span><span class="alectryon-token"> h : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"> <span class="bp">=</span> a&#39;</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span></span></span></span><br><span><var>ω</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b, c</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>Δ', Γ✝</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>α✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b✝, c✝</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br><span><var>ρ</var><span class="hyp-type"><b>: </b><span>HList <span class="bp">Γ✝</span></span></span></span><br><span><var>σ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Δ</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ✝</span> <span class="bp">→</span> Assg (List.append <span class="bp">Δ</span> [α]) <span class="bp">→</span> List α<span class="bp">✝</span></span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>Stmt m ω (α<span class="bp">✝</span> :: <span class="bp">Γ✝</span>) (List.append <span class="bp">Δ</span> [α]) true true Unit</span></span></span><br><span><var>ih</var><span class="hyp-type"><b>: </b><span><span class="bp">∀</span> (a : α) (ρ : HList (α<span class="bp">✝</span> :: <span class="bp">Γ✝</span>)) (σ : Assg <span class="bp">Δ</span>),
  StateT.run (Stmt.eval (a :: ρ) (S ((_ : List.append <span class="bp">Δ</span> [α] <span class="bp">=</span> List.append <span class="bp">Δ</span> [α]) <span class="bp">▸</span> s)) σ) a <span class="bp">=</span> <span class="k">do</span>
    <span class="k">let</span> x <span class="bp">←</span> Stmt.eval ρ s ((_ : List.append <span class="bp">Δ</span> [α] <span class="bp">=</span> List.append <span class="bp">Δ</span> [α]) <span class="bp">▸</span> Assg.extendBot a σ)
    <span class="k">match</span> x <span class="k">with</span>
      <span class="bp">|</span> (r, σ) <span class="bp">=&gt;</span>
        pure
          (r :: Assg.dropBot ((_ : List.append <span class="bp">Δ</span> [α] <span class="bp">=</span> List.append <span class="bp">Δ</span> [α]) <span class="bp">▸</span> σ),
            Assg.bot ((_ : List.append <span class="bp">Δ</span> [α] <span class="bp">=</span> List.append <span class="bp">Δ</span> [α]) <span class="bp">▸</span> σ))</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>a <span class="bp">=</span> a&#39;</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">sfor</span></span><div class="goal-conclusion">StateT.run
    (Stmt.eval.go (a&#39; :: ρ) c<span class="bp">✝</span> b<span class="bp">✝</span> α<span class="bp">✝</span> (Stmt.bind (Stmt.expr <span class="k">fun</span> x x <span class="bp">=&gt;</span> get) (Stmt.mapAssg S.shadowSnd (S s))) σ
      (e ρ (Assg.extendBot a&#39; σ)))
    a&#39; <span class="bp">=</span>
  <span class="k">do</span>
  <span class="k">let</span> x <span class="bp">←</span> Stmt.eval.go ρ c<span class="bp">✝</span> b<span class="bp">✝</span> α<span class="bp">✝</span> s (Assg.extendBot a&#39; σ) (e ρ (Assg.extendBot a&#39; σ))
  pure (x.fst :: Assg.dropBot x.snd, Assg.bot x.snd)</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
    </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chke0" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chke0"><span class="alectryon-token"><span class="k">conv</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span></span></span></span><br><span><var>ω</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b, c</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>Δ', Γ✝</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>α✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b✝, c✝</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br><span><var>ρ</var><span class="hyp-type"><b>: </b><span>HList <span class="bp">Γ✝</span></span></span></span><br><span><var>σ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Δ</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ✝</span> <span class="bp">→</span> Assg (List.append <span class="bp">Δ</span> [α]) <span class="bp">→</span> List α<span class="bp">✝</span></span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>Stmt m ω (α<span class="bp">✝</span> :: <span class="bp">Γ✝</span>) (List.append <span class="bp">Δ</span> [α]) true true Unit</span></span></span><br><span><var>ih</var><span class="hyp-type"><b>: </b><span><span class="bp">∀</span> (a : α) (ρ : HList (α<span class="bp">✝</span> :: <span class="bp">Γ✝</span>)) (σ : Assg <span class="bp">Δ</span>),
  StateT.run (Stmt.eval (a :: ρ) (S ((_ : List.append <span class="bp">Δ</span> [α] <span class="bp">=</span> List.append <span class="bp">Δ</span> [α]) <span class="bp">▸</span> s)) σ) a <span class="bp">=</span> <span class="k">do</span>
    <span class="k">let</span> x <span class="bp">←</span> Stmt.eval ρ s ((_ : List.append <span class="bp">Δ</span> [α] <span class="bp">=</span> List.append <span class="bp">Δ</span> [α]) <span class="bp">▸</span> Assg.extendBot a σ)
    <span class="k">match</span> x <span class="k">with</span>
      <span class="bp">|</span> (r, σ) <span class="bp">=&gt;</span>
        pure
          (r :: Assg.dropBot ((_ : List.append <span class="bp">Δ</span> [α] <span class="bp">=</span> List.append <span class="bp">Δ</span> [α]) <span class="bp">▸</span> σ),
            Assg.bot ((_ : List.append <span class="bp">Δ</span> [α] <span class="bp">=</span> List.append <span class="bp">Δ</span> [α]) <span class="bp">▸</span> σ))</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>a <span class="bp">=</span> a&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a :: ρ</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
      </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chke1" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chke1"><span class="alectryon-token"><span class="k">pattern</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>HList.cons</var><b>: </b><span>{α : Type} → {αs : List Type} → α → HList αs → HList (α :: αs)</span></span></div></blockquote></div></small></div>HList.cons</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a'</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">a&#39;</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>_</var><b>: </b><span>HList ?m.595792</span></span></div></blockquote></div></small></div>_</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span></span></span></span><br><span><var>ω</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b, c</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>Δ', Γ✝</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>α✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b✝, c✝</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br><span><var>ρ</var><span class="hyp-type"><b>: </b><span>HList <span class="bp">Γ✝</span></span></span></span><br><span><var>σ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Δ</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ✝</span> <span class="bp">→</span> Assg (List.append <span class="bp">Δ</span> [α]) <span class="bp">→</span> List α<span class="bp">✝</span></span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>Stmt m ω (α<span class="bp">✝</span> :: <span class="bp">Γ✝</span>) (List.append <span class="bp">Δ</span> [α]) true true Unit</span></span></span><br><span><var>ih</var><span class="hyp-type"><b>: </b><span><span class="bp">∀</span> (a : α) (ρ : HList (α<span class="bp">✝</span> :: <span class="bp">Γ✝</span>)) (σ : Assg <span class="bp">Δ</span>),
  StateT.run (Stmt.eval (a :: ρ) (S ((_ : List.append <span class="bp">Δ</span> [α] <span class="bp">=</span> List.append <span class="bp">Δ</span> [α]) <span class="bp">▸</span> s)) σ) a <span class="bp">=</span> <span class="k">do</span>
    <span class="k">let</span> x <span class="bp">←</span> Stmt.eval ρ s ((_ : List.append <span class="bp">Δ</span> [α] <span class="bp">=</span> List.append <span class="bp">Δ</span> [α]) <span class="bp">▸</span> Assg.extendBot a σ)
    <span class="k">match</span> x <span class="k">with</span>
      <span class="bp">|</span> (r, σ) <span class="bp">=&gt;</span>
        pure
          (r :: Assg.dropBot ((_ : List.append <span class="bp">Δ</span> [α] <span class="bp">=</span> List.append <span class="bp">Δ</span> [α]) <span class="bp">▸</span> σ),
            Assg.bot ((_ : List.append <span class="bp">Δ</span> [α] <span class="bp">=</span> List.append <span class="bp">Δ</span> [α]) <span class="bp">▸</span> σ))</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>a <span class="bp">=</span> a&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a&#39; :: ρ</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
      </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chke2" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chke2"><span class="alectryon-token"><span class="k">rw</span></span><span class="alectryon-token"> [</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span></span></span></span><br><span><var>ω</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b, c</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>Δ', Γ✝</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>α✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b✝, c✝</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br><span><var>ρ</var><span class="hyp-type"><b>: </b><span>HList <span class="bp">Γ✝</span></span></span></span><br><span><var>σ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Δ</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ✝</span> <span class="bp">→</span> Assg (List.append <span class="bp">Δ</span> [α]) <span class="bp">→</span> List α<span class="bp">✝</span></span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>Stmt m ω (α<span class="bp">✝</span> :: <span class="bp">Γ✝</span>) (List.append <span class="bp">Δ</span> [α]) true true Unit</span></span></span><br><span><var>ih</var><span class="hyp-type"><b>: </b><span><span class="bp">∀</span> (a : α) (ρ : HList (α<span class="bp">✝</span> :: <span class="bp">Γ✝</span>)) (σ : Assg <span class="bp">Δ</span>),
  StateT.run (Stmt.eval (a :: ρ) (S ((_ : List.append <span class="bp">Δ</span> [α] <span class="bp">=</span> List.append <span class="bp">Δ</span> [α]) <span class="bp">▸</span> s)) σ) a <span class="bp">=</span> <span class="k">do</span>
    <span class="k">let</span> x <span class="bp">←</span> Stmt.eval ρ s ((_ : List.append <span class="bp">Δ</span> [α] <span class="bp">=</span> List.append <span class="bp">Δ</span> [α]) <span class="bp">▸</span> Assg.extendBot a σ)
    <span class="k">match</span> x <span class="k">with</span>
      <span class="bp">|</span> (r, σ) <span class="bp">=&gt;</span>
        pure
          (r :: Assg.dropBot ((_ : List.append <span class="bp">Δ</span> [α] <span class="bp">=</span> List.append <span class="bp">Δ</span> [α]) <span class="bp">▸</span> σ),
            Assg.bot ((_ : List.append <span class="bp">Δ</span> [α] <span class="bp">=</span> List.append <span class="bp">Δ</span> [α]) <span class="bp">▸</span> σ))</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>a <span class="bp">=</span> a&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a&#39; :: ρ</div></blockquote></div></div></small></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chke3" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chke3"><span class="alectryon-token"><span class="bp">←</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>h</var><b>: </b><span>a = a'</span></span></div></blockquote></div></small></div><span class="nv">h</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span></span></span></span><br><span><var>ω</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b, c</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>Δ', Γ✝</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>α✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b✝, c✝</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br><span><var>ρ</var><span class="hyp-type"><b>: </b><span>HList <span class="bp">Γ✝</span></span></span></span><br><span><var>σ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Δ</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ✝</span> <span class="bp">→</span> Assg (List.append <span class="bp">Δ</span> [α]) <span class="bp">→</span> List α<span class="bp">✝</span></span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>Stmt m ω (α<span class="bp">✝</span> :: <span class="bp">Γ✝</span>) (List.append <span class="bp">Δ</span> [α]) true true Unit</span></span></span><br><span><var>ih</var><span class="hyp-type"><b>: </b><span><span class="bp">∀</span> (a : α) (ρ : HList (α<span class="bp">✝</span> :: <span class="bp">Γ✝</span>)) (σ : Assg <span class="bp">Δ</span>),
  StateT.run (Stmt.eval (a :: ρ) (S ((_ : List.append <span class="bp">Δ</span> [α] <span class="bp">=</span> List.append <span class="bp">Δ</span> [α]) <span class="bp">▸</span> s)) σ) a <span class="bp">=</span> <span class="k">do</span>
    <span class="k">let</span> x <span class="bp">←</span> Stmt.eval ρ s ((_ : List.append <span class="bp">Δ</span> [α] <span class="bp">=</span> List.append <span class="bp">Δ</span> [α]) <span class="bp">▸</span> Assg.extendBot a σ)
    <span class="k">match</span> x <span class="k">with</span>
      <span class="bp">|</span> (r, σ) <span class="bp">=&gt;</span>
        pure
          (r :: Assg.dropBot ((_ : List.append <span class="bp">Δ</span> [α] <span class="bp">=</span> List.append <span class="bp">Δ</span> [α]) <span class="bp">▸</span> σ),
            Assg.bot ((_ : List.append <span class="bp">Δ</span> [α] <span class="bp">=</span> List.append <span class="bp">Δ</span> [α]) <span class="bp">▸</span> σ))</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>a <span class="bp">=</span> a&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a :: ρ</div></blockquote></div></div></small></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chke4" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chke4"><span class="alectryon-token">]</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span></span></span></span><br><span><var>ω</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b, c</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>Δ', Γ✝</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>α✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b✝, c✝</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br><span><var>ρ</var><span class="hyp-type"><b>: </b><span>HList <span class="bp">Γ✝</span></span></span></span><br><span><var>σ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Δ</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ✝</span> <span class="bp">→</span> Assg (List.append <span class="bp">Δ</span> [α]) <span class="bp">→</span> List α<span class="bp">✝</span></span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>Stmt m ω (α<span class="bp">✝</span> :: <span class="bp">Γ✝</span>) (List.append <span class="bp">Δ</span> [α]) true true Unit</span></span></span><br><span><var>ih</var><span class="hyp-type"><b>: </b><span><span class="bp">∀</span> (a : α) (ρ : HList (α<span class="bp">✝</span> :: <span class="bp">Γ✝</span>)) (σ : Assg <span class="bp">Δ</span>),
  StateT.run (Stmt.eval (a :: ρ) (S ((_ : List.append <span class="bp">Δ</span> [α] <span class="bp">=</span> List.append <span class="bp">Δ</span> [α]) <span class="bp">▸</span> s)) σ) a <span class="bp">=</span> <span class="k">do</span>
    <span class="k">let</span> x <span class="bp">←</span> Stmt.eval ρ s ((_ : List.append <span class="bp">Δ</span> [α] <span class="bp">=</span> List.append <span class="bp">Δ</span> [α]) <span class="bp">▸</span> Assg.extendBot a σ)
    <span class="k">match</span> x <span class="k">with</span>
      <span class="bp">|</span> (r, σ) <span class="bp">=&gt;</span>
        pure
          (r :: Assg.dropBot ((_ : List.append <span class="bp">Δ</span> [α] <span class="bp">=</span> List.append <span class="bp">Δ</span> [α]) <span class="bp">▸</span> σ),
            Assg.bot ((_ : List.append <span class="bp">Δ</span> [α] <span class="bp">=</span> List.append <span class="bp">Δ</span> [α]) <span class="bp">▸</span> σ))</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>a <span class="bp">=</span> a&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a :: ρ</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
    </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chke5" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chke5"><span class="alectryon-token"><span class="k">clear</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>h</var><b>: </b><span>a = a'</span></span></div></blockquote></div></small></div><span class="nv">h</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span></span></span></span><br><span><var>ω</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b, c</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>Δ', Γ✝</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>α✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b✝, c✝</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br><span><var>ρ</var><span class="hyp-type"><b>: </b><span>HList <span class="bp">Γ✝</span></span></span></span><br><span><var>σ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Δ</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ✝</span> <span class="bp">→</span> Assg (List.append <span class="bp">Δ</span> [α]) <span class="bp">→</span> List α<span class="bp">✝</span></span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>Stmt m ω (α<span class="bp">✝</span> :: <span class="bp">Γ✝</span>) (List.append <span class="bp">Δ</span> [α]) true true Unit</span></span></span><br><span><var>ih</var><span class="hyp-type"><b>: </b><span><span class="bp">∀</span> (a : α) (ρ : HList (α<span class="bp">✝</span> :: <span class="bp">Γ✝</span>)) (σ : Assg <span class="bp">Δ</span>),
  StateT.run (Stmt.eval (a :: ρ) (S ((_ : List.append <span class="bp">Δ</span> [α] <span class="bp">=</span> List.append <span class="bp">Δ</span> [α]) <span class="bp">▸</span> s)) σ) a <span class="bp">=</span> <span class="k">do</span>
    <span class="k">let</span> x <span class="bp">←</span> Stmt.eval ρ s ((_ : List.append <span class="bp">Δ</span> [α] <span class="bp">=</span> List.append <span class="bp">Δ</span> [α]) <span class="bp">▸</span> Assg.extendBot a σ)
    <span class="k">match</span> x <span class="k">with</span>
      <span class="bp">|</span> (r, σ) <span class="bp">=&gt;</span>
        pure
          (r :: Assg.dropBot ((_ : List.append <span class="bp">Δ</span> [α] <span class="bp">=</span> List.append <span class="bp">Δ</span> [α]) <span class="bp">▸</span> σ),
            Assg.bot ((_ : List.append <span class="bp">Δ</span> [α] <span class="bp">=</span> List.append <span class="bp">Δ</span> [α]) <span class="bp">▸</span> σ))</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">sfor</span></span><div class="goal-conclusion">StateT.run
    (Stmt.eval.go (a :: ρ) c<span class="bp">✝</span> b<span class="bp">✝</span> α<span class="bp">✝</span> (Stmt.bind (Stmt.expr <span class="k">fun</span> x x <span class="bp">=&gt;</span> get) (Stmt.mapAssg S.shadowSnd (S s))) σ
      (e ρ (Assg.extendBot a&#39; σ)))
    a&#39; <span class="bp">=</span>
  <span class="k">do</span>
  <span class="k">let</span> x <span class="bp">←</span> Stmt.eval.go ρ c<span class="bp">✝</span> b<span class="bp">✝</span> α<span class="bp">✝</span> s (Assg.extendBot a&#39; σ) (e ρ (Assg.extendBot a&#39; σ))
  pure (x.fst :: Assg.dropBot x.snd, Assg.bot x.snd)</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
    </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chke6" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chke6"><span class="alectryon-token"><span class="k">induction</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>Assg Γ✝ → Assg (List.append Δ [α]) → List α✝</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ρ</var><b>: </b><span>HList Γ✝</span></span></div></blockquote></div></small></div><span class="nv">ρ</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>_</var><b>: </b><span>Assg (List.append Δ [α])</span></span></div></blockquote></div></small></div><span class="k">_</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">generalizing</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>σ</var><b>: </b><span>Assg Δ</span></span></div></blockquote></div></small></div><span class="nv">σ</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a'</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">a&#39;</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span></span></span></span><br><span><var>ω</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b, c</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>Δ', Γ✝</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>α✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b✝, c✝</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br><span><var>ρ</var><span class="hyp-type"><b>: </b><span>HList <span class="bp">Γ✝</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ✝</span> <span class="bp">→</span> Assg (List.append <span class="bp">Δ</span> [α]) <span class="bp">→</span> List α<span class="bp">✝</span></span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>Stmt m ω (α<span class="bp">✝</span> :: <span class="bp">Γ✝</span>) (List.append <span class="bp">Δ</span> [α]) true true Unit</span></span></span><br><span><var>ih</var><span class="hyp-type"><b>: </b><span><span class="bp">∀</span> (a : α) (ρ : HList (α<span class="bp">✝</span> :: <span class="bp">Γ✝</span>)) (σ : Assg <span class="bp">Δ</span>),
  StateT.run (Stmt.eval (a :: ρ) (S ((_ : List.append <span class="bp">Δ</span> [α] <span class="bp">=</span> List.append <span class="bp">Δ</span> [α]) <span class="bp">▸</span> s)) σ) a <span class="bp">=</span> <span class="k">do</span>
    <span class="k">let</span> x <span class="bp">←</span> Stmt.eval ρ s ((_ : List.append <span class="bp">Δ</span> [α] <span class="bp">=</span> List.append <span class="bp">Δ</span> [α]) <span class="bp">▸</span> Assg.extendBot a σ)
    <span class="k">match</span> x <span class="k">with</span>
      <span class="bp">|</span> (r, σ) <span class="bp">=&gt;</span>
        pure
          (r :: Assg.dropBot ((_ : List.append <span class="bp">Δ</span> [α] <span class="bp">=</span> List.append <span class="bp">Δ</span> [α]) <span class="bp">▸</span> σ),
            Assg.bot ((_ : List.append <span class="bp">Δ</span> [α] <span class="bp">=</span> List.append <span class="bp">Δ</span> [α]) <span class="bp">▸</span> σ))</span></span></span><br><span><var>σ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Δ</span></span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">sfor.nil</span></span><div class="goal-conclusion">StateT.run (Stmt.eval.go (a :: ρ) c<span class="bp">✝</span> b<span class="bp">✝</span> α<span class="bp">✝</span> (Stmt.bind (Stmt.expr <span class="k">fun</span> x x <span class="bp">=&gt;</span> get) (Stmt.mapAssg S.shadowSnd (S s))) σ [])
    a&#39; <span class="bp">=</span>
  <span class="k">do</span>
  <span class="k">let</span> x <span class="bp">←</span> Stmt.eval.go ρ c<span class="bp">✝</span> b<span class="bp">✝</span> α<span class="bp">✝</span> s (Assg.extendBot a&#39; σ) []
  pure (x.fst :: Assg.dropBot x.snd, Assg.bot x.snd)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Formal-lean-chke7" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span></span></span></span><br><span><var>ω</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b, c</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>Δ', Γ✝</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>α✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b✝, c✝</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br><span><var>ρ</var><span class="hyp-type"><b>: </b><span>HList <span class="bp">Γ✝</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ✝</span> <span class="bp">→</span> Assg (List.append <span class="bp">Δ</span> [α]) <span class="bp">→</span> List α<span class="bp">✝</span></span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>Stmt m ω (α<span class="bp">✝</span> :: <span class="bp">Γ✝</span>) (List.append <span class="bp">Δ</span> [α]) true true Unit</span></span></span><br><span><var>ih</var><span class="hyp-type"><b>: </b><span><span class="bp">∀</span> (a : α) (ρ : HList (α<span class="bp">✝</span> :: <span class="bp">Γ✝</span>)) (σ : Assg <span class="bp">Δ</span>),
  StateT.run (Stmt.eval (a :: ρ) (S ((_ : List.append <span class="bp">Δ</span> [α] <span class="bp">=</span> List.append <span class="bp">Δ</span> [α]) <span class="bp">▸</span> s)) σ) a <span class="bp">=</span> <span class="k">do</span>
    <span class="k">let</span> x <span class="bp">←</span> Stmt.eval ρ s ((_ : List.append <span class="bp">Δ</span> [α] <span class="bp">=</span> List.append <span class="bp">Δ</span> [α]) <span class="bp">▸</span> Assg.extendBot a σ)
    <span class="k">match</span> x <span class="k">with</span>
      <span class="bp">|</span> (r, σ) <span class="bp">=&gt;</span>
        pure
          (r :: Assg.dropBot ((_ : List.append <span class="bp">Δ</span> [α] <span class="bp">=</span> List.append <span class="bp">Δ</span> [α]) <span class="bp">▸</span> σ),
            Assg.bot ((_ : List.append <span class="bp">Δ</span> [α] <span class="bp">=</span> List.append <span class="bp">Δ</span> [α]) <span class="bp">▸</span> σ))</span></span></span><br><span><var>head✝</var><span class="hyp-type"><b>: </b><span>α<span class="bp">✝</span></span></span></span><br><span><var>tail✝</var><span class="hyp-type"><b>: </b><span>List α<span class="bp">✝</span></span></span></span><br><span><var>σ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Δ</span></span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br></div><label class="goal-separator" for="Formal-lean-chke7"><hr><span class="goal-name">sfor.cons</span></label><div class="goal-conclusion">StateT.run
    (Stmt.eval.go (a :: ρ) c<span class="bp">✝</span> b<span class="bp">✝</span> α<span class="bp">✝</span> (Stmt.bind (Stmt.expr <span class="k">fun</span> x x <span class="bp">=&gt;</span> get) (Stmt.mapAssg S.shadowSnd (S s))) σ
      (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>))
    a&#39; <span class="bp">=</span>
  <span class="k">do</span>
  <span class="k">let</span> x <span class="bp">←</span> Stmt.eval.go ρ c<span class="bp">✝</span> b<span class="bp">✝</span> α<span class="bp">✝</span> s (Assg.extendBot a&#39; σ) (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>)
  pure (x.fst :: Assg.dropBot x.snd, Assg.bot x.snd)</div></blockquote></div></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chke8" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chke8"><span class="alectryon-token"><span class="k">&lt;;&gt;</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span></span></span></span><br><span><var>ω</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b, c</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>Δ', Γ✝</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>α✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b✝, c✝</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br><span><var>ρ</var><span class="hyp-type"><b>: </b><span>HList <span class="bp">Γ✝</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ✝</span> <span class="bp">→</span> Assg (List.append <span class="bp">Δ</span> [α]) <span class="bp">→</span> List α<span class="bp">✝</span></span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>Stmt m ω (α<span class="bp">✝</span> :: <span class="bp">Γ✝</span>) (List.append <span class="bp">Δ</span> [α]) true true Unit</span></span></span><br><span><var>ih</var><span class="hyp-type"><b>: </b><span><span class="bp">∀</span> (a : α) (ρ : HList (α<span class="bp">✝</span> :: <span class="bp">Γ✝</span>)) (σ : Assg <span class="bp">Δ</span>),
  StateT.run (Stmt.eval (a :: ρ) (S ((_ : List.append <span class="bp">Δ</span> [α] <span class="bp">=</span> List.append <span class="bp">Δ</span> [α]) <span class="bp">▸</span> s)) σ) a <span class="bp">=</span> <span class="k">do</span>
    <span class="k">let</span> x <span class="bp">←</span> Stmt.eval ρ s ((_ : List.append <span class="bp">Δ</span> [α] <span class="bp">=</span> List.append <span class="bp">Δ</span> [α]) <span class="bp">▸</span> Assg.extendBot a σ)
    <span class="k">match</span> x <span class="k">with</span>
      <span class="bp">|</span> (r, σ) <span class="bp">=&gt;</span>
        pure
          (r :: Assg.dropBot ((_ : List.append <span class="bp">Δ</span> [α] <span class="bp">=</span> List.append <span class="bp">Δ</span> [α]) <span class="bp">▸</span> σ),
            Assg.bot ((_ : List.append <span class="bp">Δ</span> [α] <span class="bp">=</span> List.append <span class="bp">Δ</span> [α]) <span class="bp">▸</span> σ))</span></span></span><br><span><var>σ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Δ</span></span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">sfor.nil</span></span><div class="goal-conclusion">StateT.run (Stmt.eval.go (a :: ρ) c<span class="bp">✝</span> b<span class="bp">✝</span> α<span class="bp">✝</span> (Stmt.bind (Stmt.expr <span class="k">fun</span> x x <span class="bp">=&gt;</span> get) (Stmt.mapAssg S.shadowSnd (S s))) σ [])
    a&#39; <span class="bp">=</span>
  <span class="k">do</span>
  <span class="k">let</span> x <span class="bp">←</span> Stmt.eval.go ρ c<span class="bp">✝</span> b<span class="bp">✝</span> α<span class="bp">✝</span> s (Assg.extendBot a&#39; σ) []
  pure (x.fst :: Assg.dropBot x.snd, Assg.bot x.snd)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Formal-lean-chke9" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span></span></span></span><br><span><var>ω</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b, c</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>Δ', Γ✝</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>α✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b✝, c✝</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br><span><var>ρ</var><span class="hyp-type"><b>: </b><span>HList <span class="bp">Γ✝</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ✝</span> <span class="bp">→</span> Assg (List.append <span class="bp">Δ</span> [α]) <span class="bp">→</span> List α<span class="bp">✝</span></span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>Stmt m ω (α<span class="bp">✝</span> :: <span class="bp">Γ✝</span>) (List.append <span class="bp">Δ</span> [α]) true true Unit</span></span></span><br><span><var>ih</var><span class="hyp-type"><b>: </b><span><span class="bp">∀</span> (a : α) (ρ : HList (α<span class="bp">✝</span> :: <span class="bp">Γ✝</span>)) (σ : Assg <span class="bp">Δ</span>),
  StateT.run (Stmt.eval (a :: ρ) (S ((_ : List.append <span class="bp">Δ</span> [α] <span class="bp">=</span> List.append <span class="bp">Δ</span> [α]) <span class="bp">▸</span> s)) σ) a <span class="bp">=</span> <span class="k">do</span>
    <span class="k">let</span> x <span class="bp">←</span> Stmt.eval ρ s ((_ : List.append <span class="bp">Δ</span> [α] <span class="bp">=</span> List.append <span class="bp">Δ</span> [α]) <span class="bp">▸</span> Assg.extendBot a σ)
    <span class="k">match</span> x <span class="k">with</span>
      <span class="bp">|</span> (r, σ) <span class="bp">=&gt;</span>
        pure
          (r :: Assg.dropBot ((_ : List.append <span class="bp">Δ</span> [α] <span class="bp">=</span> List.append <span class="bp">Δ</span> [α]) <span class="bp">▸</span> σ),
            Assg.bot ((_ : List.append <span class="bp">Δ</span> [α] <span class="bp">=</span> List.append <span class="bp">Δ</span> [α]) <span class="bp">▸</span> σ))</span></span></span><br><span><var>head✝</var><span class="hyp-type"><b>: </b><span>α<span class="bp">✝</span></span></span></span><br><span><var>tail✝</var><span class="hyp-type"><b>: </b><span>List α<span class="bp">✝</span></span></span></span><br><span><var>σ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Δ</span></span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br></div><label class="goal-separator" for="Formal-lean-chke9"><hr><span class="goal-name">sfor.cons</span></label><div class="goal-conclusion">StateT.run
    (Stmt.eval.go (a :: ρ) c<span class="bp">✝</span> b<span class="bp">✝</span> α<span class="bp">✝</span> (Stmt.bind (Stmt.expr <span class="k">fun</span> x x <span class="bp">=&gt;</span> get) (Stmt.mapAssg S.shadowSnd (S s))) σ
      (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>))
    a&#39; <span class="bp">=</span>
  <span class="k">do</span>
  <span class="k">let</span> x <span class="bp">←</span> Stmt.eval.go ρ c<span class="bp">✝</span> b<span class="bp">✝</span> α<span class="bp">✝</span> s (Assg.extendBot a&#39; σ) (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>)
  pure (x.fst :: Assg.dropBot x.snd, Assg.bot x.snd)</div></blockquote></div></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chkea" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chkea"><span class="alectryon-token"><span class="k">aesop</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><span class="k">add</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">safe</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">cases</span></span><span class="alectryon-token"> Neut)</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chkeb" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chkeb"><span class="alectryon-token"><span class="bp">|</span> _ <span class="bp">=&gt;</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span></span></span></span><br><span><var>ω</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b, c</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>Δ', Γ✝</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>b✝, c✝</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>α✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Δ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br><span><var>ρ</var><span class="hyp-type"><b>: </b><span>HList <span class="bp">Γ✝</span></span></span></span><br><span><var>σ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Δ</span></span></span></span><br><span><var>e✝</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ✝</span> <span class="bp">→</span> Assg (List.append <span class="bp">Δ</span> [α]) <span class="bp">→</span> Bool</span></span></span><br><span><var>s₁✝, s₂✝</var><span class="hyp-type"><b>: </b><span>Stmt m ω <span class="bp">Γ✝</span> (List.append <span class="bp">Δ</span> [α]) b<span class="bp">✝</span> c<span class="bp">✝</span> α<span class="bp">✝</span></span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">ite</span></span><div class="goal-conclusion">StateT.run (Stmt.eval (a :: ρ) (S ((_ : List.append <span class="bp">Δ</span> [α] <span class="bp">=</span> List.append <span class="bp">Δ</span> [α]) <span class="bp">▸</span> Stmt.ite e<span class="bp">✝</span> s₁<span class="bp">✝</span> s₂<span class="bp">✝</span>)) σ) a <span class="bp">=</span> <span class="k">do</span>
  <span class="k">let</span> x <span class="bp">←</span> Stmt.eval ρ (Stmt.ite e<span class="bp">✝</span> s₁<span class="bp">✝</span> s₂<span class="bp">✝</span>) ((_ : List.append <span class="bp">Δ</span> [α] <span class="bp">=</span> List.append <span class="bp">Δ</span> [α]) <span class="bp">▸</span> Assg.extendBot a σ)
  <span class="k">match</span> x <span class="k">with</span>
    <span class="bp">|</span> (r, σ) <span class="bp">=&gt;</span>
      pure
        (r :: Assg.dropBot ((_ : List.append <span class="bp">Δ</span> [α] <span class="bp">=</span> List.append <span class="bp">Δ</span> [α]) <span class="bp">▸</span> σ),
          Assg.bot ((_ : List.append <span class="bp">Δ</span> [α] <span class="bp">=</span> List.append <span class="bp">Δ</span> [α]) <span class="bp">▸</span> σ))</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chkec" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chkec"><span class="alectryon-token"><span class="k">aesop</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">

</span><span class="alectryon-token"><span class="kd">theorem</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>HList.eq_nil</var><b>: </b><span>∀ (as : HList ∅), as = ∅</span></span></div></blockquote></div></small></div><span class="nv">HList.eq_nil</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>as</var><b>: </b><span>HList ∅</span></span></div></blockquote></div></small></div><span class="nv">as</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>HList</var><b>: </b><span>List (Type u_1) → Type u_1</span></span></div></blockquote></div></small></div>HList</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>∅</var><b>: </b><span>List (Type u_1)</span></span></div></blockquote></div></small></div><span class="bp">∅</span></span><span class="alectryon-token">) : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>as</var><b>: </b><span>HList ∅</span></span></div></blockquote></div></small></div><span class="nv">as</span></span><span class="alectryon-token"> <span class="bp">=</span> <span class="bp">∅</span> := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>rfl</var><b>: </b><span>∀ {α : Type u_1} {a : α}, a = a</span></span></div></blockquote></div></small></div>rfl</span><span class="alectryon-token">

</span><span class="alectryon-token"><span class="kn">attribute</span></span><span class="alectryon-token"> [</span><span class="alectryon-token"><span class="kn">local</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">simp</span></span><span class="alectryon-token">] </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ExceptT.run_bind</var><b>: </b><span>∀ {m : Type u_1 → Type u_2} {ε α β : Type u_1} {f : α → ExceptT ε m β} [inst : Monad m] (x : ExceptT ε m α),
  ExceptT.run (x &gt;&gt;= f) = do
    let x ← ExceptT.run x
    match x with
      | Except.ok x =&gt; ExceptT.run (f x)
      | Except.error e =&gt; pure (Except.error e)</span></span></div></blockquote></div></small></div>ExceptT.run_bind</span><span class="alectryon-token">

</span><span class="alectryon-token"><span class="kd">theorem</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>eval_L</var><b>: </b><span>∀ {m : Type → Type u_1} {ω : Type} {Γ Δ : List Type} {b c : Bool} {α : Type} {ρ : Assg Γ} {σ : Assg Δ} [inst : Monad m]
  [inst_1 : LawfulMonad m] (s : Stmt m ω Γ Δ b c α), Stmt.eval ρ (L s) σ = ExceptT.lift (Stmt.eval ρ s σ)</span></span></div></blockquote></div></small></div><span class="nv">eval_L</span></span><span class="alectryon-token"> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Monad</var><b>: </b><span>(Type ?u.632180 → Type ?u.632179) → Type (max (?u.632180 + 1) ?u.632179)</span></span></div></blockquote></div></small></div>Monad</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>Type → Type u_1</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token">] [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>LawfulMonad</var><b>: </b><span>(m : Type → Type u_1) → [inst : Monad m] → Prop</span></span></div></blockquote></div></small></div>LawfulMonad</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>Type → Type u_1</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token">] (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>Stmt m ω Γ Δ b c α</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt</var><b>: </b><span>(Type → Type u_1) → Type → List Type → List Type → Bool → Bool → Type → Type (max 1 u_1)</span></span></div></blockquote></div></small></div>Stmt</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>Type → Type u_1</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ω</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">ω</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Γ</var><b>: </b><span>List Type</span></span></div></blockquote></div></small></div><span class="nv">Γ</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Δ</var><b>: </b><span>List Type</span></span></div></blockquote></div></small></div><span class="nv">Δ</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>c</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div><span class="nv">c</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token">) : (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>L</var><b>: </b><span>{m : Type → Type u_1} →
  {ω : Type} →
    {Γ Δ : List Type} →
      {b c : Bool} → {α : Type} → [inst : Monad m] → Stmt m ω Γ Δ b c α → Stmt (ExceptT Unit m) ω Γ Δ b c α</span></span></div></blockquote></div></small></div>L</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>Stmt m ω Γ Δ b c α</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token">)<span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>eval</var><b>: </b><span>{m : Type → Type u_1} →
  {Γ : List Type} →
    {ω : Type} →
      {Δ : List Type} →
        {b c : Bool} → {α : Type} → [inst : Monad m] → Assg Γ → Stmt m ω Γ Δ b c α → Assg Δ → m (Neut ω α b c × Assg Δ)</span></span></div></blockquote></div></small></div><span class="na">eval</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ρ</var><b>: </b><span>Assg Γ</span></span></div></blockquote></div></small></div><span class="nv">ρ</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>σ</var><b>: </b><span>Assg Δ</span></span></div></blockquote></div></small></div><span class="nv">σ</span></span><span class="alectryon-token"> <span class="bp">=</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ExceptT.lift</var><b>: </b><span>{ε : Type} → {m : Type → Type u_1} → [inst : Monad m] → {α : Type} → m α → ExceptT ε m α</span></span></div></blockquote></div></small></div>ExceptT.lift</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>Stmt m ω Γ Δ b c α</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>eval</var><b>: </b><span>{m : Type → Type u_1} →
  {Γ : List Type} →
    {ω : Type} →
      {Δ : List Type} →
        {b c : Bool} → {α : Type} → [inst : Monad m] → Assg Γ → Stmt m ω Γ Δ b c α → Assg Δ → m (Neut ω α b c × Assg Δ)</span></span></div></blockquote></div></small></div>eval</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ρ</var><b>: </b><span>Assg Γ</span></span></div></blockquote></div></small></div><span class="nv">ρ</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>σ</var><b>: </b><span>Assg Δ</span></span></div></blockquote></div></small></div><span class="nv">σ</span></span><span class="alectryon-token">) := </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chked" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chked"><span class="alectryon-token"><span class="kd">by</span></span><span class="alectryon-token"></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>ω</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Γ, Δ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>b, c</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ρ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ</span></span></span></span><br><span><var>σ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Δ</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>Stmt m ω <span class="bp">Γ</span> <span class="bp">Δ</span> b c α</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Stmt.eval ρ (L s) σ <span class="bp">=</span> ExceptT.lift (Stmt.eval ρ s σ)</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chkee" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chkee"><span class="alectryon-token"><span class="k">apply</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ExceptT.ext</var><b>: </b><span>∀ {m : Type → Type u_1} {ε α : Type} [inst : Monad m] {x y : ExceptT ε m α}, ExceptT.run x = ExceptT.run y → x = y</span></span></div></blockquote></div></small></div>ExceptT.ext</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>ω</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Γ, Δ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>b, c</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ρ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ</span></span></span></span><br><span><var>σ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Δ</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>Stmt m ω <span class="bp">Γ</span> <span class="bp">Δ</span> b c α</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">h</span></span><div class="goal-conclusion">ExceptT.run (Stmt.eval ρ (L s) σ) <span class="bp">=</span> ExceptT.run (ExceptT.lift (Stmt.eval ρ s σ))</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chkef" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chkef"><span class="alectryon-token"><span class="k">induction</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>Stmt m ω Γ Δ b c α</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">with</span></span><span class="alectryon-token"></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>ω</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Γ, Δ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>b, c</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ρ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ</span></span></span></span><br><span><var>σ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Δ</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>Stmt m ω <span class="bp">Γ</span> <span class="bp">Δ</span> b c α</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">h</span></span><div class="goal-conclusion">ExceptT.run (Stmt.eval ρ (L s) σ) <span class="bp">=</span> ExceptT.run (ExceptT.lift (Stmt.eval ρ s σ))</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chkf0" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chkf0"><span class="alectryon-token"><span class="bp">|</span> sfor </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>Assg Γ✝ → Assg Δ✝ → List α✝</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>ω</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Γ, Δ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>b, c</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>Γ✝, Δ✝</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>α✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b✝, c✝</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ✝</span> <span class="bp">→</span> Assg <span class="bp">Δ✝</span> <span class="bp">→</span> List α<span class="bp">✝</span></span></span></span><br><span><var>s✝</var><span class="hyp-type"><b>: </b><span>Stmt m ω (α<span class="bp">✝</span> :: <span class="bp">Γ✝</span>) <span class="bp">Δ✝</span> true true Unit</span></span></span><br><span><var>ρ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ✝</span></span></span></span><br><span><var>σ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Δ✝</span></span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">h.sfor</span></span><div class="goal-conclusion">ExceptT.run (Stmt.eval ρ (L (Stmt.sfor e s<span class="bp">✝</span>)) σ) <span class="bp">=</span> ExceptT.run (ExceptT.lift (Stmt.eval ρ (Stmt.sfor e s<span class="bp">✝</span>) σ))</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
    </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chkf1" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chkf1"><span class="alectryon-token"><span class="k">simp</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">only</span></span><span class="alectryon-token"> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt.eval</var><b>: </b><span>{m : Type → Type ?u.632851} →
  {Γ : List Type} →
    {ω : Type} →
      {Δ : List Type} →
        {b c : Bool} → {α : Type} → [inst : Monad m] → Assg Γ → Stmt m ω Γ Δ b c α → Assg Δ → m (Neut ω α b c × Assg Δ)</span></span></div></blockquote></div></small></div>Stmt.eval</span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>L</var><b>: </b><span>{m : Type → Type ?u.633194} →
  {ω : Type} →
    {Γ Δ : List Type} →
      {b c : Bool} → {α : Type} → [inst : Monad m] → Stmt m ω Γ Δ b c α → Stmt (ExceptT Unit m) ω Γ Δ b c α</span></span></div></blockquote></div></small></div>L</span><span class="alectryon-token">]</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>ω</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Γ, Δ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>b, c</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>Γ✝, Δ✝</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>α✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b✝, c✝</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ✝</span> <span class="bp">→</span> Assg <span class="bp">Δ✝</span> <span class="bp">→</span> List α<span class="bp">✝</span></span></span></span><br><span><var>s✝</var><span class="hyp-type"><b>: </b><span>Stmt m ω (α<span class="bp">✝</span> :: <span class="bp">Γ✝</span>) <span class="bp">Δ✝</span> true true Unit</span></span></span><br><span><var>ρ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ✝</span></span></span></span><br><span><var>σ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Δ✝</span></span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">h.sfor</span></span><div class="goal-conclusion">ExceptT.run (Stmt.eval.go ρ c<span class="bp">✝</span> b<span class="bp">✝</span> α<span class="bp">✝</span> (L s<span class="bp">✝</span>) σ (e ρ σ)) <span class="bp">=</span>
  ExceptT.run (ExceptT.lift (Stmt.eval.go ρ c<span class="bp">✝</span> b<span class="bp">✝</span> α<span class="bp">✝</span> s<span class="bp">✝</span> σ (e ρ σ)))</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
    </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chkf2" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chkf2"><span class="alectryon-token"><span class="k">induction</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>Assg Γ✝ → Assg Δ✝ → List α✝</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ρ</var><b>: </b><span>Assg Γ✝</span></span></div></blockquote></div></small></div><span class="nv">ρ</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>σ</var><b>: </b><span>Assg Δ✝</span></span></div></blockquote></div></small></div><span class="nv">σ</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">generalizing</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>σ</var><b>: </b><span>Assg Δ✝</span></span></div></blockquote></div></small></div><span class="nv">σ</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>ω</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Γ, Δ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>b, c</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>Γ✝, Δ✝</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>α✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b✝, c✝</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ✝</span> <span class="bp">→</span> Assg <span class="bp">Δ✝</span> <span class="bp">→</span> List α<span class="bp">✝</span></span></span></span><br><span><var>s✝</var><span class="hyp-type"><b>: </b><span>Stmt m ω (α<span class="bp">✝</span> :: <span class="bp">Γ✝</span>) <span class="bp">Δ✝</span> true true Unit</span></span></span><br><span><var>ρ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ✝</span></span></span></span><br><span><var>σ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Δ✝</span></span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">h.sfor.nil</span></span><div class="goal-conclusion">ExceptT.run (Stmt.eval.go ρ c<span class="bp">✝</span> b<span class="bp">✝</span> α<span class="bp">✝</span> (L s<span class="bp">✝</span>) σ []) <span class="bp">=</span> ExceptT.run (ExceptT.lift (Stmt.eval.go ρ c<span class="bp">✝</span> b<span class="bp">✝</span> α<span class="bp">✝</span> s<span class="bp">✝</span> σ []))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Formal-lean-chkf3" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>ω</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Γ, Δ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>b, c</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>Γ✝, Δ✝</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>α✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b✝, c✝</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ✝</span> <span class="bp">→</span> Assg <span class="bp">Δ✝</span> <span class="bp">→</span> List α<span class="bp">✝</span></span></span></span><br><span><var>s✝</var><span class="hyp-type"><b>: </b><span>Stmt m ω (α<span class="bp">✝</span> :: <span class="bp">Γ✝</span>) <span class="bp">Δ✝</span> true true Unit</span></span></span><br><span><var>ρ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ✝</span></span></span></span><br><span><var>head✝</var><span class="hyp-type"><b>: </b><span>α<span class="bp">✝</span></span></span></span><br><span><var>tail✝</var><span class="hyp-type"><b>: </b><span>List α<span class="bp">✝</span></span></span></span><br><span><var>σ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Δ✝</span></span></span></span><br></div><label class="goal-separator" for="Formal-lean-chkf3"><hr><span class="goal-name">h.sfor.cons</span></label><div class="goal-conclusion">ExceptT.run (Stmt.eval.go ρ c<span class="bp">✝</span> b<span class="bp">✝</span> α<span class="bp">✝</span> (L s<span class="bp">✝</span>) σ (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>)) <span class="bp">=</span>
  ExceptT.run (ExceptT.lift (Stmt.eval.go ρ c<span class="bp">✝</span> b<span class="bp">✝</span> α<span class="bp">✝</span> s<span class="bp">✝</span> σ (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>)))</div></blockquote></div></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chkf4" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chkf4"><span class="alectryon-token"><span class="k">&lt;;&gt;</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>ω</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Γ, Δ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>b, c</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>Γ✝, Δ✝</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>α✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b✝, c✝</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ✝</span> <span class="bp">→</span> Assg <span class="bp">Δ✝</span> <span class="bp">→</span> List α<span class="bp">✝</span></span></span></span><br><span><var>s✝</var><span class="hyp-type"><b>: </b><span>Stmt m ω (α<span class="bp">✝</span> :: <span class="bp">Γ✝</span>) <span class="bp">Δ✝</span> true true Unit</span></span></span><br><span><var>ρ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ✝</span></span></span></span><br><span><var>σ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Δ✝</span></span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">h.sfor.nil</span></span><div class="goal-conclusion">ExceptT.run (Stmt.eval.go ρ c<span class="bp">✝</span> b<span class="bp">✝</span> α<span class="bp">✝</span> (L s<span class="bp">✝</span>) σ []) <span class="bp">=</span> ExceptT.run (ExceptT.lift (Stmt.eval.go ρ c<span class="bp">✝</span> b<span class="bp">✝</span> α<span class="bp">✝</span> s<span class="bp">✝</span> σ []))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Formal-lean-chkf5" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>ω</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Γ, Δ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>b, c</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>Γ✝, Δ✝</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>α✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b✝, c✝</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ✝</span> <span class="bp">→</span> Assg <span class="bp">Δ✝</span> <span class="bp">→</span> List α<span class="bp">✝</span></span></span></span><br><span><var>s✝</var><span class="hyp-type"><b>: </b><span>Stmt m ω (α<span class="bp">✝</span> :: <span class="bp">Γ✝</span>) <span class="bp">Δ✝</span> true true Unit</span></span></span><br><span><var>ρ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ✝</span></span></span></span><br><span><var>head✝</var><span class="hyp-type"><b>: </b><span>α<span class="bp">✝</span></span></span></span><br><span><var>tail✝</var><span class="hyp-type"><b>: </b><span>List α<span class="bp">✝</span></span></span></span><br><span><var>σ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Δ✝</span></span></span></span><br></div><label class="goal-separator" for="Formal-lean-chkf5"><hr><span class="goal-name">h.sfor.cons</span></label><div class="goal-conclusion">ExceptT.run (Stmt.eval.go ρ c<span class="bp">✝</span> b<span class="bp">✝</span> α<span class="bp">✝</span> (L s<span class="bp">✝</span>) σ (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>)) <span class="bp">=</span>
  ExceptT.run (ExceptT.lift (Stmt.eval.go ρ c<span class="bp">✝</span> b<span class="bp">✝</span> α<span class="bp">✝</span> s<span class="bp">✝</span> σ (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>)))</div></blockquote></div></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chkf6" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chkf6"><span class="alectryon-token"><span class="k">aesop</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chkf7" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chkf7"><span class="alectryon-token"><span class="bp">|</span> _ <span class="bp">=&gt;</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>ω</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Γ, Δ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>b, c</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>Γ✝, Δ✝</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>b✝, c✝</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>x✝</var><span class="hyp-type"><b>: </b><span>Fin (List.length <span class="bp">Δ✝</span>)</span></span></span><br><span><var>e✝</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ✝</span> <span class="bp">→</span> Assg <span class="bp">Δ✝</span> <span class="bp">→</span> List.get <span class="bp">Δ✝</span> x<span class="bp">✝</span></span></span></span><br><span><var>ρ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ✝</span></span></span></span><br><span><var>σ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Δ✝</span></span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">h.assg</span></span><div class="goal-conclusion">ExceptT.run (Stmt.eval ρ (L (Stmt.assg x<span class="bp">✝</span> e<span class="bp">✝</span>)) σ) <span class="bp">=</span> ExceptT.run (ExceptT.lift (Stmt.eval ρ (Stmt.assg x<span class="bp">✝</span> e<span class="bp">✝</span>) σ))</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chkf8" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chkf8"><span class="alectryon-token"><span class="k">aesop</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><span class="k">add</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">safe</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">cases</span></span><span class="alectryon-token"> Neut)</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">

</span><span class="alectryon-token"><span class="kd">theorem</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>eval_B</var><b>: </b><span>∀ {m : Type → Type u_1} {ω : Type} {Γ Δ : List Type} {b c : Bool} {α : Type} {ρ : Assg Γ} {σ : Assg Δ} [inst : Monad m]
  [inst_1 : LawfulMonad m] (s : Stmt m ω Γ Δ b c α),
  Stmt.eval ρ (B s) σ = do
    let x ← ExceptT.lift (Stmt.eval ρ s σ)
    match b, c, x with
      | b, c, (Neut.ret o, σ) =&gt; pure (Neut.ret o, σ)
      | b, c, (Neut.val a, σ) =&gt; pure (Neut.val a, σ)
      | b, .(true), (Neut.rcont, σ) =&gt; pure (Neut.rcont, σ)
      | .(true), c, (Neut.rbreak, snd) =&gt; throw ()</span></span></div></blockquote></div></small></div><span class="nv">eval_B</span></span><span class="alectryon-token"> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Monad</var><b>: </b><span>(Type ?u.666038 → Type ?u.666037) → Type (max (?u.666038 + 1) ?u.666037)</span></span></div></blockquote></div></small></div>Monad</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>Type → Type u_1</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token">] [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>LawfulMonad</var><b>: </b><span>(m : Type ?u.665935 → Type ?u.665934) → [inst : Monad m] → Prop</span></span></div></blockquote></div></small></div>LawfulMonad</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>Type → Type u_1</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token">] (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>Stmt m ω Γ Δ b c α</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt</var><b>: </b><span>(Type → Type ?u.665969) → Type → List Type → List Type → Bool → Bool → Type → Type (max 1 ?u.665969)</span></span></div></blockquote></div></small></div>Stmt</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>Type → Type u_1</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ω</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">ω</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Γ</var><b>: </b><span>List Type</span></span></div></blockquote></div></small></div><span class="nv">Γ</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Δ</var><b>: </b><span>List Type</span></span></div></blockquote></div></small></div><span class="nv">Δ</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>c</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div><span class="nv">c</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token">) : (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>B</var><b>: </b><span>{m : Type → Type u_1} →
  {ω : Type} →
    {Γ Δ : List Type} →
      {b c : Bool} → {α : Type} → [inst : Monad m] → Stmt m ω Γ Δ b c α → Stmt (ExceptT Unit m) ω Γ Δ false c α</span></span></div></blockquote></div></small></div>B</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>Stmt m ω Γ Δ b c α</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token">)<span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>eval</var><b>: </b><span>{m : Type → Type u_1} →
  {Γ : List Type} →
    {ω : Type} →
      {Δ : List Type} →
        {b c : Bool} → {α : Type} → [inst : Monad m] → Assg Γ → Stmt m ω Γ Δ b c α → Assg Δ → m (Neut ω α b c × Assg Δ)</span></span></div></blockquote></div></small></div><span class="na">eval</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ρ</var><b>: </b><span>Assg Γ</span></span></div></blockquote></div></small></div><span class="nv">ρ</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>σ</var><b>: </b><span>Assg Δ</span></span></div></blockquote></div></small></div><span class="nv">σ</span></span><span class="alectryon-token"> <span class="bp">=</span> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ExceptT.lift</var><b>: </b><span>{ε : Type} → {m : Type → Type u_1} → [inst : Monad m] → {α : Type} → m α → ExceptT ε m α</span></span></div></blockquote></div></small></div>ExceptT.lift</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>Stmt m ω Γ Δ b c α</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>eval</var><b>: </b><span>{m : Type → Type u_1} →
  {Γ : List Type} →
    {ω : Type} →
      {Δ : List Type} →
        {b c : Bool} → {α : Type} → [inst : Monad m] → Assg Γ → Stmt m ω Γ Δ b c α → Assg Δ → m (Neut ω α b c × Assg Δ)</span></span></div></blockquote></div></small></div>eval</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ρ</var><b>: </b><span>Assg Γ</span></span></div></blockquote></div></small></div><span class="nv">ρ</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>σ</var><b>: </b><span>Assg Δ</span></span></div></blockquote></div></small></div><span class="nv">σ</span></span><span class="alectryon-token">) <span class="bp">&gt;&gt;=</span> </span><span class="alectryon-token"><span class="k">fun</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>Neut ω α b c × Assg Δ</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><span class="k">match</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><span class="k">generalizing</span></span><span class="alectryon-token"> := </span><span class="alectryon-token"><span class="k">false</span></span><span class="alectryon-token">) </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>Neut ω α b c × Assg Δ</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">with</span></span><span class="alectryon-token">
    <span class="bp">|</span> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Neut.ret</var><b>: </b><span>{ω α : Type} → {b c : Bool} → ω → Neut ω α b c</span></span></div></blockquote></div></small></div>Neut.ret</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>o</var><b>: </b><span>ω</span></span></div></blockquote></div></small></div><span class="nv">o</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>σ</var><b>: </b><span>Assg Δ</span></span></div></blockquote></div></small></div><span class="nv">σ</span></span><span class="alectryon-token">) <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>pure</var><b>: </b><span>{f : Type → Type u_1} → [self : Pure f] → {α : Type} → α → f α</span></span></div></blockquote></div></small></div>pure</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Neut.ret</var><b>: </b><span>{ω α : Type} → {b c : Bool} → ω → Neut ω α b c</span></span></div></blockquote></div></small></div>Neut.ret</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>o</var><b>: </b><span>ω</span></span></div></blockquote></div></small></div><span class="nv">o</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>σ</var><b>: </b><span>Assg Δ</span></span></div></blockquote></div></small></div><span class="nv">σ</span></span><span class="alectryon-token">)
    <span class="bp">|</span> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Neut.val</var><b>: </b><span>{ω α : Type} → {b c : Bool} → α → Neut ω α b c</span></span></div></blockquote></div></small></div>Neut.val</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>σ</var><b>: </b><span>Assg Δ</span></span></div></blockquote></div></small></div><span class="nv">σ</span></span><span class="alectryon-token">) <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>pure</var><b>: </b><span>{f : Type → Type u_1} → [self : Pure f] → {α : Type} → α → f α</span></span></div></blockquote></div></small></div>pure</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Neut.val</var><b>: </b><span>{ω α : Type} → {b c : Bool} → α → Neut ω α b c</span></span></div></blockquote></div></small></div>Neut.val</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>σ</var><b>: </b><span>Assg Δ</span></span></div></blockquote></div></small></div><span class="nv">σ</span></span><span class="alectryon-token">)
    <span class="bp">|</span> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Neut.rcont</var><b>: </b><span>{ω α : Type} → {b : Bool} → Neut ω α b true</span></span></div></blockquote></div></small></div>Neut.rcont</span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>σ</var><b>: </b><span>Assg Δ</span></span></div></blockquote></div></small></div><span class="nv">σ</span></span><span class="alectryon-token">) <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>pure</var><b>: </b><span>{f : Type → Type u_1} → [self : Pure f] → {α : Type} → α → f α</span></span></div></blockquote></div></small></div>pure</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Neut.rcont</var><b>: </b><span>{ω α : Type} → {b : Bool} → Neut ω α b true</span></span></div></blockquote></div></small></div>Neut.rcont</span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>σ</var><b>: </b><span>Assg Δ</span></span></div></blockquote></div></small></div><span class="nv">σ</span></span><span class="alectryon-token">)
    <span class="bp">|</span> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Neut.rbreak</var><b>: </b><span>{ω α : Type} → {c : Bool} → Neut ω α true c</span></span></div></blockquote></div></small></div>Neut.rbreak</span><span class="alectryon-token">, _) <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>throw</var><b>: </b><span>{ε : Type} → {m : Type → Type u_1} → [self : MonadExcept ε m] → {α : Type} → ε → m α</span></span></div></blockquote></div></small></div>throw</span><span class="alectryon-token"> () : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ExceptT</var><b>: </b><span>Type → (Type → Type u_1) → Type → Type u_1</span></span></div></blockquote></div></small></div>ExceptT</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Unit</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Unit</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>Type → Type u_1</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Neut</var><b>: </b><span>Type → Type → Bool → Bool → Type</span></span></div></blockquote></div></small></div>Neut</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ω</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">ω</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>false</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div>false</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>c</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div><span class="nv">c</span></span><span class="alectryon-token"> <span class="bp">×</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Assg</var><b>: </b><span>List Type → Type</span></span></div></blockquote></div></small></div>Assg</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Δ</var><b>: </b><span>List Type</span></span></div></blockquote></div></small></div><span class="nv">Δ</span></span><span class="alectryon-token">)) := </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chkf9" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chkf9"><span class="alectryon-token"><span class="kd">by</span></span><span class="alectryon-token"></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>ω</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Γ, Δ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>b, c</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ρ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ</span></span></span></span><br><span><var>σ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Δ</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>Stmt m ω <span class="bp">Γ</span> <span class="bp">Δ</span> b c α</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Stmt.eval ρ (B s) σ <span class="bp">=</span> <span class="k">do</span>
  <span class="k">let</span> x <span class="bp">←</span> ExceptT.lift (Stmt.eval ρ s σ)
  <span class="k">match</span> b, c, x <span class="k">with</span>
    <span class="bp">|</span> b, c, (Neut.ret o, σ) <span class="bp">=&gt;</span> pure (Neut.ret o, σ)
    <span class="bp">|</span> b, c, (Neut.val a, σ) <span class="bp">=&gt;</span> pure (Neut.val a, σ)
    <span class="bp">|</span> b, <span class="bp">.</span>(true), (Neut.rcont, σ) <span class="bp">=&gt;</span> pure (Neut.rcont, σ)
    <span class="bp">|</span> <span class="bp">.</span>(true), c, (Neut.rbreak, snd) <span class="bp">=&gt;</span> throw ()</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chkfa" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chkfa"><span class="alectryon-token"><span class="k">apply</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ExceptT.ext</var><b>: </b><span>∀ {m : Type → Type u_1} {ε α : Type} [inst : Monad m] {x y : ExceptT ε m α}, ExceptT.run x = ExceptT.run y → x = y</span></span></div></blockquote></div></small></div>ExceptT.ext</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>ω</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Γ, Δ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>b, c</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ρ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ</span></span></span></span><br><span><var>σ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Δ</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>Stmt m ω <span class="bp">Γ</span> <span class="bp">Δ</span> b c α</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">h</span></span><div class="goal-conclusion">ExceptT.run (Stmt.eval ρ (B s) σ) <span class="bp">=</span>
  ExceptT.run <span class="k">do</span>
    <span class="k">let</span> x <span class="bp">←</span> ExceptT.lift (Stmt.eval ρ s σ)
    <span class="k">match</span> b, c, x <span class="k">with</span>
      <span class="bp">|</span> b, c, (Neut.ret o, σ) <span class="bp">=&gt;</span> pure (Neut.ret o, σ)
      <span class="bp">|</span> b, c, (Neut.val a, σ) <span class="bp">=&gt;</span> pure (Neut.val a, σ)
      <span class="bp">|</span> b, <span class="bp">.</span>(true), (Neut.rcont, σ) <span class="bp">=&gt;</span> pure (Neut.rcont, σ)
      <span class="bp">|</span> <span class="bp">.</span>(true), c, (Neut.rbreak, snd) <span class="bp">=&gt;</span> throw ()</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chkfb" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chkfb"><span class="alectryon-token"><span class="k">induction</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>Stmt m ω Γ Δ b c α</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">with</span></span><span class="alectryon-token"></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>ω</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Γ, Δ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>b, c</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ρ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ</span></span></span></span><br><span><var>σ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Δ</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>Stmt m ω <span class="bp">Γ</span> <span class="bp">Δ</span> b c α</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">h</span></span><div class="goal-conclusion">ExceptT.run (Stmt.eval ρ (B s) σ) <span class="bp">=</span>
  ExceptT.run <span class="k">do</span>
    <span class="k">let</span> x <span class="bp">←</span> ExceptT.lift (Stmt.eval ρ s σ)
    <span class="k">match</span> b, c, x <span class="k">with</span>
      <span class="bp">|</span> b, c, (Neut.ret o, σ) <span class="bp">=&gt;</span> pure (Neut.ret o, σ)
      <span class="bp">|</span> b, c, (Neut.val a, σ) <span class="bp">=&gt;</span> pure (Neut.val a, σ)
      <span class="bp">|</span> b, <span class="bp">.</span>(true), (Neut.rcont, σ) <span class="bp">=&gt;</span> pure (Neut.rcont, σ)
      <span class="bp">|</span> <span class="bp">.</span>(true), c, (Neut.rbreak, snd) <span class="bp">=&gt;</span> throw ()</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chkfc" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chkfc"><span class="alectryon-token"><span class="bp">|</span> sfor </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>Assg Γ✝ → Assg Δ✝ → List α✝</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>ω</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Γ, Δ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>b, c</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>Γ✝, Δ✝</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>α✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b✝, c✝</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ✝</span> <span class="bp">→</span> Assg <span class="bp">Δ✝</span> <span class="bp">→</span> List α<span class="bp">✝</span></span></span></span><br><span><var>s✝</var><span class="hyp-type"><b>: </b><span>Stmt m ω (α<span class="bp">✝</span> :: <span class="bp">Γ✝</span>) <span class="bp">Δ✝</span> true true Unit</span></span></span><br><span><var>ρ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ✝</span></span></span></span><br><span><var>σ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Δ✝</span></span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">h.sfor</span></span><div class="goal-conclusion">ExceptT.run (Stmt.eval ρ (B (Stmt.sfor e s<span class="bp">✝</span>)) σ) <span class="bp">=</span>
  ExceptT.run <span class="k">do</span>
    <span class="k">let</span> x <span class="bp">←</span> ExceptT.lift (Stmt.eval ρ (Stmt.sfor e s<span class="bp">✝</span>) σ)
    <span class="k">match</span> b<span class="bp">✝</span>, c<span class="bp">✝</span>, x <span class="k">with</span>
      <span class="bp">|</span> b, c, (Neut.ret o, σ) <span class="bp">=&gt;</span> pure (Neut.ret o, σ)
      <span class="bp">|</span> b, c, (Neut.val a, σ) <span class="bp">=&gt;</span> pure (Neut.val a, σ)
      <span class="bp">|</span> b, <span class="bp">.</span>(true), (Neut.rcont, σ) <span class="bp">=&gt;</span> pure (Neut.rcont, σ)
      <span class="bp">|</span> <span class="bp">.</span>(true), c, (Neut.rbreak, snd) <span class="bp">=&gt;</span> throw ()</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
    </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chkfd" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chkfd"><span class="alectryon-token"><span class="k">simp</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">only</span></span><span class="alectryon-token"> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt.eval</var><b>: </b><span>{m : Type → Type ?u.668260} →
  {Γ : List Type} →
    {ω : Type} →
      {Δ : List Type} →
        {b c : Bool} → {α : Type} → [inst : Monad m] → Assg Γ → Stmt m ω Γ Δ b c α → Assg Δ → m (Neut ω α b c × Assg Δ)</span></span></div></blockquote></div></small></div>Stmt.eval</span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>B</var><b>: </b><span>{m : Type → Type ?u.668603} →
  {ω : Type} →
    {Γ Δ : List Type} →
      {b c : Bool} → {α : Type} → [inst : Monad m] → Stmt m ω Γ Δ b c α → Stmt (ExceptT Unit m) ω Γ Δ false c α</span></span></div></blockquote></div></small></div>B</span><span class="alectryon-token">]</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>ω</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Γ, Δ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>b, c</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>Γ✝, Δ✝</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>α✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b✝, c✝</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ✝</span> <span class="bp">→</span> Assg <span class="bp">Δ✝</span> <span class="bp">→</span> List α<span class="bp">✝</span></span></span></span><br><span><var>s✝</var><span class="hyp-type"><b>: </b><span>Stmt m ω (α<span class="bp">✝</span> :: <span class="bp">Γ✝</span>) <span class="bp">Δ✝</span> true true Unit</span></span></span><br><span><var>ρ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ✝</span></span></span></span><br><span><var>σ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Δ✝</span></span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">h.sfor</span></span><div class="goal-conclusion">ExceptT.run (Stmt.eval.go ρ c<span class="bp">✝</span> false α<span class="bp">✝</span> (L s<span class="bp">✝</span>) σ (e ρ σ)) <span class="bp">=</span>
  ExceptT.run <span class="k">do</span>
    <span class="k">let</span> x <span class="bp">←</span> ExceptT.lift (Stmt.eval.go ρ c<span class="bp">✝</span> b<span class="bp">✝</span> α<span class="bp">✝</span> s<span class="bp">✝</span> σ (e ρ σ))
    <span class="k">match</span> b<span class="bp">✝</span>, c<span class="bp">✝</span>, x <span class="k">with</span>
      <span class="bp">|</span> b, c, (Neut.ret o, σ) <span class="bp">=&gt;</span> pure (Neut.ret o, σ)
      <span class="bp">|</span> b, c, (Neut.val a, σ) <span class="bp">=&gt;</span> pure (Neut.val a, σ)
      <span class="bp">|</span> b, <span class="bp">.</span>(true), (Neut.rcont, σ) <span class="bp">=&gt;</span> pure (Neut.rcont, σ)
      <span class="bp">|</span> <span class="bp">.</span>(true), c, (Neut.rbreak, snd) <span class="bp">=&gt;</span> throw ()</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
    </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chkfe" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chkfe"><span class="alectryon-token"><span class="k">induction</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>Assg Γ✝ → Assg Δ✝ → List α✝</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ρ</var><b>: </b><span>Assg Γ✝</span></span></div></blockquote></div></small></div><span class="nv">ρ</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>σ</var><b>: </b><span>Assg Δ✝</span></span></div></blockquote></div></small></div><span class="nv">σ</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">generalizing</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>σ</var><b>: </b><span>Assg Δ✝</span></span></div></blockquote></div></small></div><span class="nv">σ</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>ω</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Γ, Δ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>b, c</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>Γ✝, Δ✝</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>α✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b✝, c✝</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ✝</span> <span class="bp">→</span> Assg <span class="bp">Δ✝</span> <span class="bp">→</span> List α<span class="bp">✝</span></span></span></span><br><span><var>s✝</var><span class="hyp-type"><b>: </b><span>Stmt m ω (α<span class="bp">✝</span> :: <span class="bp">Γ✝</span>) <span class="bp">Δ✝</span> true true Unit</span></span></span><br><span><var>ρ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ✝</span></span></span></span><br><span><var>σ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Δ✝</span></span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">h.sfor.nil</span></span><div class="goal-conclusion">ExceptT.run (Stmt.eval.go ρ c<span class="bp">✝</span> false α<span class="bp">✝</span> (L s<span class="bp">✝</span>) σ []) <span class="bp">=</span>
  ExceptT.run <span class="k">do</span>
    <span class="k">let</span> x <span class="bp">←</span> ExceptT.lift (Stmt.eval.go ρ c<span class="bp">✝</span> b<span class="bp">✝</span> α<span class="bp">✝</span> s<span class="bp">✝</span> σ [])
    <span class="k">match</span> b<span class="bp">✝</span>, c<span class="bp">✝</span>, x <span class="k">with</span>
      <span class="bp">|</span> b, c, (Neut.ret o, σ) <span class="bp">=&gt;</span> pure (Neut.ret o, σ)
      <span class="bp">|</span> b, c, (Neut.val a, σ) <span class="bp">=&gt;</span> pure (Neut.val a, σ)
      <span class="bp">|</span> b, <span class="bp">.</span>(true), (Neut.rcont, σ) <span class="bp">=&gt;</span> pure (Neut.rcont, σ)
      <span class="bp">|</span> <span class="bp">.</span>(true), c, (Neut.rbreak, snd) <span class="bp">=&gt;</span> throw ()</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Formal-lean-chkff" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>ω</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Γ, Δ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>b, c</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>Γ✝, Δ✝</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>α✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b✝, c✝</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ✝</span> <span class="bp">→</span> Assg <span class="bp">Δ✝</span> <span class="bp">→</span> List α<span class="bp">✝</span></span></span></span><br><span><var>s✝</var><span class="hyp-type"><b>: </b><span>Stmt m ω (α<span class="bp">✝</span> :: <span class="bp">Γ✝</span>) <span class="bp">Δ✝</span> true true Unit</span></span></span><br><span><var>ρ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ✝</span></span></span></span><br><span><var>head✝</var><span class="hyp-type"><b>: </b><span>α<span class="bp">✝</span></span></span></span><br><span><var>tail✝</var><span class="hyp-type"><b>: </b><span>List α<span class="bp">✝</span></span></span></span><br><span><var>σ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Δ✝</span></span></span></span><br></div><label class="goal-separator" for="Formal-lean-chkff"><hr><span class="goal-name">h.sfor.cons</span></label><div class="goal-conclusion">ExceptT.run (Stmt.eval.go ρ c<span class="bp">✝</span> false α<span class="bp">✝</span> (L s<span class="bp">✝</span>) σ (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>)) <span class="bp">=</span>
  ExceptT.run <span class="k">do</span>
    <span class="k">let</span> x <span class="bp">←</span> ExceptT.lift (Stmt.eval.go ρ c<span class="bp">✝</span> b<span class="bp">✝</span> α<span class="bp">✝</span> s<span class="bp">✝</span> σ (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>))
    <span class="k">match</span> b<span class="bp">✝</span>, c<span class="bp">✝</span>, x <span class="k">with</span>
      <span class="bp">|</span> b, c, (Neut.ret o, σ) <span class="bp">=&gt;</span> pure (Neut.ret o, σ)
      <span class="bp">|</span> b, c, (Neut.val a, σ) <span class="bp">=&gt;</span> pure (Neut.val a, σ)
      <span class="bp">|</span> b, <span class="bp">.</span>(true), (Neut.rcont, σ) <span class="bp">=&gt;</span> pure (Neut.rcont, σ)
      <span class="bp">|</span> <span class="bp">.</span>(true), c, (Neut.rbreak, snd) <span class="bp">=&gt;</span> throw ()</div></blockquote></div></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk100" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk100"><span class="alectryon-token"><span class="k">&lt;;&gt;</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>ω</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Γ, Δ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>b, c</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>Γ✝, Δ✝</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>α✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b✝, c✝</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ✝</span> <span class="bp">→</span> Assg <span class="bp">Δ✝</span> <span class="bp">→</span> List α<span class="bp">✝</span></span></span></span><br><span><var>s✝</var><span class="hyp-type"><b>: </b><span>Stmt m ω (α<span class="bp">✝</span> :: <span class="bp">Γ✝</span>) <span class="bp">Δ✝</span> true true Unit</span></span></span><br><span><var>ρ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ✝</span></span></span></span><br><span><var>σ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Δ✝</span></span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">h.sfor.nil</span></span><div class="goal-conclusion">ExceptT.run (Stmt.eval.go ρ c<span class="bp">✝</span> false α<span class="bp">✝</span> (L s<span class="bp">✝</span>) σ []) <span class="bp">=</span>
  ExceptT.run <span class="k">do</span>
    <span class="k">let</span> x <span class="bp">←</span> ExceptT.lift (Stmt.eval.go ρ c<span class="bp">✝</span> b<span class="bp">✝</span> α<span class="bp">✝</span> s<span class="bp">✝</span> σ [])
    <span class="k">match</span> b<span class="bp">✝</span>, c<span class="bp">✝</span>, x <span class="k">with</span>
      <span class="bp">|</span> b, c, (Neut.ret o, σ) <span class="bp">=&gt;</span> pure (Neut.ret o, σ)
      <span class="bp">|</span> b, c, (Neut.val a, σ) <span class="bp">=&gt;</span> pure (Neut.val a, σ)
      <span class="bp">|</span> b, <span class="bp">.</span>(true), (Neut.rcont, σ) <span class="bp">=&gt;</span> pure (Neut.rcont, σ)
      <span class="bp">|</span> <span class="bp">.</span>(true), c, (Neut.rbreak, snd) <span class="bp">=&gt;</span> throw ()</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Formal-lean-chk101" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>ω</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Γ, Δ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>b, c</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>Γ✝, Δ✝</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>α✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b✝, c✝</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ✝</span> <span class="bp">→</span> Assg <span class="bp">Δ✝</span> <span class="bp">→</span> List α<span class="bp">✝</span></span></span></span><br><span><var>s✝</var><span class="hyp-type"><b>: </b><span>Stmt m ω (α<span class="bp">✝</span> :: <span class="bp">Γ✝</span>) <span class="bp">Δ✝</span> true true Unit</span></span></span><br><span><var>ρ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ✝</span></span></span></span><br><span><var>head✝</var><span class="hyp-type"><b>: </b><span>α<span class="bp">✝</span></span></span></span><br><span><var>tail✝</var><span class="hyp-type"><b>: </b><span>List α<span class="bp">✝</span></span></span></span><br><span><var>σ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Δ✝</span></span></span></span><br></div><label class="goal-separator" for="Formal-lean-chk101"><hr><span class="goal-name">h.sfor.cons</span></label><div class="goal-conclusion">ExceptT.run (Stmt.eval.go ρ c<span class="bp">✝</span> false α<span class="bp">✝</span> (L s<span class="bp">✝</span>) σ (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>)) <span class="bp">=</span>
  ExceptT.run <span class="k">do</span>
    <span class="k">let</span> x <span class="bp">←</span> ExceptT.lift (Stmt.eval.go ρ c<span class="bp">✝</span> b<span class="bp">✝</span> α<span class="bp">✝</span> s<span class="bp">✝</span> σ (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>))
    <span class="k">match</span> b<span class="bp">✝</span>, c<span class="bp">✝</span>, x <span class="k">with</span>
      <span class="bp">|</span> b, c, (Neut.ret o, σ) <span class="bp">=&gt;</span> pure (Neut.ret o, σ)
      <span class="bp">|</span> b, c, (Neut.val a, σ) <span class="bp">=&gt;</span> pure (Neut.val a, σ)
      <span class="bp">|</span> b, <span class="bp">.</span>(true), (Neut.rcont, σ) <span class="bp">=&gt;</span> pure (Neut.rcont, σ)
      <span class="bp">|</span> <span class="bp">.</span>(true), c, (Neut.rbreak, snd) <span class="bp">=&gt;</span> throw ()</div></blockquote></div></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk102" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk102"><span class="alectryon-token"><span class="k">aesop</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><span class="k">add</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">norm</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">simp</span></span><span class="alectryon-token"> eval_L)</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk103" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk103"><span class="alectryon-token"><span class="bp">|</span> _ <span class="bp">=&gt;</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>ω</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Γ, Δ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>b, c</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>Γ✝, Δ✝</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>b✝, c✝</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>x✝</var><span class="hyp-type"><b>: </b><span>Fin (List.length <span class="bp">Δ✝</span>)</span></span></span><br><span><var>e✝</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ✝</span> <span class="bp">→</span> Assg <span class="bp">Δ✝</span> <span class="bp">→</span> List.get <span class="bp">Δ✝</span> x<span class="bp">✝</span></span></span></span><br><span><var>ρ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ✝</span></span></span></span><br><span><var>σ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Δ✝</span></span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">h.assg</span></span><div class="goal-conclusion">ExceptT.run (Stmt.eval ρ (B (Stmt.assg x<span class="bp">✝</span> e<span class="bp">✝</span>)) σ) <span class="bp">=</span>
  ExceptT.run <span class="k">do</span>
    <span class="k">let</span> x <span class="bp">←</span> ExceptT.lift (Stmt.eval ρ (Stmt.assg x<span class="bp">✝</span> e<span class="bp">✝</span>) σ)
    <span class="k">match</span> b<span class="bp">✝</span>, c<span class="bp">✝</span>, x <span class="k">with</span>
      <span class="bp">|</span> b, c, (Neut.ret o, σ) <span class="bp">=&gt;</span> pure (Neut.ret o, σ)
      <span class="bp">|</span> b, c, (Neut.val a, σ) <span class="bp">=&gt;</span> pure (Neut.val a, σ)
      <span class="bp">|</span> b, <span class="bp">.</span>(true), (Neut.rcont, σ) <span class="bp">=&gt;</span> pure (Neut.rcont, σ)
      <span class="bp">|</span> <span class="bp">.</span>(true), c, (Neut.rbreak, snd) <span class="bp">=&gt;</span> throw ()</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk104" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk104"><span class="alectryon-token"><span class="k">aesop</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><span class="k">erase</span></span><span class="alectryon-token"> Aesop.BuiltinRules.destructProducts)</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">

<span class="bp">@</span>[</span><span class="alectryon-token"><span class="k">simp</span></span><span class="alectryon-token">] </span><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>throwOnContinue</var><b>: </b><span>{m : Type → Type u_1} →
  {ω α : Type} →
    {c : Bool} →
      {Δ : List Type} → [inst : Monad m] → Neut ω α false c × Assg Δ → ExceptT Unit m (Neut ω α false false × Assg Δ)</span></span></div></blockquote></div></small></div><span class="nv">throwOnContinue</span></span><span class="alectryon-token"> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Monad</var><b>: </b><span>(Type ?u.788677 → Type ?u.788676) → Type (max (?u.788677 + 1) ?u.788676)</span></span></div></blockquote></div></small></div>Monad</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>Type → Type u_1</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token">] : (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Neut</var><b>: </b><span>Type → Type → Bool → Bool → Type</span></span></div></blockquote></div></small></div>Neut</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ω</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">ω</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>false</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div>false</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>c</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div><span class="nv">c</span></span><span class="alectryon-token"> <span class="bp">×</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Assg</var><b>: </b><span>List Type → Type</span></span></div></blockquote></div></small></div>Assg</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Δ</var><b>: </b><span>List Type</span></span></div></blockquote></div></small></div><span class="nv">Δ</span></span><span class="alectryon-token">) <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ExceptT</var><b>: </b><span>Type → (Type → Type u_1) → Type → Type u_1</span></span></div></blockquote></div></small></div>ExceptT</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Unit</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Unit</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>Type → Type u_1</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Neut</var><b>: </b><span>Type → Type → Bool → Bool → Type</span></span></div></blockquote></div></small></div>Neut</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ω</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">ω</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>false</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div>false</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>false</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div>false</span><span class="alectryon-token"> <span class="bp">×</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Assg</var><b>: </b><span>List Type → Type</span></span></div></blockquote></div></small></div>Assg</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Δ</var><b>: </b><span>List Type</span></span></div></blockquote></div></small></div><span class="nv">Δ</span></span><span class="alectryon-token">)
  <span class="bp">|</span> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Neut.ret</var><b>: </b><span>{ω α : Type} → {b c : Bool} → ω → Neut ω α b c</span></span></div></blockquote></div></small></div>Neut.ret</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>o</var><b>: </b><span>ω</span></span></div></blockquote></div></small></div><span class="nv">o</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>σ</var><b>: </b><span>Assg Δ</span></span></div></blockquote></div></small></div><span class="nv">σ</span></span><span class="alectryon-token">) <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>pure</var><b>: </b><span>{f : Type → Type u_1} → [self : Pure f] → {α : Type} → α → f α</span></span></div></blockquote></div></small></div>pure</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Neut.ret</var><b>: </b><span>{ω α : Type} → {b c : Bool} → ω → Neut ω α b c</span></span></div></blockquote></div></small></div>Neut.ret</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>o</var><b>: </b><span>ω</span></span></div></blockquote></div></small></div><span class="nv">o</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>σ</var><b>: </b><span>Assg Δ</span></span></div></blockquote></div></small></div><span class="nv">σ</span></span><span class="alectryon-token">)
  <span class="bp">|</span> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Neut.val</var><b>: </b><span>{ω α : Type} → {b c : Bool} → α → Neut ω α b c</span></span></div></blockquote></div></small></div>Neut.val</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>σ</var><b>: </b><span>Assg Δ</span></span></div></blockquote></div></small></div><span class="nv">σ</span></span><span class="alectryon-token">) <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>pure</var><b>: </b><span>{f : Type → Type u_1} → [self : Pure f] → {α : Type} → α → f α</span></span></div></blockquote></div></small></div>pure</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Neut.val</var><b>: </b><span>{ω α : Type} → {b c : Bool} → α → Neut ω α b c</span></span></div></blockquote></div></small></div>Neut.val</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>σ</var><b>: </b><span>Assg Δ</span></span></div></blockquote></div></small></div><span class="nv">σ</span></span><span class="alectryon-token">)
  <span class="bp">|</span> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Neut.rcont</var><b>: </b><span>{ω α : Type} → {b : Bool} → Neut ω α b true</span></span></div></blockquote></div></small></div>Neut.rcont</span><span class="alectryon-token">, _) <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>throw</var><b>: </b><span>{ε : Type} → {m : Type → Type u_1} → [self : MonadExcept ε m] → {α : Type} → ε → m α</span></span></div></blockquote></div></small></div>throw</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>()</var><b>: </b><span>Unit</span></span></div></blockquote></div></small></div>()</span><span class="alectryon-token">

</span><span class="alectryon-token"><span class="kd">theorem</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>eval_C</var><b>: </b><span>∀ {m : Type → Type u_1} {ω : Type} {Γ Δ : List Type} {c : Bool} {α : Type} {ρ : Assg Γ} {σ : Assg Δ} [inst : Monad m]
  [inst_1 : LawfulMonad m] (s : Stmt m ω Γ Δ false c α),
  Stmt.eval ρ (C s) σ = ExceptT.lift (Stmt.eval ρ s σ) &gt;&gt;= throwOnContinue</span></span></div></blockquote></div></small></div><span class="nv">eval_C</span></span><span class="alectryon-token"> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Monad</var><b>: </b><span>(Type ?u.790186 → Type ?u.790185) → Type (max (?u.790186 + 1) ?u.790185)</span></span></div></blockquote></div></small></div>Monad</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>Type → Type u_1</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token">] [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>LawfulMonad</var><b>: </b><span>(m : Type ?u.790060 → Type ?u.790059) → [inst : Monad m] → Prop</span></span></div></blockquote></div></small></div>LawfulMonad</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>Type → Type u_1</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token">] (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>Stmt m ω Γ Δ false c α</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt</var><b>: </b><span>(Type → Type ?u.790118) → Type → List Type → List Type → Bool → Bool → Type → Type (max 1 ?u.790118)</span></span></div></blockquote></div></small></div>Stmt</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>Type → Type u_1</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ω</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">ω</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Γ</var><b>: </b><span>List Type</span></span></div></blockquote></div></small></div><span class="nv">Γ</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Δ</var><b>: </b><span>List Type</span></span></div></blockquote></div></small></div><span class="nv">Δ</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>false</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div>false</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>c</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div><span class="nv">c</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token">) : (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>C</var><b>: </b><span>{m : Type → Type u_1} →
  {ω : Type} →
    {Γ Δ : List Type} →
      {c : Bool} → {α : Type} → [inst : Monad m] → Stmt m ω Γ Δ false c α → Stmt (ExceptT Unit m) ω Γ Δ false false α</span></span></div></blockquote></div></small></div>C</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>Stmt m ω Γ Δ false c α</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token">)<span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>eval</var><b>: </b><span>{m : Type → Type u_1} →
  {Γ : List Type} →
    {ω : Type} →
      {Δ : List Type} →
        {b c : Bool} → {α : Type} → [inst : Monad m] → Assg Γ → Stmt m ω Γ Δ b c α → Assg Δ → m (Neut ω α b c × Assg Δ)</span></span></div></blockquote></div></small></div><span class="na">eval</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ρ</var><b>: </b><span>Assg Γ</span></span></div></blockquote></div></small></div><span class="nv">ρ</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>σ</var><b>: </b><span>Assg Δ</span></span></div></blockquote></div></small></div><span class="nv">σ</span></span><span class="alectryon-token"> <span class="bp">=</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ExceptT.lift</var><b>: </b><span>{ε : Type} → {m : Type → Type u_1} → [inst : Monad m] → {α : Type} → m α → ExceptT ε m α</span></span></div></blockquote></div></small></div>ExceptT.lift</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>Stmt m ω Γ Δ false c α</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>eval</var><b>: </b><span>{m : Type → Type u_1} →
  {Γ : List Type} →
    {ω : Type} →
      {Δ : List Type} →
        {b c : Bool} → {α : Type} → [inst : Monad m] → Assg Γ → Stmt m ω Γ Δ b c α → Assg Δ → m (Neut ω α b c × Assg Δ)</span></span></div></blockquote></div></small></div>eval</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ρ</var><b>: </b><span>Assg Γ</span></span></div></blockquote></div></small></div><span class="nv">ρ</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>σ</var><b>: </b><span>Assg Δ</span></span></div></blockquote></div></small></div><span class="nv">σ</span></span><span class="alectryon-token">) <span class="bp">&gt;&gt;=</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>throwOnContinue</var><b>: </b><span>{m : Type → Type u_1} →
  {ω α : Type} →
    {c : Bool} →
      {Δ : List Type} → [inst : Monad m] → Neut ω α false c × Assg Δ → ExceptT Unit m (Neut ω α false false × Assg Δ)</span></span></div></blockquote></div></small></div>throwOnContinue</span><span class="alectryon-token"> := </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk105" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk105"><span class="alectryon-token"><span class="kd">by</span></span><span class="alectryon-token"></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>ω</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Γ, Δ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ρ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ</span></span></span></span><br><span><var>σ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Δ</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>Stmt m ω <span class="bp">Γ</span> <span class="bp">Δ</span> false c α</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Stmt.eval ρ (C s) σ <span class="bp">=</span> ExceptT.lift (Stmt.eval ρ s σ) <span class="bp">&gt;&gt;=</span> throwOnContinue</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk106" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk106"><span class="alectryon-token"><span class="k">revert</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>Stmt m ω Γ Δ false c α</span></span></div></blockquote></div></small></div><span class="nv">s</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>ω</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Γ, Δ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ρ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ</span></span></span></span><br><span><var>σ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Δ</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="bp">∀</span> (s : Stmt m ω <span class="bp">Γ</span> <span class="bp">Δ</span> false c α), Stmt.eval ρ (C s) σ <span class="bp">=</span> ExceptT.lift (Stmt.eval ρ s σ) <span class="bp">&gt;&gt;=</span> throwOnContinue</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk107" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk107"><span class="alectryon-token"><span class="k">suffices</span></span><span class="alectryon-token"> {</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token">: </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>_</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>_</span><span class="alectryon-token"> } <span class="bp">→</span> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s'</var><b>: </b><span>Stmt m ω Γ Δ b c α</span></span></div></blockquote></div></small></div><span class="nv">s&#39;</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt</var><b>: </b><span>(Type → Type u_1) → Type → List Type → List Type → Bool → Bool → Type → Type (max 1 u_1)</span></span></div></blockquote></div></small></div>Stmt</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>Type → Type u_1</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ω</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">ω</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Γ</var><b>: </b><span>List Type</span></span></div></blockquote></div></small></div><span class="nv">Γ</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Δ</var><b>: </b><span>List Type</span></span></div></blockquote></div></small></div><span class="nv">Δ</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>c</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div><span class="nv">c</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token">) <span class="bp">→</span> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>h</var><b>: </b><span>b = false</span></span></div></blockquote></div></small></div><span class="nv">h</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token"> <span class="bp">=</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>false</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div>false</span><span class="alectryon-token">) <span class="bp">→</span> </span><span class="alectryon-token"><span class="k">let</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>Stmt m ω Γ Δ false c α</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt</var><b>: </b><span>(Type → Type u_1) → Type → List Type → List Type → Bool → Bool → Type → Type (max 1 u_1)</span></span></div></blockquote></div></small></div>Stmt</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>Type → Type u_1</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ω</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">ω</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Γ</var><b>: </b><span>List Type</span></span></div></blockquote></div></small></div><span class="nv">Γ</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Δ</var><b>: </b><span>List Type</span></span></div></blockquote></div></small></div><span class="nv">Δ</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>false</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div>false</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>c</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div><span class="nv">c</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token"> := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>h</var><b>: </b><span>b = false</span></span></div></blockquote></div></small></div><span class="nv">h</span></span><span class="alectryon-token"> <span class="bp">▸</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s'</var><b>: </b><span>Stmt m ω Γ Δ b c α</span></span></div></blockquote></div></small></div><span class="nv">s&#39;</span></span><span class="alectryon-token"><span class="bp">;</span> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>C</var><b>: </b><span>{m : Type → Type u_1} →
  {ω : Type} →
    {Γ Δ : List Type} →
      {c : Bool} → {α : Type} → [inst : Monad m] → Stmt m ω Γ Δ false c α → Stmt (ExceptT Unit m) ω Γ Δ false false α</span></span></div></blockquote></div></small></div>C</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>Stmt m ω Γ Δ false c α</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token">)<span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>eval</var><b>: </b><span>{m : Type → Type u_1} →
  {Γ : List Type} →
    {ω : Type} →
      {Δ : List Type} →
        {b c : Bool} → {α : Type} → [inst : Monad m] → Assg Γ → Stmt m ω Γ Δ b c α → Assg Δ → m (Neut ω α b c × Assg Δ)</span></span></div></blockquote></div></small></div><span class="na">eval</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ρ</var><b>: </b><span>Assg Γ</span></span></div></blockquote></div></small></div><span class="nv">ρ</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>σ</var><b>: </b><span>Assg Δ</span></span></div></blockquote></div></small></div><span class="nv">σ</span></span><span class="alectryon-token"> <span class="bp">=</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ExceptT.lift</var><b>: </b><span>{ε : Type} → {m : Type → Type u_1} → [inst : Monad m] → {α : Type} → m α → ExceptT ε m α</span></span></div></blockquote></div></small></div>ExceptT.lift</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>Stmt m ω Γ Δ false c α</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>eval</var><b>: </b><span>{m : Type → Type u_1} →
  {Γ : List Type} →
    {ω : Type} →
      {Δ : List Type} →
        {b c : Bool} → {α : Type} → [inst : Monad m] → Assg Γ → Stmt m ω Γ Δ b c α → Assg Δ → m (Neut ω α b c × Assg Δ)</span></span></div></blockquote></div></small></div>eval</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ρ</var><b>: </b><span>Assg Γ</span></span></div></blockquote></div></small></div><span class="nv">ρ</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>σ</var><b>: </b><span>Assg Δ</span></span></div></blockquote></div></small></div><span class="nv">σ</span></span><span class="alectryon-token">) <span class="bp">&gt;&gt;=</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>throwOnContinue</var><b>: </b><span>{m : Type → Type u_1} →
  {ω α : Type} →
    {c : Bool} →
      {Δ : List Type} → [inst : Monad m] → Neut ω α false c × Assg Δ → ExceptT Unit m (Neut ω α false false × Assg Δ)</span></span></div></blockquote></div></small></div>throwOnContinue</span><span class="alectryon-token">
    </span><span class="alectryon-token"><span class="k">from</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">fun</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>Stmt m ω Γ Δ false c α</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>this</var><b>: </b><span>∀ {b : Bool} (s' : Stmt m ω Γ Δ b c α) (h : b = false),
  let s := h ▸ s';
  Stmt.eval ρ (C s) σ = ExceptT.lift (Stmt.eval ρ s σ) &gt;&gt;= throwOnContinue</span></span></div></blockquote></div></small></div><span class="k">this</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>Stmt m ω Γ Δ false c α</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>rfl</var><b>: </b><span>∀ {α : Type} {a : α}, a = a</span></span></div></blockquote></div></small></div>rfl</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>ω</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Γ, Δ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ρ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ</span></span></span></span><br><span><var>σ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Δ</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="bp">∀</span> {b : Bool} (s&#39; : Stmt m ω <span class="bp">Γ</span> <span class="bp">Δ</span> b c α) (h : b <span class="bp">=</span> false),
  <span class="k">let</span> s := h <span class="bp">▸</span> s&#39;<span class="bp">;</span>
  Stmt.eval ρ (C s) σ <span class="bp">=</span> ExceptT.lift (Stmt.eval ρ s σ) <span class="bp">&gt;&gt;=</span> throwOnContinue</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk108" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk108"><span class="alectryon-token"><span class="k">intro</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b'</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div><span class="nv">b&#39;</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>Stmt m ω Γ Δ b' c α</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>h</var><b>: </b><span>b' = false</span></span></div></blockquote></div></small></div><span class="nv">h</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>ω</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Γ, Δ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ρ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ</span></span></span></span><br><span><var>σ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Δ</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>b'</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>Stmt m ω <span class="bp">Γ</span> <span class="bp">Δ</span> b&#39; c α</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>b&#39; <span class="bp">=</span> false</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="k">let</span> s := h <span class="bp">▸</span> s<span class="bp">;</span>
Stmt.eval ρ (C s) σ <span class="bp">=</span> ExceptT.lift (Stmt.eval ρ s σ) <span class="bp">&gt;&gt;=</span> throwOnContinue</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk109" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk109"><span class="alectryon-token"><span class="k">induction</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>Stmt m ω Γ Δ b' c α</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">with</span></span><span class="alectryon-token"></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>ω</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Γ, Δ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ρ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ</span></span></span></span><br><span><var>σ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Δ</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>b'</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>Stmt m ω <span class="bp">Γ</span> <span class="bp">Δ</span> b&#39; c α</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>b&#39; <span class="bp">=</span> false</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="k">let</span> s := h <span class="bp">▸</span> s<span class="bp">;</span>
Stmt.eval ρ (C s) σ <span class="bp">=</span> ExceptT.lift (Stmt.eval ρ s σ) <span class="bp">&gt;&gt;=</span> throwOnContinue</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
    </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk10a" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk10a"><span class="alectryon-token">(</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>ω</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Γ, Δ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>b'</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>Γ✝, Δ✝</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>α✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b✝, c✝</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>β✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>e✝</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ✝</span> <span class="bp">→</span> Assg <span class="bp">Δ✝</span> <span class="bp">→</span> α<span class="bp">✝</span></span></span></span><br><span><var>s✝</var><span class="hyp-type"><b>: </b><span>Stmt m ω <span class="bp">Γ✝</span> (α<span class="bp">✝</span> :: <span class="bp">Δ✝</span>) b<span class="bp">✝</span> c<span class="bp">✝</span> β<span class="bp">✝</span></span></span></span><br><span><var>ρ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ✝</span></span></span></span><br><span><var>σ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Δ✝</span></span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>b<span class="bp">✝</span> <span class="bp">=</span> false</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">letmut</span></span><div class="goal-conclusion"><span class="k">let</span> s := h <span class="bp">▸</span> Stmt.letmut e<span class="bp">✝</span> s<span class="bp">✝;</span>
Stmt.eval ρ (C s) σ <span class="bp">=</span> ExceptT.lift (Stmt.eval ρ s σ) <span class="bp">&gt;&gt;=</span> throwOnContinue</div></blockquote></div></div></small></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk10b" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk10b"><span class="alectryon-token"><span class="k">first</span></span><span class="alectryon-token"> <span class="bp">|</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>ω</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Γ, Δ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>b'</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>Γ✝, Δ✝</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>b✝, c✝</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>α✝, β✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>s✝</var><span class="hyp-type"><b>: </b><span>Stmt m ω <span class="bp">Γ✝</span> <span class="bp">Δ✝</span> b<span class="bp">✝</span> c<span class="bp">✝</span> α<span class="bp">✝</span></span></span></span><br><span><var>s'✝</var><span class="hyp-type"><b>: </b><span>Stmt m ω (α<span class="bp">✝</span> :: <span class="bp">Γ✝</span>) <span class="bp">Δ✝</span> b<span class="bp">✝</span> c<span class="bp">✝</span> β<span class="bp">✝</span></span></span></span><br><span><var>ρ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ✝</span></span></span></span><br><span><var>σ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Δ✝</span></span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>b<span class="bp">✝</span> <span class="bp">=</span> false</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">bind</span></span><div class="goal-conclusion"><span class="k">let</span> s := h <span class="bp">▸</span> Stmt.bind s<span class="bp">✝</span> s&#39;<span class="bp">✝;</span>
Stmt.eval ρ (C s) σ <span class="bp">=</span> ExceptT.lift (Stmt.eval ρ s σ) <span class="bp">&gt;&gt;=</span> throwOnContinue</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk10c" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk10c"><span class="alectryon-token"><span class="k">subst</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>h</var><b>: </b><span>b✝ = false</span></span></div></blockquote></div></small></div><span class="nv">h</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>ω</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Γ, Δ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>b'</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>Γ✝, Δ✝</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>c✝</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>α✝, β✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ρ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ✝</span></span></span></span><br><span><var>σ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Δ✝</span></span></span></span><br><span><var>s✝</var><span class="hyp-type"><b>: </b><span>Stmt m ω <span class="bp">Γ✝</span> <span class="bp">Δ✝</span> false c<span class="bp">✝</span> α<span class="bp">✝</span></span></span></span><br><span><var>s'✝</var><span class="hyp-type"><b>: </b><span>Stmt m ω (α<span class="bp">✝</span> :: <span class="bp">Γ✝</span>) <span class="bp">Δ✝</span> false c<span class="bp">✝</span> β<span class="bp">✝</span></span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">bind</span></span><div class="goal-conclusion"><span class="k">let</span> s := (_ : false <span class="bp">=</span> false) <span class="bp">▸</span> Stmt.bind s<span class="bp">✝</span> s&#39;<span class="bp">✝;</span>
Stmt.eval ρ (C s) σ <span class="bp">=</span> ExceptT.lift (Stmt.eval ρ s σ) <span class="bp">&gt;&gt;=</span> throwOnContinue</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk10d" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk10d"><span class="alectryon-token"><span class="bp">|</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>ω</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Γ, Δ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>b'</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>Γ✝, Δ✝</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>b✝, c✝</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>α✝, β✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>s✝</var><span class="hyp-type"><b>: </b><span>Stmt m ω <span class="bp">Γ✝</span> <span class="bp">Δ✝</span> b<span class="bp">✝</span> c<span class="bp">✝</span> α<span class="bp">✝</span></span></span></span><br><span><var>s'✝</var><span class="hyp-type"><b>: </b><span>Stmt m ω (α<span class="bp">✝</span> :: <span class="bp">Γ✝</span>) <span class="bp">Δ✝</span> b<span class="bp">✝</span> c<span class="bp">✝</span> β<span class="bp">✝</span></span></span></span><br><span><var>ρ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ✝</span></span></span></span><br><span><var>σ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Δ✝</span></span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>b<span class="bp">✝</span> <span class="bp">=</span> false</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">bind</span></span><div class="goal-conclusion"><span class="k">let</span> s := h <span class="bp">▸</span> Stmt.bind s<span class="bp">✝</span> s&#39;<span class="bp">✝;</span>
Stmt.eval ρ (C s) σ <span class="bp">=</span> ExceptT.lift (Stmt.eval ρ s σ) <span class="bp">&gt;&gt;=</span> throwOnContinue</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk10e" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk10e"><span class="alectryon-token"><span class="k">trivial</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>ω</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Γ, Δ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>b'</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>Γ✝, Δ✝</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>c✝</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>α✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ρ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ✝</span></span></span></span><br><span><var>σ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Δ✝</span></span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>true <span class="bp">=</span> false</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">sbreak</span></span><div class="goal-conclusion"><span class="k">let</span> s := h <span class="bp">▸</span> Stmt.sbreak<span class="bp">;</span>
Stmt.eval ρ (C s) σ <span class="bp">=</span> ExceptT.lift (Stmt.eval ρ s σ) <span class="bp">&gt;&gt;=</span> throwOnContinue</div></blockquote></div></div></small></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk10f" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk10f"><span class="alectryon-token">)</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>ω</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Γ, Δ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>b'</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>Γ✝, Δ✝</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>α✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>c✝</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>β✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>e✝</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ✝</span> <span class="bp">→</span> Assg <span class="bp">Δ✝</span> <span class="bp">→</span> α<span class="bp">✝</span></span></span></span><br><span><var>ρ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ✝</span></span></span></span><br><span><var>σ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Δ✝</span></span></span></span><br><span><var>s✝</var><span class="hyp-type"><b>: </b><span>Stmt m ω <span class="bp">Γ✝</span> (α<span class="bp">✝</span> :: <span class="bp">Δ✝</span>) false c<span class="bp">✝</span> β<span class="bp">✝</span></span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">letmut</span></span><div class="goal-conclusion"><span class="k">let</span> s := (_ : false <span class="bp">=</span> false) <span class="bp">▸</span> Stmt.letmut e<span class="bp">✝</span> s<span class="bp">✝;</span>
Stmt.eval ρ (C s) σ <span class="bp">=</span> ExceptT.lift (Stmt.eval ρ s σ) <span class="bp">&gt;&gt;=</span> throwOnContinue</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk110" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk110"><span class="alectryon-token"><span class="bp">|</span> sfor </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>Assg Γ✝ → Assg Δ✝ → List α✝</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>ω</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Γ, Δ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>b'</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>Γ✝, Δ✝</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>α✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>c✝</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ✝</span> <span class="bp">→</span> Assg <span class="bp">Δ✝</span> <span class="bp">→</span> List α<span class="bp">✝</span></span></span></span><br><span><var>s✝</var><span class="hyp-type"><b>: </b><span>Stmt m ω (α<span class="bp">✝</span> :: <span class="bp">Γ✝</span>) <span class="bp">Δ✝</span> true true Unit</span></span></span><br><span><var>ρ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ✝</span></span></span></span><br><span><var>σ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Δ✝</span></span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">sfor</span></span><div class="goal-conclusion"><span class="k">let</span> s := (_ : false <span class="bp">=</span> false) <span class="bp">▸</span> Stmt.sfor e s<span class="bp">✝;</span>
Stmt.eval ρ (C s) σ <span class="bp">=</span> ExceptT.lift (Stmt.eval ρ s σ) <span class="bp">&gt;&gt;=</span> throwOnContinue</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
    </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk111" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk111"><span class="alectryon-token"><span class="k">simp</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">only</span></span><span class="alectryon-token"> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt.eval</var><b>: </b><span>{m : Type → Type ?u.790927} →
  {Γ : List Type} →
    {ω : Type} →
      {Δ : List Type} →
        {b c : Bool} → {α : Type} → [inst : Monad m] → Assg Γ → Stmt m ω Γ Δ b c α → Assg Δ → m (Neut ω α b c × Assg Δ)</span></span></div></blockquote></div></small></div>Stmt.eval</span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>C</var><b>: </b><span>{m : Type → Type ?u.791270} →
  {ω : Type} →
    {Γ Δ : List Type} →
      {c : Bool} → {α : Type} → [inst : Monad m] → Stmt m ω Γ Δ false c α → Stmt (ExceptT Unit m) ω Γ Δ false false α</span></span></div></blockquote></div></small></div>C</span><span class="alectryon-token">]</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>ω</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Γ, Δ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>b'</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>Γ✝, Δ✝</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>α✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>c✝</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ✝</span> <span class="bp">→</span> Assg <span class="bp">Δ✝</span> <span class="bp">→</span> List α<span class="bp">✝</span></span></span></span><br><span><var>s✝</var><span class="hyp-type"><b>: </b><span>Stmt m ω (α<span class="bp">✝</span> :: <span class="bp">Γ✝</span>) <span class="bp">Δ✝</span> true true Unit</span></span></span><br><span><var>ρ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ✝</span></span></span></span><br><span><var>σ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Δ✝</span></span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">sfor</span></span><div class="goal-conclusion">Stmt.eval.go ρ false false α<span class="bp">✝</span> (L s<span class="bp">✝</span>) σ (e ρ σ) <span class="bp">=</span>
  ExceptT.lift (Stmt.eval.go ρ c<span class="bp">✝</span> false α<span class="bp">✝</span> s<span class="bp">✝</span> σ (e ρ σ)) <span class="bp">&gt;&gt;=</span> throwOnContinue</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
    </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk112" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk112"><span class="alectryon-token"><span class="k">induction</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>Assg Γ✝ → Assg Δ✝ → List α✝</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ρ</var><b>: </b><span>Assg Γ✝</span></span></div></blockquote></div></small></div><span class="nv">ρ</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>σ</var><b>: </b><span>Assg Δ✝</span></span></div></blockquote></div></small></div><span class="nv">σ</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">generalizing</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>σ</var><b>: </b><span>Assg Δ✝</span></span></div></blockquote></div></small></div><span class="nv">σ</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>ω</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Γ, Δ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>b'</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>Γ✝, Δ✝</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>α✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>c✝</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ✝</span> <span class="bp">→</span> Assg <span class="bp">Δ✝</span> <span class="bp">→</span> List α<span class="bp">✝</span></span></span></span><br><span><var>s✝</var><span class="hyp-type"><b>: </b><span>Stmt m ω (α<span class="bp">✝</span> :: <span class="bp">Γ✝</span>) <span class="bp">Δ✝</span> true true Unit</span></span></span><br><span><var>ρ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ✝</span></span></span></span><br><span><var>σ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Δ✝</span></span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">sfor.nil</span></span><div class="goal-conclusion">Stmt.eval.go ρ false false α<span class="bp">✝</span> (L s<span class="bp">✝</span>) σ [] <span class="bp">=</span> ExceptT.lift (Stmt.eval.go ρ c<span class="bp">✝</span> false α<span class="bp">✝</span> s<span class="bp">✝</span> σ []) <span class="bp">&gt;&gt;=</span> throwOnContinue</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Formal-lean-chk113" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>ω</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Γ, Δ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>b'</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>Γ✝, Δ✝</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>α✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>c✝</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ✝</span> <span class="bp">→</span> Assg <span class="bp">Δ✝</span> <span class="bp">→</span> List α<span class="bp">✝</span></span></span></span><br><span><var>s✝</var><span class="hyp-type"><b>: </b><span>Stmt m ω (α<span class="bp">✝</span> :: <span class="bp">Γ✝</span>) <span class="bp">Δ✝</span> true true Unit</span></span></span><br><span><var>ρ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ✝</span></span></span></span><br><span><var>head✝</var><span class="hyp-type"><b>: </b><span>α<span class="bp">✝</span></span></span></span><br><span><var>tail✝</var><span class="hyp-type"><b>: </b><span>List α<span class="bp">✝</span></span></span></span><br><span><var>σ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Δ✝</span></span></span></span><br></div><label class="goal-separator" for="Formal-lean-chk113"><hr><span class="goal-name">sfor.cons</span></label><div class="goal-conclusion">Stmt.eval.go ρ false false α<span class="bp">✝</span> (L s<span class="bp">✝</span>) σ (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) <span class="bp">=</span>
  ExceptT.lift (Stmt.eval.go ρ c<span class="bp">✝</span> false α<span class="bp">✝</span> s<span class="bp">✝</span> σ (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>)) <span class="bp">&gt;&gt;=</span> throwOnContinue</div></blockquote></div></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk114" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk114"><span class="alectryon-token"><span class="k">&lt;;&gt;</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>ω</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Γ, Δ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>b'</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>Γ✝, Δ✝</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>α✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>c✝</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ✝</span> <span class="bp">→</span> Assg <span class="bp">Δ✝</span> <span class="bp">→</span> List α<span class="bp">✝</span></span></span></span><br><span><var>s✝</var><span class="hyp-type"><b>: </b><span>Stmt m ω (α<span class="bp">✝</span> :: <span class="bp">Γ✝</span>) <span class="bp">Δ✝</span> true true Unit</span></span></span><br><span><var>ρ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ✝</span></span></span></span><br><span><var>σ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Δ✝</span></span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">sfor.nil</span></span><div class="goal-conclusion">Stmt.eval.go ρ false false α<span class="bp">✝</span> (L s<span class="bp">✝</span>) σ [] <span class="bp">=</span> ExceptT.lift (Stmt.eval.go ρ c<span class="bp">✝</span> false α<span class="bp">✝</span> s<span class="bp">✝</span> σ []) <span class="bp">&gt;&gt;=</span> throwOnContinue</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Formal-lean-chk115" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>ω</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Γ, Δ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>b'</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>Γ✝, Δ✝</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>α✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>c✝</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ✝</span> <span class="bp">→</span> Assg <span class="bp">Δ✝</span> <span class="bp">→</span> List α<span class="bp">✝</span></span></span></span><br><span><var>s✝</var><span class="hyp-type"><b>: </b><span>Stmt m ω (α<span class="bp">✝</span> :: <span class="bp">Γ✝</span>) <span class="bp">Δ✝</span> true true Unit</span></span></span><br><span><var>ρ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ✝</span></span></span></span><br><span><var>head✝</var><span class="hyp-type"><b>: </b><span>α<span class="bp">✝</span></span></span></span><br><span><var>tail✝</var><span class="hyp-type"><b>: </b><span>List α<span class="bp">✝</span></span></span></span><br><span><var>σ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Δ✝</span></span></span></span><br></div><label class="goal-separator" for="Formal-lean-chk115"><hr><span class="goal-name">sfor.cons</span></label><div class="goal-conclusion">Stmt.eval.go ρ false false α<span class="bp">✝</span> (L s<span class="bp">✝</span>) σ (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) <span class="bp">=</span>
  ExceptT.lift (Stmt.eval.go ρ c<span class="bp">✝</span> false α<span class="bp">✝</span> s<span class="bp">✝</span> σ (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>)) <span class="bp">&gt;&gt;=</span> throwOnContinue</div></blockquote></div></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk116" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk116"><span class="alectryon-token"><span class="k">aesop</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><span class="k">add</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">norm</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">simp</span></span><span class="alectryon-token"> eval_L, </span><span class="alectryon-token"><span class="k">unsafe</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">apply</span></span><span class="alectryon-token"> ExceptT.ext)</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk117" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk117"><span class="alectryon-token"><span class="bp">|</span> _ <span class="bp">=&gt;</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1</span></span></span><br><span><var>ω</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Γ, Δ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>b'</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>Γ✝, Δ✝</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>α✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>c✝</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>β✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>e✝</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ✝</span> <span class="bp">→</span> Assg <span class="bp">Δ✝</span> <span class="bp">→</span> α<span class="bp">✝</span></span></span></span><br><span><var>ρ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ✝</span></span></span></span><br><span><var>σ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Δ✝</span></span></span></span><br><span><var>s✝</var><span class="hyp-type"><b>: </b><span>Stmt m ω <span class="bp">Γ✝</span> (α<span class="bp">✝</span> :: <span class="bp">Δ✝</span>) false c<span class="bp">✝</span> β<span class="bp">✝</span></span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">letmut</span></span><div class="goal-conclusion"><span class="k">let</span> s := (_ : false <span class="bp">=</span> false) <span class="bp">▸</span> Stmt.letmut e<span class="bp">✝</span> s<span class="bp">✝;</span>
Stmt.eval ρ (C s) σ <span class="bp">=</span> ExceptT.lift (Stmt.eval ρ s σ) <span class="bp">&gt;&gt;=</span> throwOnContinue</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk118" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk118"><span class="alectryon-token"><span class="k">aesop</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><span class="k">add</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">unsafe</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">apply</span></span><span class="alectryon-token"> ExceptT.ext)</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">

</span><span class="alectryon-token"><span class="kd">theorem</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>D_eq</var><b>: </b><span>∀
  (_x :
    (m : Type → Type) ×'
      (Γ : List Type) ×'
        (α : Type) ×' (_ : Assg Γ) ×' (inst : Monad m) ×' (_ : LawfulMonad m) ×' Stmt m Empty Γ ∅ false false α),
  D _x.2.2.2.2.2.2 _x.2.2.2.1 = do
    let x ← Stmt.eval _x.2.2.2.1 _x.2.2.2.2.2.2 ∅
    match x with
      | (Neut.val a, snd) =&gt; pure a</span></span></div></blockquote></div></small></div><span class="nv">D_eq</span></span><span class="alectryon-token"> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Monad</var><b>: </b><span>(Type ?u.924916 → Type ?u.924915) → Type (max (?u.924916 + 1) ?u.924915)</span></span></div></blockquote></div></small></div>Monad</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>Type → Type</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token">] [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>LawfulMonad</var><b>: </b><span>(m : Type ?u.924921 → Type ?u.924920) → [inst : Monad m] → Prop</span></span></div></blockquote></div></small></div>LawfulMonad</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>Type → Type</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token">] : (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>Stmt m Empty Γ ∅ false false α</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt</var><b>: </b><span>(Type → Type) → Type → List Type → List Type → Bool → Bool → Type → Type 1</span></span></div></blockquote></div></small></div>Stmt</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>Type → Type</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Empty</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Empty</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Γ</var><b>: </b><span>List Type</span></span></div></blockquote></div></small></div><span class="nv">Γ</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>∅</var><b>: </b><span>List Type</span></span></div></blockquote></div></small></div><span class="bp">∅</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>false</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div>false</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>false</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div>false</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token">) <span class="bp">→</span>
    </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>D</var><b>: </b><span>{m : Type → Type} → {Γ : List Type} → {α : Type} → [inst : Monad m] → Stmt m Empty Γ ∅ false false α → Assg Γ → m α</span></span></div></blockquote></div></small></div>D</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>Stmt m Empty Γ ∅ false false α</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ρ</var><b>: </b><span>Assg Γ</span></span></div></blockquote></div></small></div><span class="nv">ρ</span></span><span class="alectryon-token"> <span class="bp">=</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>Stmt m Empty Γ ∅ false false α</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>eval</var><b>: </b><span>{m : Type → Type} →
  {Γ : List Type} →
    {ω : Type} →
      {Δ : List Type} →
        {b c : Bool} → {α : Type} → [inst : Monad m] → Assg Γ → Stmt m ω Γ Δ b c α → Assg Δ → m (Neut ω α b c × Assg Δ)</span></span></div></blockquote></div></small></div>eval</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ρ</var><b>: </b><span>Assg Γ</span></span></div></blockquote></div></small></div><span class="nv">ρ</span></span><span class="alectryon-token"> <span class="bp">∅</span> <span class="bp">&gt;&gt;=</span> </span><span class="alectryon-token"><span class="k">fun</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Neut.val</var><b>: </b><span>{ω α : Type} → {b c : Bool} → α → Neut ω α b c</span></span></div></blockquote></div></small></div>Neut.val</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token">, _) <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>pure</var><b>: </b><span>{f : Type → Type} → [self : Pure f] → {α : Type} → α → f α</span></span></div></blockquote></div></small></div>pure</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt.expr</var><b>: </b><span>{m : Type → Type ?u.926133} →
  {ω : Type} → {Γ Δ : List Type} → {α : Type} → {b c : Bool} → (Assg Γ → Assg Δ → m α) → Stmt m ω Γ Δ b c α</span></span></div></blockquote></div></small></div>Stmt.expr</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>Assg Γ → Assg ∅ → m α</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk119" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk119"><span class="alectryon-token"><span class="kd">by</span></span><span class="alectryon-token"></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span></span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>ρ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ</span> <span class="bp">→</span> Assg <span class="bp">∅</span> <span class="bp">→</span> m α</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">D (Stmt.expr e) ρ <span class="bp">=</span> <span class="k">do</span>
  <span class="k">let</span> x <span class="bp">←</span> Stmt.eval ρ (Stmt.expr e) <span class="bp">∅</span>
  <span class="k">match</span> x <span class="k">with</span>
    <span class="bp">|</span> (Neut.val a, snd) <span class="bp">=&gt;</span> pure a</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk11a" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk11a"><span class="alectryon-token"><span class="k">simp</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt.bind</var><b>: </b><span>{m : Type → Type ?u.926201} →
  {ω : Type} →
    {Γ Δ : List Type} →
      {b c : Bool} → {α β : Type} → Stmt m ω Γ Δ b c α → Stmt m ω (α :: Γ) Δ b c β → Stmt m ω Γ Δ b c β</span></span></div></blockquote></div></small></div>Stmt.bind</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s₁</var><b>: </b><span>Stmt m Empty Γ ∅ false false α✝</span></span></div></blockquote></div></small></div><span class="nv">s₁</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s₂</var><b>: </b><span>Stmt m Empty (α✝ :: Γ) ∅ false false α</span></span></div></blockquote></div></small></div><span class="nv">s₂</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk11b" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk11b"><span class="alectryon-token"><span class="kd">by</span></span><span class="alectryon-token"></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span></span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>ρ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>α, α✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>s₁</var><span class="hyp-type"><b>: </b><span>Stmt m Empty <span class="bp">Γ</span> <span class="bp">∅</span> false false α<span class="bp">✝</span></span></span></span><br><span><var>s₂</var><span class="hyp-type"><b>: </b><span>Stmt m Empty (α<span class="bp">✝</span> :: <span class="bp">Γ</span>) <span class="bp">∅</span> false false α</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">D (Stmt.bind s₁ s₂) ρ <span class="bp">=</span> <span class="k">do</span>
  <span class="k">let</span> x <span class="bp">←</span> Stmt.eval ρ (Stmt.bind s₁ s₂) <span class="bp">∅</span>
  <span class="k">match</span> x <span class="k">with</span>
    <span class="bp">|</span> (Neut.val a, snd) <span class="bp">=&gt;</span> pure a</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
    </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk11c" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk11c"><span class="alectryon-token"><span class="k">have</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ih₁</var><b>: </b><span>∀ (ρ : Assg Γ),
  Monad m →
    LawfulMonad m →
      D s₁ ρ = do
        let x ← Stmt.eval ρ s₁ ∅
        match x with
          | (Neut.val a, snd) =&gt; pure a</span></span></div></blockquote></div></small></div><span class="nv">ih₁</span></span><span class="alectryon-token"> := <span class="bp">@</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>D_eq</var><b>: </b><span>∀ {m : Type → Type} {Γ : List Type} {α : Type} {ρ : Assg Γ} [inst : Monad m] [inst_1 : LawfulMonad m]
  (s : Stmt m Empty Γ ∅ false false α),
  D s ρ = do
    let x ← Stmt.eval ρ s ∅
    match x with
      | (Neut.val a, snd) =&gt; pure a</span></span></div></blockquote></div></small></div><span class="nv">D_eq</span></span><span class="alectryon-token"> (s := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s₁</var><b>: </b><span>Stmt m Empty Γ ∅ false false α✝</span></span></div></blockquote></div></small></div><span class="nv">s₁</span></span><span class="alectryon-token">)</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span></span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>ρ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>α, α✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>s₁</var><span class="hyp-type"><b>: </b><span>Stmt m Empty <span class="bp">Γ</span> <span class="bp">∅</span> false false α<span class="bp">✝</span></span></span></span><br><span><var>s₂</var><span class="hyp-type"><b>: </b><span>Stmt m Empty (α<span class="bp">✝</span> :: <span class="bp">Γ</span>) <span class="bp">∅</span> false false α</span></span></span><br><span><var>ih₁</var><span class="hyp-type"><b>: </b><span><span class="bp">∀</span> (ρ : Assg <span class="bp">Γ</span>),
  Monad m <span class="bp">→</span>
    LawfulMonad m <span class="bp">→</span>
      D s₁ ρ <span class="bp">=</span> <span class="k">do</span>
        <span class="k">let</span> x <span class="bp">←</span> Stmt.eval ρ s₁ <span class="bp">∅</span>
        <span class="k">match</span> x <span class="k">with</span>
          <span class="bp">|</span> (Neut.val a, snd) <span class="bp">=&gt;</span> pure a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">D (Stmt.bind s₁ s₂) ρ <span class="bp">=</span> <span class="k">do</span>
  <span class="k">let</span> x <span class="bp">←</span> Stmt.eval ρ (Stmt.bind s₁ s₂) <span class="bp">∅</span>
  <span class="k">match</span> x <span class="k">with</span>
    <span class="bp">|</span> (Neut.val a, snd) <span class="bp">=&gt;</span> pure a</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
    </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk11d" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk11d"><span class="alectryon-token"><span class="k">have</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ih₂</var><b>: </b><span>∀ (ρ : Assg (α✝ :: Γ)),
  Monad m →
    LawfulMonad m →
      D s₂ ρ = do
        let x ← Stmt.eval ρ s₂ ∅
        match x with
          | (Neut.val a, snd) =&gt; pure a</span></span></div></blockquote></div></small></div><span class="nv">ih₂</span></span><span class="alectryon-token"> := <span class="bp">@</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>D_eq</var><b>: </b><span>∀ {m : Type → Type} {Γ : List Type} {α : Type} {ρ : Assg Γ} [inst : Monad m] [inst_1 : LawfulMonad m]
  (s : Stmt m Empty Γ ∅ false false α),
  D s ρ = do
    let x ← Stmt.eval ρ s ∅
    match x with
      | (Neut.val a, snd) =&gt; pure a</span></span></div></blockquote></div></small></div><span class="nv">D_eq</span></span><span class="alectryon-token"> (s := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s₂</var><b>: </b><span>Stmt m Empty (α✝ :: Γ) ∅ false false α</span></span></div></blockquote></div></small></div><span class="nv">s₂</span></span><span class="alectryon-token">)</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span></span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>ρ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>α, α✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>s₁</var><span class="hyp-type"><b>: </b><span>Stmt m Empty <span class="bp">Γ</span> <span class="bp">∅</span> false false α<span class="bp">✝</span></span></span></span><br><span><var>s₂</var><span class="hyp-type"><b>: </b><span>Stmt m Empty (α<span class="bp">✝</span> :: <span class="bp">Γ</span>) <span class="bp">∅</span> false false α</span></span></span><br><span><var>ih₁</var><span class="hyp-type"><b>: </b><span><span class="bp">∀</span> (ρ : Assg <span class="bp">Γ</span>),
  Monad m <span class="bp">→</span>
    LawfulMonad m <span class="bp">→</span>
      D s₁ ρ <span class="bp">=</span> <span class="k">do</span>
        <span class="k">let</span> x <span class="bp">←</span> Stmt.eval ρ s₁ <span class="bp">∅</span>
        <span class="k">match</span> x <span class="k">with</span>
          <span class="bp">|</span> (Neut.val a, snd) <span class="bp">=&gt;</span> pure a</span></span></span><br><span><var>ih₂</var><span class="hyp-type"><b>: </b><span><span class="bp">∀</span> (ρ : Assg (α<span class="bp">✝</span> :: <span class="bp">Γ</span>)),
  Monad m <span class="bp">→</span>
    LawfulMonad m <span class="bp">→</span>
      D s₂ ρ <span class="bp">=</span> <span class="k">do</span>
        <span class="k">let</span> x <span class="bp">←</span> Stmt.eval ρ s₂ <span class="bp">∅</span>
        <span class="k">match</span> x <span class="k">with</span>
          <span class="bp">|</span> (Neut.val a, snd) <span class="bp">=&gt;</span> pure a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">D (Stmt.bind s₁ s₂) ρ <span class="bp">=</span> <span class="k">do</span>
  <span class="k">let</span> x <span class="bp">←</span> Stmt.eval ρ (Stmt.bind s₁ s₂) <span class="bp">∅</span>
  <span class="k">match</span> x <span class="k">with</span>
    <span class="bp">|</span> (Neut.val a, snd) <span class="bp">=&gt;</span> pure a</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
    </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk11e" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk11e"><span class="alectryon-token"><span class="k">aesop</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt.letmut</var><b>: </b><span>{m : Type → Type ?u.926267} →
  {ω : Type} →
    {Γ Δ : List Type} →
      {α : Type} → {b c : Bool} → {β : Type} → (Assg Γ → Assg Δ → α) → Stmt m ω Γ (α :: Δ) b c β → Stmt m ω Γ Δ b c β</span></span></div></blockquote></div></small></div>Stmt.letmut</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>Assg Γ → Assg ∅ → α✝</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>Stmt m Empty Γ (α✝ :: ∅) false false α</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk11f" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk11f"><span class="alectryon-token"><span class="kd">by</span></span><span class="alectryon-token"></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span></span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>ρ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>α, α✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ</span> <span class="bp">→</span> Assg <span class="bp">∅</span> <span class="bp">→</span> α<span class="bp">✝</span></span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>Stmt m Empty <span class="bp">Γ</span> (α<span class="bp">✝</span> :: <span class="bp">∅</span>) false false α</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">D (Stmt.letmut e s) ρ <span class="bp">=</span> <span class="k">do</span>
  <span class="k">let</span> x <span class="bp">←</span> Stmt.eval ρ (Stmt.letmut e s) <span class="bp">∅</span>
  <span class="k">match</span> x <span class="k">with</span>
    <span class="bp">|</span> (Neut.val a, snd) <span class="bp">=&gt;</span> pure a</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
    </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk120" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk120"><span class="alectryon-token"><span class="k">have</span></span><span class="alectryon-token"> := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat.lt_succ_of_le</var><b>: </b><span>∀ {n m : Nat}, n ≤ m → n &lt; Nat.succ m</span></span></div></blockquote></div></small></div>Nat.lt_succ_of_le</span><span class="alectryon-token"> <span class="bp">&lt;|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt.numExts_S</var><b>: </b><span>∀ {m : Type → Type} {ω : Type} {Γ Δ : List Type} {α : Type} {b c : Bool} {β : Type} [inst : Monad m]
  (s : Stmt m ω Γ (List.append Δ [α]) b c β), Stmt.numExts (S s) ≤ Stmt.numExts s</span></span></div></blockquote></div></small></div>Stmt.numExts_S</span><span class="alectryon-token"> (<span class="bp">Δ</span> := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>[]</var><b>: </b><span>List Type</span></span></div></blockquote></div></small></div>[]</span><span class="alectryon-token">) </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>Stmt m Empty Γ (α✝ :: ∅) false false α</span></span></div></blockquote></div></small></div><span class="nv">s</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span></span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>ρ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>α, α✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ</span> <span class="bp">→</span> Assg <span class="bp">∅</span> <span class="bp">→</span> α<span class="bp">✝</span></span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>Stmt m Empty <span class="bp">Γ</span> (α<span class="bp">✝</span> :: <span class="bp">∅</span>) false false α</span></span></span><br><span><var>this</var><span class="hyp-type"><b>: </b><span>Stmt.numExts (S s) <span class="bp">&lt;</span> Nat.succ (Stmt.numExts s)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">D (Stmt.letmut e s) ρ <span class="bp">=</span> <span class="k">do</span>
  <span class="k">let</span> x <span class="bp">←</span> Stmt.eval ρ (Stmt.letmut e s) <span class="bp">∅</span>
  <span class="k">match</span> x <span class="k">with</span>
    <span class="bp">|</span> (Neut.val a, snd) <span class="bp">=&gt;</span> pure a</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk121" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk121"><span class="alectryon-token"><span class="c1">-- for termination</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span></span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>ρ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>α, α✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ</span> <span class="bp">→</span> Assg <span class="bp">∅</span> <span class="bp">→</span> α<span class="bp">✝</span></span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>Stmt m Empty <span class="bp">Γ</span> (α<span class="bp">✝</span> :: <span class="bp">∅</span>) false false α</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">D (Stmt.letmut e s) ρ <span class="bp">=</span> <span class="k">do</span>
  <span class="k">let</span> x <span class="bp">←</span> Stmt.eval ρ (Stmt.letmut e s) <span class="bp">∅</span>
  <span class="k">match</span> x <span class="k">with</span>
    <span class="bp">|</span> (Neut.val a, snd) <span class="bp">=&gt;</span> pure a</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
    </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk122" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk122"><span class="alectryon-token"><span class="k">have</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ih</var><b>: </b><span>∀ (a : Assg (α✝ :: Γ)),
  D (S s) a = do
    let x ← Stmt.eval a (S s) ∅
    match x with
      | (Neut.val a, snd) =&gt; pure a</span></span></div></blockquote></div></small></div><span class="nv">ih</span></span><span class="alectryon-token"> := (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>D_eq</var><b>: </b><span>∀ {m : Type → Type} {Γ : List Type} {α : Type} {ρ : Assg Γ} [inst : Monad m] [inst_1 : LawfulMonad m]
  (s : Stmt m Empty Γ ∅ false false α),
  D s ρ = do
    let x ← Stmt.eval ρ s ∅
    match x with
      | (Neut.val a, snd) =&gt; pure a</span></span></div></blockquote></div></small></div><span class="nv">D_eq</span></span><span class="alectryon-token"> (ρ := <span class="bp">·</span>) (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>S</var><b>: </b><span>{m : Type → Type} →
  {ω : Type} →
    {Γ Δ : List Type} →
      {α : Type} →
        {b c : Bool} →
          {β : Type} → [inst : Monad m] → Stmt m ω Γ (List.append Δ [α]) b c β → Stmt (StateT α m) ω (α :: Γ) Δ b c β</span></span></div></blockquote></div></small></div>S</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>Stmt m Empty Γ (α✝ :: ∅) false false α</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token">))</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span></span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>ρ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>α, α✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ</span> <span class="bp">→</span> Assg <span class="bp">∅</span> <span class="bp">→</span> α<span class="bp">✝</span></span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>Stmt m Empty <span class="bp">Γ</span> (α<span class="bp">✝</span> :: <span class="bp">∅</span>) false false α</span></span></span><br><span><var>this</var><span class="hyp-type"><b>: </b><span>Stmt.numExts (S s) <span class="bp">&lt;</span> Nat.succ (Stmt.numExts s)</span></span></span><br><span><var>ih</var><span class="hyp-type"><b>: </b><span><span class="bp">∀</span> (a : Assg (α<span class="bp">✝</span> :: <span class="bp">Γ</span>)),
  D (S s) a <span class="bp">=</span> <span class="k">do</span>
    <span class="k">let</span> x <span class="bp">←</span> Stmt.eval a (S s) <span class="bp">∅</span>
    <span class="k">match</span> x <span class="k">with</span>
      <span class="bp">|</span> (Neut.val a, snd) <span class="bp">=&gt;</span> pure a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">D (Stmt.letmut e s) ρ <span class="bp">=</span> <span class="k">do</span>
  <span class="k">let</span> x <span class="bp">←</span> Stmt.eval ρ (Stmt.letmut e s) <span class="bp">∅</span>
  <span class="k">match</span> x <span class="k">with</span>
    <span class="bp">|</span> (Neut.val a, snd) <span class="bp">=&gt;</span> pure a</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
    </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk123" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk123"><span class="alectryon-token"><span class="k">aesop</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><span class="k">add</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">safe</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">cases</span></span><span class="alectryon-token"> Neut, </span><span class="alectryon-token"><span class="k">norm</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">simp</span></span><span class="alectryon-token"> eval_S)</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt.ite</var><b>: </b><span>{m : Type → Type ?u.926338} →
  {ω : Type} →
    {Γ Δ : List Type} →
      {b c : Bool} →
        {α : Type} → (Assg Γ → Assg Δ → Bool) → Stmt m ω Γ Δ b c α → Stmt m ω Γ Δ b c α → Stmt m ω Γ Δ b c α</span></span></div></blockquote></div></small></div>Stmt.ite</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>Assg Γ → Assg ∅ → Bool</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s₁</var><b>: </b><span>Stmt m Empty Γ ∅ false false α</span></span></div></blockquote></div></small></div><span class="nv">s₁</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s₂</var><b>: </b><span>Stmt m Empty Γ ∅ false false α</span></span></div></blockquote></div></small></div><span class="nv">s₂</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk124" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk124"><span class="alectryon-token"><span class="kd">by</span></span><span class="alectryon-token"></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span></span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>ρ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ</span> <span class="bp">→</span> Assg <span class="bp">∅</span> <span class="bp">→</span> Bool</span></span></span><br><span><var>s₁, s₂</var><span class="hyp-type"><b>: </b><span>Stmt m Empty <span class="bp">Γ</span> <span class="bp">∅</span> false false α</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">D (Stmt.ite e s₁ s₂) ρ <span class="bp">=</span> <span class="k">do</span>
  <span class="k">let</span> x <span class="bp">←</span> Stmt.eval ρ (Stmt.ite e s₁ s₂) <span class="bp">∅</span>
  <span class="k">match</span> x <span class="k">with</span>
    <span class="bp">|</span> (Neut.val a, snd) <span class="bp">=&gt;</span> pure a</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk125" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk125"><span class="alectryon-token"><span class="k">simp</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span></span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>ρ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ</span> <span class="bp">→</span> Assg <span class="bp">∅</span> <span class="bp">→</span> Bool</span></span></span><br><span><var>s₁, s₂</var><span class="hyp-type"><b>: </b><span>Stmt m Empty <span class="bp">Γ</span> <span class="bp">∅</span> false false α</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="k">if</span> e ρ <span class="bp">∅</span> <span class="bp">=</span> true <span class="k">then</span> D s₁ ρ <span class="k">else</span> D s₂ ρ) <span class="bp">=</span> <span class="k">do</span>
  <span class="k">let</span> x <span class="bp">←</span> <span class="k">if</span> e ρ <span class="bp">∅</span> <span class="bp">=</span> true <span class="k">then</span> Stmt.eval ρ s₁ <span class="bp">∅</span> <span class="k">else</span> Stmt.eval ρ s₂ <span class="bp">∅</span>
  <span class="k">match</span> x <span class="k">with</span>
    <span class="bp">|</span> (Neut.val a, snd) <span class="bp">=&gt;</span> pure a</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"><span class="bp">;</span></span><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk126" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk126"><span class="alectryon-token"><span class="k">split</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span></span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>ρ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ</span> <span class="bp">→</span> Assg <span class="bp">∅</span> <span class="bp">→</span> Bool</span></span></span><br><span><var>s₁, s₂</var><span class="hyp-type"><b>: </b><span>Stmt m Empty <span class="bp">Γ</span> <span class="bp">∅</span> false false α</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">inl</span></span><div class="goal-conclusion">D s₁ ρ <span class="bp">=</span> <span class="k">do</span>
  <span class="k">let</span> x <span class="bp">←</span> Stmt.eval ρ s₁ <span class="bp">∅</span>
  <span class="k">match</span> x <span class="k">with</span>
    <span class="bp">|</span> (Neut.val a, snd) <span class="bp">=&gt;</span> pure a</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Formal-lean-chk127" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span></span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>ρ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ</span> <span class="bp">→</span> Assg <span class="bp">∅</span> <span class="bp">→</span> Bool</span></span></span><br><span><var>s₁, s₂</var><span class="hyp-type"><b>: </b><span>Stmt m Empty <span class="bp">Γ</span> <span class="bp">∅</span> false false α</span></span></span><br></div><label class="goal-separator" for="Formal-lean-chk127"><hr><span class="goal-name">inr</span></label><div class="goal-conclusion">D s₂ ρ <span class="bp">=</span> <span class="k">do</span>
  <span class="k">let</span> x <span class="bp">←</span> Stmt.eval ρ s₂ <span class="bp">∅</span>
  <span class="k">match</span> x <span class="k">with</span>
    <span class="bp">|</span> (Neut.val a, snd) <span class="bp">=&gt;</span> pure a</div></blockquote></div></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk128" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk128"><span class="alectryon-token"><span class="k">&lt;;&gt;</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span></span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>ρ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ</span> <span class="bp">→</span> Assg <span class="bp">∅</span> <span class="bp">→</span> Bool</span></span></span><br><span><var>s₁, s₂</var><span class="hyp-type"><b>: </b><span>Stmt m Empty <span class="bp">Γ</span> <span class="bp">∅</span> false false α</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">inl</span></span><div class="goal-conclusion">D s₁ ρ <span class="bp">=</span> <span class="k">do</span>
  <span class="k">let</span> x <span class="bp">←</span> Stmt.eval ρ s₁ <span class="bp">∅</span>
  <span class="k">match</span> x <span class="k">with</span>
    <span class="bp">|</span> (Neut.val a, snd) <span class="bp">=&gt;</span> pure a</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Formal-lean-chk129" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span></span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>ρ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ</span> <span class="bp">→</span> Assg <span class="bp">∅</span> <span class="bp">→</span> Bool</span></span></span><br><span><var>s₁, s₂</var><span class="hyp-type"><b>: </b><span>Stmt m Empty <span class="bp">Γ</span> <span class="bp">∅</span> false false α</span></span></span><br></div><label class="goal-separator" for="Formal-lean-chk129"><hr><span class="goal-name">inr</span></label><div class="goal-conclusion">D s₂ ρ <span class="bp">=</span> <span class="k">do</span>
  <span class="k">let</span> x <span class="bp">←</span> Stmt.eval ρ s₂ <span class="bp">∅</span>
  <span class="k">match</span> x <span class="k">with</span>
    <span class="bp">|</span> (Neut.val a, snd) <span class="bp">=&gt;</span> pure a</div></blockquote></div></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk12a" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk12a"><span class="alectryon-token"><span class="k">simp</span></span><span class="alectryon-token"> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>D_eq</var><b>: </b><span>∀ {m : Type → Type} {Γ : List Type} {α : Type} {ρ : Assg Γ} [inst : Monad m] [inst_1 : LawfulMonad m]
  (s : Stmt m Empty Γ ∅ false false α),
  D s ρ = do
    let x ← Stmt.eval ρ s ∅
    match x with
      | (Neut.val a, snd) =&gt; pure a</span></span></div></blockquote></div></small></div><span class="nv">D_eq</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s₁</var><b>: </b><span>Stmt m Empty Γ ∅ false false α</span></span></div></blockquote></div></small></div><span class="nv">s₁</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>D_eq</var><b>: </b><span>∀ {m : Type → Type} {Γ : List Type} {α : Type} {ρ : Assg Γ} [inst : Monad m] [inst_1 : LawfulMonad m]
  (s : Stmt m Empty Γ ∅ false false α),
  D s ρ = do
    let x ← Stmt.eval ρ s ∅
    match x with
      | (Neut.val a, snd) =&gt; pure a</span></span></div></blockquote></div></small></div><span class="nv">D_eq</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s₂</var><b>: </b><span>Stmt m Empty Γ ∅ false false α</span></span></div></blockquote></div></small></div><span class="nv">s₂</span></span><span class="alectryon-token">]</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt.ret</var><b>: </b><span>{m : Type → Type ?u.926403} →
  {ω : Type} → {Γ Δ : List Type} → {b c : Bool} → {α : Type} → (Assg Γ → Assg Δ → ω) → Stmt m ω Γ Δ b c α</span></span></div></blockquote></div></small></div>Stmt.ret</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>Assg Γ → Assg ∅ → Empty</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><span class="k">nomatch</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>Assg Γ → Assg ∅ → Empty</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ρ</var><b>: </b><span>Assg Γ</span></span></div></blockquote></div></small></div><span class="nv">ρ</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>∅</var><b>: </b><span>Assg ∅</span></span></div></blockquote></div></small></div><span class="bp">∅</span></span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt.sfor</var><b>: </b><span>{m : Type → Type ?u.926500} →
  {ω : Type} →
    {Γ Δ : List Type} →
      {α : Type} →
        {b c : Bool} → (Assg Γ → Assg Δ → List α) → Stmt m ω (α :: Γ) Δ true true Unit → Stmt m ω Γ Δ b c Unit</span></span></div></blockquote></div></small></div>Stmt.sfor</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>Assg Γ → Assg ∅ → List α✝</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>Stmt m Empty (α✝ :: Γ) ∅ true true Unit</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk12b" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk12b"><span class="alectryon-token"><span class="kd">by</span></span><span class="alectryon-token"></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span></span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>ρ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>α✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ</span> <span class="bp">→</span> Assg <span class="bp">∅</span> <span class="bp">→</span> List α<span class="bp">✝</span></span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>Stmt m Empty (α<span class="bp">✝</span> :: <span class="bp">Γ</span>) <span class="bp">∅</span> true true Unit</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">D (Stmt.sfor e s) ρ <span class="bp">=</span> <span class="k">do</span>
  <span class="k">let</span> x <span class="bp">←</span> Stmt.eval ρ (Stmt.sfor e s) <span class="bp">∅</span>
  <span class="k">match</span> x <span class="k">with</span>
    <span class="bp">|</span> (Neut.val a, snd) <span class="bp">=&gt;</span> pure a</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
    </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk12c" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk12c"><span class="alectryon-token"><span class="k">have</span></span><span class="alectryon-token"> := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat.lt_succ_of_le</var><b>: </b><span>∀ {n m : Nat}, n ≤ m → n &lt; Nat.succ m</span></span></div></blockquote></div></small></div>Nat.lt_succ_of_le</span><span class="alectryon-token"> <span class="bp">&lt;|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt.numExts_C_B</var><b>: </b><span>∀ {m : Type → Type} {ω : Type} {Γ Δ : List Type} {b c : Bool} {β : Type} [inst : Monad m] (s : Stmt m ω Γ Δ b c β),
  Stmt.numExts (C (B s)) ≤ Stmt.numExts s</span></span></div></blockquote></div></small></div>Stmt.numExts_C_B</span><span class="alectryon-token"> (<span class="bp">Δ</span> := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>[]</var><b>: </b><span>List Type</span></span></div></blockquote></div></small></div>[]</span><span class="alectryon-token">) </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>Stmt m Empty (α✝ :: Γ) ∅ true true Unit</span></span></div></blockquote></div></small></div><span class="nv">s</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span></span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>ρ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>α✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ</span> <span class="bp">→</span> Assg <span class="bp">∅</span> <span class="bp">→</span> List α<span class="bp">✝</span></span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>Stmt m Empty (α<span class="bp">✝</span> :: <span class="bp">Γ</span>) <span class="bp">∅</span> true true Unit</span></span></span><br><span><var>this</var><span class="hyp-type"><b>: </b><span>Stmt.numExts (C (B s)) <span class="bp">&lt;</span> Nat.succ (Stmt.numExts s)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">D (Stmt.sfor e s) ρ <span class="bp">=</span> <span class="k">do</span>
  <span class="k">let</span> x <span class="bp">←</span> Stmt.eval ρ (Stmt.sfor e s) <span class="bp">∅</span>
  <span class="k">match</span> x <span class="k">with</span>
    <span class="bp">|</span> (Neut.val a, snd) <span class="bp">=&gt;</span> pure a</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk12d" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk12d"><span class="alectryon-token"><span class="c1">-- for termination</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span></span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>ρ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>α✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ</span> <span class="bp">→</span> Assg <span class="bp">∅</span> <span class="bp">→</span> List α<span class="bp">✝</span></span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>Stmt m Empty (α<span class="bp">✝</span> :: <span class="bp">Γ</span>) <span class="bp">∅</span> true true Unit</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">D (Stmt.sfor e s) ρ <span class="bp">=</span> <span class="k">do</span>
  <span class="k">let</span> x <span class="bp">←</span> Stmt.eval ρ (Stmt.sfor e s) <span class="bp">∅</span>
  <span class="k">match</span> x <span class="k">with</span>
    <span class="bp">|</span> (Neut.val a, snd) <span class="bp">=&gt;</span> pure a</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
    </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk12e" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk12e"><span class="alectryon-token"><span class="k">have</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ih</var><b>: </b><span>∀ (a : Assg (α✝ :: Γ)),
  D (C (B s)) a = do
    let x ← Stmt.eval a (C (B s)) ∅
    match x with
      | (Neut.val a, snd) =&gt; pure a</span></span></div></blockquote></div></small></div><span class="nv">ih</span></span><span class="alectryon-token"> := (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>D_eq</var><b>: </b><span>∀ {m : Type → Type} {Γ : List Type} {α : Type} {ρ : Assg Γ} [inst : Monad m] [inst_1 : LawfulMonad m]
  (s : Stmt m Empty Γ ∅ false false α),
  D s ρ = do
    let x ← Stmt.eval ρ s ∅
    match x with
      | (Neut.val a, snd) =&gt; pure a</span></span></div></blockquote></div></small></div><span class="nv">D_eq</span></span><span class="alectryon-token"> (ρ := <span class="bp">·</span>) (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>C</var><b>: </b><span>{m : Type → Type} →
  {ω : Type} →
    {Γ Δ : List Type} →
      {c : Bool} → {α : Type} → [inst : Monad m] → Stmt m ω Γ Δ false c α → Stmt (ExceptT Unit m) ω Γ Δ false false α</span></span></div></blockquote></div></small></div>C</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>B</var><b>: </b><span>{m : Type → Type} →
  {ω : Type} →
    {Γ Δ : List Type} →
      {b c : Bool} → {α : Type} → [inst : Monad m] → Stmt m ω Γ Δ b c α → Stmt (ExceptT Unit m) ω Γ Δ false c α</span></span></div></blockquote></div></small></div>B</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>Stmt m Empty (α✝ :: Γ) ∅ true true Unit</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token">)))</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span></span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>ρ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>α✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ</span> <span class="bp">→</span> Assg <span class="bp">∅</span> <span class="bp">→</span> List α<span class="bp">✝</span></span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>Stmt m Empty (α<span class="bp">✝</span> :: <span class="bp">Γ</span>) <span class="bp">∅</span> true true Unit</span></span></span><br><span><var>this</var><span class="hyp-type"><b>: </b><span>Stmt.numExts (C (B s)) <span class="bp">&lt;</span> Nat.succ (Stmt.numExts s)</span></span></span><br><span><var>ih</var><span class="hyp-type"><b>: </b><span><span class="bp">∀</span> (a : Assg (α<span class="bp">✝</span> :: <span class="bp">Γ</span>)),
  D (C (B s)) a <span class="bp">=</span> <span class="k">do</span>
    <span class="k">let</span> x <span class="bp">←</span> Stmt.eval a (C (B s)) <span class="bp">∅</span>
    <span class="k">match</span> x <span class="k">with</span>
      <span class="bp">|</span> (Neut.val a, snd) <span class="bp">=&gt;</span> pure a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">D (Stmt.sfor e s) ρ <span class="bp">=</span> <span class="k">do</span>
  <span class="k">let</span> x <span class="bp">←</span> Stmt.eval ρ (Stmt.sfor e s) <span class="bp">∅</span>
  <span class="k">match</span> x <span class="k">with</span>
    <span class="bp">|</span> (Neut.val a, snd) <span class="bp">=&gt;</span> pure a</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
    </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk12f" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk12f"><span class="alectryon-token"><span class="k">simp</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span></span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>ρ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>α✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ</span> <span class="bp">→</span> Assg <span class="bp">∅</span> <span class="bp">→</span> List α<span class="bp">✝</span></span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>Stmt m Empty (α<span class="bp">✝</span> :: <span class="bp">Γ</span>) <span class="bp">∅</span> true true Unit</span></span></span><br><span><var>this</var><span class="hyp-type"><b>: </b><span>Stmt.numExts (C (B s)) <span class="bp">&lt;</span> Nat.succ (Stmt.numExts s)</span></span></span><br><span><var>ih</var><span class="hyp-type"><b>: </b><span><span class="bp">∀</span> (a : Assg (α<span class="bp">✝</span> :: <span class="bp">Γ</span>)),
  D (C (B s)) a <span class="bp">=</span> <span class="k">do</span>
    <span class="k">let</span> x <span class="bp">←</span> Stmt.eval a (C (B s)) <span class="bp">∅</span>
    <span class="k">match</span> x <span class="k">with</span>
      <span class="bp">|</span> (Neut.val a, snd) <span class="bp">=&gt;</span> pure a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">runCatch (forM (e ρ <span class="bp">∅</span>) <span class="k">fun</span> x <span class="bp">=&gt;</span> runCatch (D (C (B s)) (x :: ρ))) <span class="bp">=</span> <span class="k">do</span>
  <span class="k">let</span> x <span class="bp">←</span> Stmt.eval.go ρ false false α<span class="bp">✝</span> s <span class="bp">∅</span> (e ρ <span class="bp">∅</span>)
  <span class="k">match</span> x <span class="k">with</span>
    <span class="bp">|</span> (Neut.val a, snd) <span class="bp">=&gt;</span> pure a</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
    </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk130" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk130"><span class="alectryon-token"><span class="k">induction</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>Assg Γ → Assg ∅ → List α✝</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ρ</var><b>: </b><span>Assg Γ</span></span></div></blockquote></div></small></div><span class="nv">ρ</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>∅</var><b>: </b><span>Assg ∅</span></span></div></blockquote></div></small></div><span class="k">∅</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span></span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>ρ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>α✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ</span> <span class="bp">→</span> Assg <span class="bp">∅</span> <span class="bp">→</span> List α<span class="bp">✝</span></span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>Stmt m Empty (α<span class="bp">✝</span> :: <span class="bp">Γ</span>) <span class="bp">∅</span> true true Unit</span></span></span><br><span><var>this</var><span class="hyp-type"><b>: </b><span>Stmt.numExts (C (B s)) <span class="bp">&lt;</span> Nat.succ (Stmt.numExts s)</span></span></span><br><span><var>ih</var><span class="hyp-type"><b>: </b><span><span class="bp">∀</span> (a : Assg (α<span class="bp">✝</span> :: <span class="bp">Γ</span>)),
  D (C (B s)) a <span class="bp">=</span> <span class="k">do</span>
    <span class="k">let</span> x <span class="bp">←</span> Stmt.eval a (C (B s)) <span class="bp">∅</span>
    <span class="k">match</span> x <span class="k">with</span>
      <span class="bp">|</span> (Neut.val a, snd) <span class="bp">=&gt;</span> pure a</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">nil</span></span><div class="goal-conclusion">runCatch (forM [] <span class="k">fun</span> x <span class="bp">=&gt;</span> runCatch (D (C (B s)) (x :: ρ))) <span class="bp">=</span> <span class="k">do</span>
  <span class="k">let</span> x <span class="bp">←</span> Stmt.eval.go ρ false false α<span class="bp">✝</span> s <span class="bp">∅</span> []
  <span class="k">match</span> x <span class="k">with</span>
    <span class="bp">|</span> (Neut.val a, snd) <span class="bp">=&gt;</span> pure a</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Formal-lean-chk131" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span></span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>ρ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>α✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ</span> <span class="bp">→</span> Assg <span class="bp">∅</span> <span class="bp">→</span> List α<span class="bp">✝</span></span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>Stmt m Empty (α<span class="bp">✝</span> :: <span class="bp">Γ</span>) <span class="bp">∅</span> true true Unit</span></span></span><br><span><var>this</var><span class="hyp-type"><b>: </b><span>Stmt.numExts (C (B s)) <span class="bp">&lt;</span> Nat.succ (Stmt.numExts s)</span></span></span><br><span><var>ih</var><span class="hyp-type"><b>: </b><span><span class="bp">∀</span> (a : Assg (α<span class="bp">✝</span> :: <span class="bp">Γ</span>)),
  D (C (B s)) a <span class="bp">=</span> <span class="k">do</span>
    <span class="k">let</span> x <span class="bp">←</span> Stmt.eval a (C (B s)) <span class="bp">∅</span>
    <span class="k">match</span> x <span class="k">with</span>
      <span class="bp">|</span> (Neut.val a, snd) <span class="bp">=&gt;</span> pure a</span></span></span><br><span><var>head✝</var><span class="hyp-type"><b>: </b><span>α<span class="bp">✝</span></span></span></span><br><span><var>tail✝</var><span class="hyp-type"><b>: </b><span>List α<span class="bp">✝</span></span></span></span><br></div><label class="goal-separator" for="Formal-lean-chk131"><hr><span class="goal-name">cons</span></label><div class="goal-conclusion">runCatch (forM (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) <span class="k">fun</span> x <span class="bp">=&gt;</span> runCatch (D (C (B s)) (x :: ρ))) <span class="bp">=</span> <span class="k">do</span>
  <span class="k">let</span> x <span class="bp">←</span> Stmt.eval.go ρ false false α<span class="bp">✝</span> s <span class="bp">∅</span> (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>)
  <span class="k">match</span> x <span class="k">with</span>
    <span class="bp">|</span> (Neut.val a, snd) <span class="bp">=&gt;</span> pure a</div></blockquote></div></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk132" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk132"><span class="alectryon-token"><span class="k">&lt;;&gt;</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span></span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>ρ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>α✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ</span> <span class="bp">→</span> Assg <span class="bp">∅</span> <span class="bp">→</span> List α<span class="bp">✝</span></span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>Stmt m Empty (α<span class="bp">✝</span> :: <span class="bp">Γ</span>) <span class="bp">∅</span> true true Unit</span></span></span><br><span><var>this</var><span class="hyp-type"><b>: </b><span>Stmt.numExts (C (B s)) <span class="bp">&lt;</span> Nat.succ (Stmt.numExts s)</span></span></span><br><span><var>ih</var><span class="hyp-type"><b>: </b><span><span class="bp">∀</span> (a : Assg (α<span class="bp">✝</span> :: <span class="bp">Γ</span>)),
  D (C (B s)) a <span class="bp">=</span> <span class="k">do</span>
    <span class="k">let</span> x <span class="bp">←</span> Stmt.eval a (C (B s)) <span class="bp">∅</span>
    <span class="k">match</span> x <span class="k">with</span>
      <span class="bp">|</span> (Neut.val a, snd) <span class="bp">=&gt;</span> pure a</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">nil</span></span><div class="goal-conclusion">runCatch (forM [] <span class="k">fun</span> x <span class="bp">=&gt;</span> runCatch (D (C (B s)) (x :: ρ))) <span class="bp">=</span> <span class="k">do</span>
  <span class="k">let</span> x <span class="bp">←</span> Stmt.eval.go ρ false false α<span class="bp">✝</span> s <span class="bp">∅</span> []
  <span class="k">match</span> x <span class="k">with</span>
    <span class="bp">|</span> (Neut.val a, snd) <span class="bp">=&gt;</span> pure a</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Formal-lean-chk133" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span></span></span></span><br><span><var>Γ</var><span class="hyp-type"><b>: </b><span>List <span class="kt">Type</span></span></span></span><br><span><var>ρ</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>α✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>Assg <span class="bp">Γ</span> <span class="bp">→</span> Assg <span class="bp">∅</span> <span class="bp">→</span> List α<span class="bp">✝</span></span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>Stmt m Empty (α<span class="bp">✝</span> :: <span class="bp">Γ</span>) <span class="bp">∅</span> true true Unit</span></span></span><br><span><var>this</var><span class="hyp-type"><b>: </b><span>Stmt.numExts (C (B s)) <span class="bp">&lt;</span> Nat.succ (Stmt.numExts s)</span></span></span><br><span><var>ih</var><span class="hyp-type"><b>: </b><span><span class="bp">∀</span> (a : Assg (α<span class="bp">✝</span> :: <span class="bp">Γ</span>)),
  D (C (B s)) a <span class="bp">=</span> <span class="k">do</span>
    <span class="k">let</span> x <span class="bp">←</span> Stmt.eval a (C (B s)) <span class="bp">∅</span>
    <span class="k">match</span> x <span class="k">with</span>
      <span class="bp">|</span> (Neut.val a, snd) <span class="bp">=&gt;</span> pure a</span></span></span><br><span><var>head✝</var><span class="hyp-type"><b>: </b><span>α<span class="bp">✝</span></span></span></span><br><span><var>tail✝</var><span class="hyp-type"><b>: </b><span>List α<span class="bp">✝</span></span></span></span><br></div><label class="goal-separator" for="Formal-lean-chk133"><hr><span class="goal-name">cons</span></label><div class="goal-conclusion">runCatch (forM (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) <span class="k">fun</span> x <span class="bp">=&gt;</span> runCatch (D (C (B s)) (x :: ρ))) <span class="bp">=</span> <span class="k">do</span>
  <span class="k">let</span> x <span class="bp">←</span> Stmt.eval.go ρ false false α<span class="bp">✝</span> s <span class="bp">∅</span> (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>)
  <span class="k">match</span> x <span class="k">with</span>
    <span class="bp">|</span> (Neut.val a, snd) <span class="bp">=&gt;</span> pure a</div></blockquote></div></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk134" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk134"><span class="alectryon-token"><span class="k">aesop</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><span class="k">add</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">safe</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">cases</span></span><span class="alectryon-token"> Neut, </span><span class="alectryon-token"><span class="k">norm</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">unfold</span></span><span class="alectryon-token"> runCatch, </span><span class="alectryon-token"><span class="k">norm</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">simp</span></span><span class="alectryon-token"> [eval_C, eval_B])</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
</span><span class="alectryon-token"><span class="k">termination_by</span></span><span class="alectryon-token"> _ s <span class="bp">=&gt;</span> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>Stmt m Empty Γ ∅ false false α</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>numExts</var><b>: </b><span>{m : Type → Type} → {ω : Type} → {Γ Δ : List Type} → {b c : Bool} → {α : Type} → Stmt m ω Γ Δ b c α → Nat</span></span></div></blockquote></div></small></div>numExts</span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>sizeOf</var><b>: </b><span>{α : Type 1} → [self : SizeOf α] → α → Nat</span></span></div></blockquote></div></small></div>sizeOf</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>Stmt m Empty Γ ∅ false false α</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token">)
</span><span class="alectryon-token"><span class="k">decreasing_by</span></span><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk135" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk135"><span class="alectryon-token"><span class="k">D_tac</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span></pre>
<p>The equivalence proof cited in the paper follows from the invariants of <code>D</code> and <code>R</code>.</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">theorem</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Do.trans_eq_eval</var><b>: </b><span>∀ {m : Type → Type} {α : Type} [inst : Monad m] [inst_1 : LawfulMonad m] (s : Do m α), trans s = ⟦s⟧</span></span></div></blockquote></div></small></div><span class="nv">Do.trans_eq_eval</span></span><span class="alectryon-token"> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Monad</var><b>: </b><span>(Type → Type) → Type 1</span></span></div></blockquote></div></small></div>Monad</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>Type → Type</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token">] [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>LawfulMonad</var><b>: </b><span>(m : Type ?u.1069260 → Type ?u.1069259) → [inst : Monad m] → Prop</span></span></div></blockquote></div></small></div>LawfulMonad</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>Type → Type</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token">] : <span class="bp">∀</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>Do m α</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Do</var><b>: </b><span>(Type → Type) → Type → Type 1</span></span></div></blockquote></div></small></div>Do</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>Type → Type</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Do.trans</var><b>: </b><span>{m : Type → Type} → {α : Type} → [inst : Monad m] → Do m α → m α</span></span></div></blockquote></div></small></div>Do.trans</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>Do m α</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token"> <span class="bp">=</span> <span class="bp">⟦</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>Do m α</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token"><span class="bp">⟧</span> := </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk136" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk136"><span class="alectryon-token"><span class="kd">by</span></span><span class="alectryon-token"></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span></span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="bp">∀</span> (s : Do m α), trans s <span class="bp">=</span> <span class="bp">⟦</span>s<span class="bp">⟧</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk137" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk137"><span class="alectryon-token"><span class="k">aesop</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><span class="k">add</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">norm</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">simp</span></span><span class="alectryon-token"> [D_eq, eval_R], </span><span class="alectryon-token"><span class="k">norm</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">unfold</span></span><span class="alectryon-token"> [runCatch, Do.trans, Do.eval])</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span></pre>
<h2 id="partial-evaluation"><a class="header" href="#partial-evaluation">Partial Evaluation</a></h2>
<p>We define a new term notation <code>simp [...] in e</code> that rewrites the term e using the given
simplification theorems.</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kn">open</span></span><span class="alectryon-token"> Lean </span><span class="alectryon-token"><span class="k">in</span></span><span class="alectryon-token">
</span><span class="alectryon-token"><span class="kn">open</span></span><span class="alectryon-token"> Lean.Parser.Tactic </span><span class="alectryon-token"><span class="k">in</span></span><span class="alectryon-token">
</span><span class="alectryon-token"><span class="kn">open</span></span><span class="alectryon-token"> Lean.Meta </span><span class="alectryon-token"><span class="k">in</span></span><span class="alectryon-token">
</span><span class="alectryon-token"><span class="kn">open</span></span><span class="alectryon-token"> Lean.Elab </span><span class="alectryon-token"><span class="k">in</span></span><span class="alectryon-token">
</span><span class="alectryon-token"><span class="k">elab</span></span><span class="alectryon-token"> <span class="s2">&quot;simp&quot;</span> <span class="s2">&quot;[&quot;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>simps</var><b>: </b><span>Syntax.TSepArray `Lean.Parser.Tactic.simpLemma &quot;,&quot;</span></span></div></blockquote></div></small></div><span class="nv">simps</span></span><span class="alectryon-token">:</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>simpLemma</var><b>: </b><span>ParserDescr</span></span></div></blockquote></div></small></div>simpLemma</span><span class="alectryon-token">,<span class="bp">*</span> <span class="s2">&quot;]&quot;</span> <span class="s2">&quot;in&quot;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>TSyntax `term</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token">:term : term <span class="bp">=&gt;</span> </span><span class="alectryon-token"><span class="k">do</span></span><span class="alectryon-token">
  <span class="c1">-- construct goal `⊢ e = ?x` with fresh metavariable `?x`, simplify, solve by reflexivity,</span>
  <span class="c1">-- and return assigned value of `?x`</span>
  </span><span class="alectryon-token"><span class="k">let</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>Expr</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token"> <span class="bp">←</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Term.elabTermAndSynthesize</var><b>: </b><span>Syntax → Option Expr → TermElabM Expr</span></span></div></blockquote></div></small></div>Term.elabTermAndSynthesize</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>TSyntax `term</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>none</var><b>: </b><span>{α : Type} → Option α</span></span></div></blockquote></div></small></div>none</span><span class="alectryon-token">
  </span><span class="alectryon-token"><span class="k">let</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>Expr</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> <span class="bp">←</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>mkFreshExprMVar</var><b>: </b><span>Option Expr → optParam MetavarKind MetavarKind.natural → optParam Name Name.anonymous → MetaM Expr</span></span></div></blockquote></div></small></div>mkFreshExprMVar</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>(← inferType e)</var><b>: </b><span>Expr</span></span></div></blockquote></div></small></div>(<span class="bp">←</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>inferType</var><b>: </b><span>Expr → MetaM Expr</span></span></div></blockquote></div></small></div><span class="nv">inferType</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>(← inferType e)</var><b>: </b><span>Expr</span></span></div></blockquote></div></small></div> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>Expr</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>(← inferType e)</var><b>: </b><span>Expr</span></span></div></blockquote></div></small></div>)</span><span class="alectryon-token">
  </span><span class="alectryon-token"><span class="k">let</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>goal</var><b>: </b><span>Expr</span></span></div></blockquote></div></small></div><span class="nv">goal</span></span><span class="alectryon-token"> <span class="bp">←</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>mkFreshExprMVar</var><b>: </b><span>Option Expr → optParam MetavarKind MetavarKind.natural → optParam Name Name.anonymous → MetaM Expr</span></span></div></blockquote></div></small></div>mkFreshExprMVar</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>(← mkEq e x)</var><b>: </b><span>Expr</span></span></div></blockquote></div></small></div>(<span class="bp">←</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>mkEq</var><b>: </b><span>Expr → Expr → MetaM Expr</span></span></div></blockquote></div></small></div><span class="nv">mkEq</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>(← mkEq e x)</var><b>: </b><span>Expr</span></span></div></blockquote></div></small></div> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>Expr</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>(← mkEq e x)</var><b>: </b><span>Expr</span></span></div></blockquote></div></small></div> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>Expr</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>(← mkEq e x)</var><b>: </b><span>Expr</span></span></div></blockquote></div></small></div>)</span><span class="alectryon-token">
  <span class="c1">-- disable ζ-reduction to preserve `let`s</span>
  </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Term.runTactic</var><b>: </b><span>MVarId → Syntax → TermElabM Unit</span></span></div></blockquote></div></small></div>Term.runTactic</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>goal</var><b>: </b><span>Expr</span></span></div></blockquote></div></small></div><span class="nv">goal</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>mvarId!</var><b>: </b><span>Expr → MVarId</span></span></div></blockquote></div></small></div>mvarId<span class="bp">!</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>(← `(tactic| (simp (config := { zeta := false }) [$simps:simpLemma,*]; rfl)))</var><b>: </b><span>TSyntax `tactic</span></span></div></blockquote></div></small></div>(<span class="bp">←</span> <span class="bp">`</span>(tactic<span class="bp">|</span> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>(← `(tactic| (simp (config := { zeta := false }) [$simps:simpLemma,*]; rfl)))</var><b>: </b><span>TSyntax `tactic</span></span></div></blockquote></div></small></div><span class="k">simp</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>(← `(tactic| (simp (config := { zeta := false }) [$simps:simpLemma,*]; rfl)))</var><b>: </b><span>TSyntax `tactic</span></span></div></blockquote></div></small></div> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>(← `(tactic| (simp (config := { zeta := false }) [$simps:simpLemma,*]; rfl)))</var><b>: </b><span>TSyntax `tactic</span></span></div></blockquote></div></small></div><span class="k">config</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>(← `(tactic| (simp (config := { zeta := false }) [$simps:simpLemma,*]; rfl)))</var><b>: </b><span>TSyntax `tactic</span></span></div></blockquote></div></small></div> := { zeta := false }) [<span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>simps</var><b>: </b><span>Syntax.TSepArray `Lean.Parser.Tactic.simpLemma &quot;,&quot;</span></span></div></blockquote></div></small></div><span class="nv">simps</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>(← `(tactic| (simp (config := { zeta := false }) [$simps:simpLemma,*]; rfl)))</var><b>: </b><span>TSyntax `tactic</span></span></div></blockquote></div></small></div>:simpLemma,<span class="bp">*</span>]<span class="bp">;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>(← `(tactic| (simp (config := { zeta := false }) [$simps:simpLemma,*]; rfl)))</var><b>: </b><span>TSyntax `tactic</span></span></div></blockquote></div></small></div><span class="k">rfl</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>(← `(tactic| (simp (config := { zeta := false }) [$simps:simpLemma,*]; rfl)))</var><b>: </b><span>TSyntax `tactic</span></span></div></blockquote></div></small></div>)))</span><span class="alectryon-token">
  </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>instantiateMVars</var><b>: </b><span>{m : Type → Type} → [inst : Monad m] → [inst : MonadMCtx m] → Expr → m Expr</span></span></div></blockquote></div></small></div>instantiateMVars</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>Expr</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token">

<span class="c1">-- further clean up generated programs</span>
</span><span class="alectryon-token"><span class="kn">attribute</span></span><span class="alectryon-token"> [</span><span class="alectryon-token"><span class="kn">local</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">simp</span></span><span class="alectryon-token">] </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Assg.extendBot</var><b>: </b><span>{α : Type u_1} → α → {Γ : List (Type u_1)} → Assg Γ → Assg (List.append Γ [α])</span></span></div></blockquote></div></small></div>Assg.extendBot</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>cast</var><b>: </b><span>{α β : Sort u} → α = β → α → β</span></span></div></blockquote></div></small></div>cast</span><span class="alectryon-token">
</span><span class="alectryon-token"><span class="kn">attribute</span></span><span class="alectryon-token"> [<span class="bp">-</span>simp] </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>StateT.run'_eq</var><b>: </b><span>∀ {m : Type u_1 → Type u_2} {σ α : Type u_1} [inst : Monad m] (x : StateT σ m α) (s : σ),
  StateT.run' x s = (fun a =&gt; a.fst) &lt;$&gt; StateT.run x s</span></span></div></blockquote></div></small></div>StateT.run&#39;_eq</span><span class="alectryon-token"></span></span></pre>
<p>We can now use this new notation to completely erase the translation functions
from an invocation on the example <code>ex2</code> from <code>For.lean</code> (manually translated to <code>Stmt</code>).</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="c">/-</span><span class="cm"></span>
<span class="cm">let mut y := init;</span>
<span class="cm">for x in xs do&#39; {</span>
<span class="cm">  y ← f y x</span>
<span class="cm">};</span>
<span class="cm">return y</span>
<span class="cm">-/</span>

</span><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ex2'</var><b>: </b><span>{m : Type → Type} → {β α : Type} → [inst : Monad m] → (β → α → m β) → β → List α → m β</span></span></div></blockquote></div></small></div><span class="nv">ex2&#39;</span></span><span class="alectryon-token"> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Monad</var><b>: </b><span>(Type ?u.1085514 → Type ?u.1085513) → Type (max (?u.1085514 + 1) ?u.1085513)</span></span></div></blockquote></div></small></div>Monad</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>Type → Type</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token">] (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>β → α → m β</span></span></div></blockquote></div></small></div><span class="nv">f</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>β</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">β</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>Type → Type</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>β</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">β</span></span><span class="alectryon-token">) (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>init</var><b>: </b><span>β</span></span></div></blockquote></div></small></div><span class="nv">init</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>β</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">β</span></span><span class="alectryon-token">) (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>xs</var><b>: </b><span>List α</span></span></div></blockquote></div></small></div><span class="nv">xs</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>List</var><b>: </b><span>Type → Type</span></span></div></blockquote></div></small></div>List</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token">) : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>Type → Type</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>β</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">β</span></span><span class="alectryon-token"> :=
  </span><span class="alectryon-token"><span class="k">simp</span></span><span class="alectryon-token"> [Do.trans] </span><span class="alectryon-token"><span class="k">in</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Do.trans</var><b>: </b><span>{m : Type → Type} → {α : Type} → [inst : Monad m] → Do m α → m α</span></span></div></blockquote></div></small></div>Do.trans</span><span class="alectryon-token"> (
      </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt.letmut</var><b>: </b><span>{m : Type → Type} →
  {ω : Type} →
    {Γ Δ : List Type} →
      {α : Type} → {b c : Bool} → {β : Type} → (Assg Γ → Assg Δ → α) → Stmt m ω Γ (α :: Δ) b c β → Stmt m ω Γ Δ b c β</span></span></div></blockquote></div></small></div>Stmt.letmut</span><span class="alectryon-token"> (</span><span class="alectryon-token"><span class="k">fun</span></span><span class="alectryon-token"> _ _ <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>init</var><b>: </b><span>β</span></span></div></blockquote></div></small></div><span class="nv">init</span></span><span class="alectryon-token">) <span class="bp">&lt;|</span>
      </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt.bind</var><b>: </b><span>{m : Type → Type} →
  {ω : Type} →
    {Γ Δ : List Type} →
      {b c : Bool} → {α β : Type} → Stmt m ω Γ Δ b c α → Stmt m ω (α :: Γ) Δ b c β → Stmt m ω Γ Δ b c β</span></span></div></blockquote></div></small></div>Stmt.bind</span><span class="alectryon-token"> (
        </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt.sfor</var><b>: </b><span>{m : Type → Type} →
  {ω : Type} →
    {Γ Δ : List Type} →
      {α : Type} →
        {b c : Bool} → (Assg Γ → Assg Δ → List α) → Stmt m ω (α :: Γ) Δ true true Unit → Stmt m ω Γ Δ b c Unit</span></span></div></blockquote></div></small></div>Stmt.sfor</span><span class="alectryon-token"> (</span><span class="alectryon-token"><span class="k">fun</span></span><span class="alectryon-token"> _ _ <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>xs</var><b>: </b><span>List α</span></span></div></blockquote></div></small></div><span class="nv">xs</span></span><span class="alectryon-token">) <span class="bp">&lt;|</span>
        <span class="c1">-- `y ← f y x` unfolded to `let z ← f y x; y := z` (A4)</span>
        </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt.bind</var><b>: </b><span>{m : Type → Type} →
  {ω : Type} →
    {Γ Δ : List Type} →
      {b c : Bool} → {α β : Type} → Stmt m ω Γ Δ b c α → Stmt m ω (α :: Γ) Δ b c β → Stmt m ω Γ Δ b c β</span></span></div></blockquote></div></small></div>Stmt.bind</span><span class="alectryon-token">
          (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt.expr</var><b>: </b><span>{m : Type → Type} →
  {ω : Type} → {Γ Δ : List Type} → {α : Type} → {b c : Bool} → (Assg Γ → Assg Δ → m α) → Stmt m ω Γ Δ b c α</span></span></div></blockquote></div></small></div>Stmt.expr</span><span class="alectryon-token"> (</span><span class="alectryon-token"><span class="k">fun</span></span><span class="alectryon-token"> ([</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token">]) ([</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>y</var><b>: </b><span>β</span></span></div></blockquote></div></small></div><span class="nv">y</span></span><span class="alectryon-token">]) <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>β → α → m β</span></span></div></blockquote></div></small></div><span class="nv">f</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>y</var><b>: </b><span>β</span></span></div></blockquote></div></small></div><span class="nv">y</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token">))
          (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt.assg</var><b>: </b><span>{m : Type → Type} →
  {ω : Type} →
    {Γ Δ : List Type} →
      {b c : Bool} → (x : Fin (List.length Δ)) → (Assg Γ → Assg Δ → List.get Δ x) → Stmt m ω Γ Δ b c Unit</span></span></div></blockquote></div></small></div>Stmt.assg</span><span class="alectryon-token"> ⟨</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>0</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">0</span></span><span class="alectryon-token">, </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk138" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk138"><span class="alectryon-token"><span class="kd">by</span></span><span class="alectryon-token"></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span></span></span></span><br><span><var>β, α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>β <span class="bp">→</span> α <span class="bp">→</span> m β</span></span></span><br><span><var>init</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>List α</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">0</span> <span class="bp">&lt;</span> List.length (β :: <span class="bp">∅</span>)</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk139" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk139"><span class="alectryon-token"><span class="k">simp</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">⟩ (</span><span class="alectryon-token"><span class="k">fun</span></span><span class="alectryon-token"> ([</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>z</var><b>: </b><span>β</span></span></div></blockquote></div></small></div><span class="nv">z</span></span><span class="alectryon-token">, </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk13a" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk13a"><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">x</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Warning: unused <span class="kd">variable</span> <span class="bp">`</span>x<span class="bp">`</span></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">]) _ <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>z</var><b>: </b><span>β</span></span></div></blockquote></div></small></div><span class="nv">z</span></span><span class="alectryon-token">))) <span class="bp">&lt;|</span>
      </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt.ret</var><b>: </b><span>{m : Type → Type} →
  {ω : Type} → {Γ Δ : List Type} → {b c : Bool} → {α : Type} → (Assg Γ → Assg Δ → ω) → Stmt m ω Γ Δ b c α</span></span></div></blockquote></div></small></div>Stmt.ret</span><span class="alectryon-token"> (</span><span class="alectryon-token"><span class="k">fun</span></span><span class="alectryon-token"> _ ([</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>y</var><b>: </b><span>β</span></span></div></blockquote></div></small></div><span class="nv">y</span></span><span class="alectryon-token">]) <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>y</var><b>: </b><span>β</span></span></div></blockquote></div></small></div><span class="nv">y</span></span><span class="alectryon-token">))</span></span></pre>
<p>Compare the output of the two versions - the structure is identical except for unused
monadic layers in the formal translation, which would be harder to avoid in this typed
approach.</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk13b" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk13b"><span class="alectryon-token"><span class="k">#print</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="kd">def</span> ex2.{u_1} : {m : <span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1} <span class="bp">→</span> {α : <span class="kt">Type</span>} <span class="bp">→</span> [inst : Monad m] <span class="bp">→</span> {β : <span class="kt">Type</span>} <span class="bp">→</span> (β <span class="bp">→</span> α <span class="bp">→</span> m β) <span class="bp">→</span> β <span class="bp">→</span> List α <span class="bp">→</span> m β :=
<span class="k">fun</span> {m} {α} [Monad m] {β} f init xs <span class="bp">=&gt;</span>
  ExceptCpsT.runCatch
    (<span class="k">let</span> y := init<span class="bp">;</span>
    StateT.run&#39;
      (<span class="k">do</span>
        forM xs <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
            <span class="k">let</span> y <span class="bp">←</span> get
            <span class="k">let</span> y <span class="bp">←</span> StateT.lift (ExceptCpsT.lift (f y x))
            <span class="k">let</span> _ <span class="bp">←</span> get
            set y
        <span class="k">let</span> y <span class="bp">←</span> get
        StateT.lift (throw y))
      y)</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ex2</var><b>: </b><span>{m : Type → Type u_1} → {α : Type} → [inst : Monad m] → {β : Type} → (β → α → m β) → β → List α → m β</span></span></div></blockquote></div></small></div>ex2</span><span class="alectryon-token">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk13c" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk13c"><span class="alectryon-token"><span class="k">#print</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="kd">def</span> ex2&#39; : {m : <span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span>} <span class="bp">→</span> {β α : <span class="kt">Type</span>} <span class="bp">→</span> [inst : Monad m] <span class="bp">→</span> (β <span class="bp">→</span> α <span class="bp">→</span> m β) <span class="bp">→</span> β <span class="bp">→</span> List α <span class="bp">→</span> m β :=
<span class="k">fun</span> {m} {β α} [Monad m] f init xs <span class="bp">=&gt;</span>
  runCatch
    (<span class="k">let</span> x := init<span class="bp">;</span>
    StateT.run&#39;
      (<span class="k">do</span>
        runCatch
            (forM xs <span class="k">fun</span> x <span class="bp">=&gt;</span>
              runCatch <span class="k">do</span>
                <span class="k">let</span> x_1 <span class="bp">←</span> ExceptT.lift (ExceptT.lift get)
                <span class="k">let</span> x <span class="bp">←</span> ExceptT.lift (ExceptT.lift (StateT.lift (ExceptT.lift (f x_1 x))))
                <span class="k">let</span> _ <span class="bp">←</span> ExceptT.lift (ExceptT.lift get)
                ExceptT.lift (ExceptT.lift (set x)))
        <span class="k">let</span> x <span class="bp">←</span> get
        StateT.lift (throw x))
      x)</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ex2'</var><b>: </b><span>{m : Type → Type} → {β α : Type} → [inst : Monad m] → (β → α → m β) → β → List α → m β</span></span></div></blockquote></div></small></div>ex2&#39;</span><span class="alectryon-token"></span></span></pre>
<p>We can evaluate the generated program like any other Lean program, and prove that both versions are equivalent.</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk13d" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk13d"><span class="alectryon-token"><span class="k">#eval</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="mi">3</span>
</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ex2'</var><b>: </b><span>{m : Type → Type} → {β α : Type} → [inst : Monad m] → (β → α → m β) → β → List α → m β</span></span></div></blockquote></div></small></div>ex2&#39;</span><span class="alectryon-token"> (m := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Id</var><b>: </b><span>Type → Type</span></span></div></blockquote></div></small></div>Id</span><span class="alectryon-token">) (</span><span class="alectryon-token"><span class="k">fun</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>pure</var><b>: </b><span>{f : Type → Type} → [self : Pure f] → {α : Type} → α → f α</span></span></div></blockquote></div></small></div>pure</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"> <span class="bp">+</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token">)) </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>0</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">0</span></span><span class="alectryon-token"> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>1</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">1</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>2</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">2</span></span><span class="alectryon-token">]

</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>example</var><b>: </b><span>∀ {m : Type → Type} {β α : Type} {init : β} {xs : List α} [inst : Monad m] [inst_1 : LawfulMonad m] (f : β → α → m β),
  ex2' f init xs = ex2 f init xs</span></span></div></blockquote></div></small></div><span class="kd">example</span></span><span class="alectryon-token"> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Monad</var><b>: </b><span>(Type → Type) → Type 1</span></span></div></blockquote></div></small></div>Monad</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>Type → Type</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token">] [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>LawfulMonad</var><b>: </b><span>(m : Type → Type) → [inst : Monad m] → Prop</span></span></div></blockquote></div></small></div>LawfulMonad</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>Type → Type</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token">] (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>β → α → m β</span></span></div></blockquote></div></small></div><span class="nv">f</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>β</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">β</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>Type → Type</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>β</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">β</span></span><span class="alectryon-token">) :
    </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ex2'</var><b>: </b><span>{m : Type → Type} → {β α : Type} → [inst : Monad m] → (β → α → m β) → β → List α → m β</span></span></div></blockquote></div></small></div>ex2&#39;</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>β → α → m β</span></span></div></blockquote></div></small></div><span class="nv">f</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>init</var><b>: </b><span>β</span></span></div></blockquote></div></small></div><span class="nv">init</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>xs</var><b>: </b><span>List α</span></span></div></blockquote></div></small></div><span class="nv">xs</span></span><span class="alectryon-token"> <span class="bp">=</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ex2</var><b>: </b><span>{m : Type → Type} → {α : Type} → [inst : Monad m] → {β : Type} → (β → α → m β) → β → List α → m β</span></span></div></blockquote></div></small></div>ex2</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>β → α → m β</span></span></div></blockquote></div></small></div><span class="nv">f</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>init</var><b>: </b><span>β</span></span></div></blockquote></div></small></div><span class="nv">init</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>xs</var><b>: </b><span>List α</span></span></div></blockquote></div></small></div><span class="nv">xs</span></span><span class="alectryon-token"> := </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk13e" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk13e"><span class="alectryon-token"><span class="kd">by</span></span><span class="alectryon-token"></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span></span></span></span><br><span><var>β, α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>init</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>List α</span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>β <span class="bp">→</span> α <span class="bp">→</span> m β</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ex2&#39; f init xs <span class="bp">=</span> ex2 f init xs</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk13f" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk13f"><span class="alectryon-token"><span class="k">rw</span></span><span class="alectryon-token"> [</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span></span></span></span><br><span><var>β, α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>init</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>List α</span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>β <span class="bp">→</span> α <span class="bp">→</span> m β</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ex2&#39; f init xs <span class="bp">=</span> ex2 f init xs</div></blockquote></div></div></small></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk140" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk140"><span class="alectryon-token">ex2,</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span></span></span></span><br><span><var>β, α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>init</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>List α</span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>β <span class="bp">→</span> α <span class="bp">→</span> m β</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ex2&#39; f init xs <span class="bp">=</span>
  ExceptCpsT.runCatch
    (<span class="k">let</span> y := init<span class="bp">;</span>
    StateT.run&#39;
      (<span class="k">do</span>
        forM xs <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
            <span class="k">let</span> y <span class="bp">←</span> get
            <span class="k">let</span> y <span class="bp">←</span> StateT.lift (ExceptCpsT.lift (f y x))
            <span class="k">let</span> _ <span class="bp">←</span> get
            set y
        <span class="k">let</span> y <span class="bp">←</span> get
        StateT.lift (throw y))
      y)</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk141" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk141"><span class="alectryon-token">ex2&#39;</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span></span></span></span><br><span><var>β, α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>init</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>List α</span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>β <span class="bp">→</span> α <span class="bp">→</span> m β</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">runCatch
    (<span class="k">let</span> x := init<span class="bp">;</span>
    StateT.run&#39;
      (<span class="k">do</span>
        runCatch
            (forM xs <span class="k">fun</span> x <span class="bp">=&gt;</span>
              runCatch <span class="k">do</span>
                <span class="k">let</span> x_1 <span class="bp">←</span> ExceptT.lift (ExceptT.lift get)
                <span class="k">let</span> x <span class="bp">←</span> ExceptT.lift (ExceptT.lift (StateT.lift (ExceptT.lift (f x_1 x))))
                <span class="k">let</span> _ <span class="bp">←</span> ExceptT.lift (ExceptT.lift get)
                ExceptT.lift (ExceptT.lift (set x)))
        <span class="k">let</span> x <span class="bp">←</span> get
        StateT.lift (throw x))
      x) <span class="bp">=</span>
  ExceptCpsT.runCatch
    (<span class="k">let</span> y := init<span class="bp">;</span>
    StateT.run&#39;
      (<span class="k">do</span>
        forM xs <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
            <span class="k">let</span> y <span class="bp">←</span> get
            <span class="k">let</span> y <span class="bp">←</span> StateT.lift (ExceptCpsT.lift (f y x))
            <span class="k">let</span> _ <span class="bp">←</span> get
            set y
        <span class="k">let</span> y <span class="bp">←</span> get
        StateT.lift (throw y))
      y)</div></blockquote></div></div></small></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk142" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk142"><span class="alectryon-token">]</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span></span></span></span><br><span><var>β, α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>init</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>List α</span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>β <span class="bp">→</span> α <span class="bp">→</span> m β</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">runCatch
    (<span class="k">let</span> x := init<span class="bp">;</span>
    StateT.run&#39;
      (<span class="k">do</span>
        runCatch
            (forM xs <span class="k">fun</span> x <span class="bp">=&gt;</span>
              runCatch <span class="k">do</span>
                <span class="k">let</span> x_1 <span class="bp">←</span> ExceptT.lift (ExceptT.lift get)
                <span class="k">let</span> x <span class="bp">←</span> ExceptT.lift (ExceptT.lift (StateT.lift (ExceptT.lift (f x_1 x))))
                <span class="k">let</span> _ <span class="bp">←</span> ExceptT.lift (ExceptT.lift get)
                ExceptT.lift (ExceptT.lift (set x)))
        <span class="k">let</span> x <span class="bp">←</span> get
        StateT.lift (throw x))
      x) <span class="bp">=</span>
  ExceptCpsT.runCatch
    (<span class="k">let</span> y := init<span class="bp">;</span>
    StateT.run&#39;
      (<span class="k">do</span>
        forM xs <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
            <span class="k">let</span> y <span class="bp">←</span> get
            <span class="k">let</span> y <span class="bp">←</span> StateT.lift (ExceptCpsT.lift (f y x))
            <span class="k">let</span> _ <span class="bp">←</span> get
            set y
        <span class="k">let</span> y <span class="bp">←</span> get
        StateT.lift (throw y))
      y)</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"><span class="bp">;</span></span><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk143" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk143"><span class="alectryon-token"><span class="k">unfold</span></span><span class="alectryon-token"> runCatch</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span></span></span></span><br><span><var>β, α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>init</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>List α</span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>β <span class="bp">→</span> α <span class="bp">→</span> m β</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="k">do</span>
    <span class="k">let</span> x <span class="bp">←</span>
      ExceptT.run
          (<span class="k">let</span> x := init<span class="bp">;</span>
          StateT.run&#39;
            (<span class="k">do</span>
              <span class="k">do</span>
                <span class="k">let</span> x <span class="bp">←</span>
                  ExceptT.run
                      (forM xs <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
                        <span class="k">let</span> x <span class="bp">←</span>
                          ExceptT.run <span class="k">do</span>
                              <span class="k">let</span> x_1 <span class="bp">←</span> ExceptT.lift (ExceptT.lift get)
                              <span class="k">let</span> x <span class="bp">←</span> ExceptT.lift (ExceptT.lift (StateT.lift (ExceptT.lift (f x_1 x))))
                              <span class="k">let</span> _ <span class="bp">←</span> ExceptT.lift (ExceptT.lift get)
                              ExceptT.lift (ExceptT.lift (set x))
                        <span class="k">match</span> x <span class="k">with</span>
                          <span class="bp">|</span> Except.ok x <span class="bp">=&gt;</span> pure x
                          <span class="bp">|</span> Except.error e <span class="bp">=&gt;</span> pure e)
                <span class="k">match</span> x <span class="k">with</span>
                  <span class="bp">|</span> Except.ok x <span class="bp">=&gt;</span> pure x
                  <span class="bp">|</span> Except.error e <span class="bp">=&gt;</span> pure e
              <span class="k">let</span> x <span class="bp">←</span> get
              StateT.lift (throw x))
            x)
    <span class="k">match</span> x <span class="k">with</span>
      <span class="bp">|</span> Except.ok x <span class="bp">=&gt;</span> pure x
      <span class="bp">|</span> Except.error e <span class="bp">=&gt;</span> pure e) <span class="bp">=</span>
  ExceptCpsT.runCatch
    (<span class="k">let</span> y := init<span class="bp">;</span>
    StateT.run&#39;
      (<span class="k">do</span>
        forM xs <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
            <span class="k">let</span> y <span class="bp">←</span> get
            <span class="k">let</span> y <span class="bp">←</span> StateT.lift (ExceptCpsT.lift (f y x))
            <span class="k">let</span> _ <span class="bp">←</span> get
            set y
        <span class="k">let</span> y <span class="bp">←</span> get
        StateT.lift (throw y))
      y)</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"><span class="bp">;</span></span><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk144" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk144"><span class="alectryon-token"><span class="k">induction</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>xs</var><b>: </b><span>List α</span></span></div></blockquote></div></small></div><span class="nv">xs</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">generalizing</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>init</var><b>: </b><span>β</span></span></div></blockquote></div></small></div><span class="nv">init</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span></span></span></span><br><span><var>β, α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>β <span class="bp">→</span> α <span class="bp">→</span> m β</span></span></span><br><span><var>init</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">nil</span></span><div class="goal-conclusion">(<span class="k">do</span>
    <span class="k">let</span> x <span class="bp">←</span>
      ExceptT.run
          (<span class="k">let</span> x := init<span class="bp">;</span>
          StateT.run&#39;
            (<span class="k">do</span>
              <span class="k">do</span>
                <span class="k">let</span> x <span class="bp">←</span>
                  ExceptT.run
                      (forM [] <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
                        <span class="k">let</span> x <span class="bp">←</span>
                          ExceptT.run <span class="k">do</span>
                              <span class="k">let</span> x_1 <span class="bp">←</span> ExceptT.lift (ExceptT.lift get)
                              <span class="k">let</span> x <span class="bp">←</span> ExceptT.lift (ExceptT.lift (StateT.lift (ExceptT.lift (f x_1 x))))
                              <span class="k">let</span> _ <span class="bp">←</span> ExceptT.lift (ExceptT.lift get)
                              ExceptT.lift (ExceptT.lift (set x))
                        <span class="k">match</span> x <span class="k">with</span>
                          <span class="bp">|</span> Except.ok x <span class="bp">=&gt;</span> pure x
                          <span class="bp">|</span> Except.error e <span class="bp">=&gt;</span> pure e)
                <span class="k">match</span> x <span class="k">with</span>
                  <span class="bp">|</span> Except.ok x <span class="bp">=&gt;</span> pure x
                  <span class="bp">|</span> Except.error e <span class="bp">=&gt;</span> pure e
              <span class="k">let</span> x <span class="bp">←</span> get
              StateT.lift (throw x))
            x)
    <span class="k">match</span> x <span class="k">with</span>
      <span class="bp">|</span> Except.ok x <span class="bp">=&gt;</span> pure x
      <span class="bp">|</span> Except.error e <span class="bp">=&gt;</span> pure e) <span class="bp">=</span>
  ExceptCpsT.runCatch
    (<span class="k">let</span> y := init<span class="bp">;</span>
    StateT.run&#39;
      (<span class="k">do</span>
        forM [] <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
            <span class="k">let</span> y <span class="bp">←</span> get
            <span class="k">let</span> y <span class="bp">←</span> StateT.lift (ExceptCpsT.lift (f y x))
            <span class="k">let</span> _ <span class="bp">←</span> get
            set y
        <span class="k">let</span> y <span class="bp">←</span> get
        StateT.lift (throw y))
      y)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Formal-lean-chk145" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span></span></span></span><br><span><var>β, α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>β <span class="bp">→</span> α <span class="bp">→</span> m β</span></span></span><br><span><var>head✝</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br><span><var>tail✝</var><span class="hyp-type"><b>: </b><span>List α</span></span></span><br><span><var>init</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br></div><label class="goal-separator" for="Formal-lean-chk145"><hr><span class="goal-name">cons</span></label><div class="goal-conclusion">(<span class="k">do</span>
    <span class="k">let</span> x <span class="bp">←</span>
      ExceptT.run
          (<span class="k">let</span> x := init<span class="bp">;</span>
          StateT.run&#39;
            (<span class="k">do</span>
              <span class="k">do</span>
                <span class="k">let</span> x <span class="bp">←</span>
                  ExceptT.run
                      (forM (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
                        <span class="k">let</span> x <span class="bp">←</span>
                          ExceptT.run <span class="k">do</span>
                              <span class="k">let</span> x_1 <span class="bp">←</span> ExceptT.lift (ExceptT.lift get)
                              <span class="k">let</span> x <span class="bp">←</span> ExceptT.lift (ExceptT.lift (StateT.lift (ExceptT.lift (f x_1 x))))
                              <span class="k">let</span> _ <span class="bp">←</span> ExceptT.lift (ExceptT.lift get)
                              ExceptT.lift (ExceptT.lift (set x))
                        <span class="k">match</span> x <span class="k">with</span>
                          <span class="bp">|</span> Except.ok x <span class="bp">=&gt;</span> pure x
                          <span class="bp">|</span> Except.error e <span class="bp">=&gt;</span> pure e)
                <span class="k">match</span> x <span class="k">with</span>
                  <span class="bp">|</span> Except.ok x <span class="bp">=&gt;</span> pure x
                  <span class="bp">|</span> Except.error e <span class="bp">=&gt;</span> pure e
              <span class="k">let</span> x <span class="bp">←</span> get
              StateT.lift (throw x))
            x)
    <span class="k">match</span> x <span class="k">with</span>
      <span class="bp">|</span> Except.ok x <span class="bp">=&gt;</span> pure x
      <span class="bp">|</span> Except.error e <span class="bp">=&gt;</span> pure e) <span class="bp">=</span>
  ExceptCpsT.runCatch
    (<span class="k">let</span> y := init<span class="bp">;</span>
    StateT.run&#39;
      (<span class="k">do</span>
        forM (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
            <span class="k">let</span> y <span class="bp">←</span> get
            <span class="k">let</span> y <span class="bp">←</span> StateT.lift (ExceptCpsT.lift (f y x))
            <span class="k">let</span> _ <span class="bp">←</span> get
            set y
        <span class="k">let</span> y <span class="bp">←</span> get
        StateT.lift (throw y))
      y)</div></blockquote></div></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk146" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk146"><span class="alectryon-token"><span class="k">&lt;;&gt;</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span></span></span></span><br><span><var>β, α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>β <span class="bp">→</span> α <span class="bp">→</span> m β</span></span></span><br><span><var>init</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">nil</span></span><div class="goal-conclusion">(<span class="k">do</span>
    <span class="k">let</span> x <span class="bp">←</span>
      ExceptT.run
          (<span class="k">let</span> x := init<span class="bp">;</span>
          StateT.run&#39;
            (<span class="k">do</span>
              <span class="k">do</span>
                <span class="k">let</span> x <span class="bp">←</span>
                  ExceptT.run
                      (forM [] <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
                        <span class="k">let</span> x <span class="bp">←</span>
                          ExceptT.run <span class="k">do</span>
                              <span class="k">let</span> x_1 <span class="bp">←</span> ExceptT.lift (ExceptT.lift get)
                              <span class="k">let</span> x <span class="bp">←</span> ExceptT.lift (ExceptT.lift (StateT.lift (ExceptT.lift (f x_1 x))))
                              <span class="k">let</span> _ <span class="bp">←</span> ExceptT.lift (ExceptT.lift get)
                              ExceptT.lift (ExceptT.lift (set x))
                        <span class="k">match</span> x <span class="k">with</span>
                          <span class="bp">|</span> Except.ok x <span class="bp">=&gt;</span> pure x
                          <span class="bp">|</span> Except.error e <span class="bp">=&gt;</span> pure e)
                <span class="k">match</span> x <span class="k">with</span>
                  <span class="bp">|</span> Except.ok x <span class="bp">=&gt;</span> pure x
                  <span class="bp">|</span> Except.error e <span class="bp">=&gt;</span> pure e
              <span class="k">let</span> x <span class="bp">←</span> get
              StateT.lift (throw x))
            x)
    <span class="k">match</span> x <span class="k">with</span>
      <span class="bp">|</span> Except.ok x <span class="bp">=&gt;</span> pure x
      <span class="bp">|</span> Except.error e <span class="bp">=&gt;</span> pure e) <span class="bp">=</span>
  ExceptCpsT.runCatch
    (<span class="k">let</span> y := init<span class="bp">;</span>
    StateT.run&#39;
      (<span class="k">do</span>
        forM [] <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
            <span class="k">let</span> y <span class="bp">←</span> get
            <span class="k">let</span> y <span class="bp">←</span> StateT.lift (ExceptCpsT.lift (f y x))
            <span class="k">let</span> _ <span class="bp">←</span> get
            set y
        <span class="k">let</span> y <span class="bp">←</span> get
        StateT.lift (throw y))
      y)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Formal-lean-chk147" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span></span></span></span><br><span><var>β, α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>β <span class="bp">→</span> α <span class="bp">→</span> m β</span></span></span><br><span><var>head✝</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br><span><var>tail✝</var><span class="hyp-type"><b>: </b><span>List α</span></span></span><br><span><var>init</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br></div><label class="goal-separator" for="Formal-lean-chk147"><hr><span class="goal-name">cons</span></label><div class="goal-conclusion">(<span class="k">do</span>
    <span class="k">let</span> x <span class="bp">←</span>
      ExceptT.run
          (<span class="k">let</span> x := init<span class="bp">;</span>
          StateT.run&#39;
            (<span class="k">do</span>
              <span class="k">do</span>
                <span class="k">let</span> x <span class="bp">←</span>
                  ExceptT.run
                      (forM (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
                        <span class="k">let</span> x <span class="bp">←</span>
                          ExceptT.run <span class="k">do</span>
                              <span class="k">let</span> x_1 <span class="bp">←</span> ExceptT.lift (ExceptT.lift get)
                              <span class="k">let</span> x <span class="bp">←</span> ExceptT.lift (ExceptT.lift (StateT.lift (ExceptT.lift (f x_1 x))))
                              <span class="k">let</span> _ <span class="bp">←</span> ExceptT.lift (ExceptT.lift get)
                              ExceptT.lift (ExceptT.lift (set x))
                        <span class="k">match</span> x <span class="k">with</span>
                          <span class="bp">|</span> Except.ok x <span class="bp">=&gt;</span> pure x
                          <span class="bp">|</span> Except.error e <span class="bp">=&gt;</span> pure e)
                <span class="k">match</span> x <span class="k">with</span>
                  <span class="bp">|</span> Except.ok x <span class="bp">=&gt;</span> pure x
                  <span class="bp">|</span> Except.error e <span class="bp">=&gt;</span> pure e
              <span class="k">let</span> x <span class="bp">←</span> get
              StateT.lift (throw x))
            x)
    <span class="k">match</span> x <span class="k">with</span>
      <span class="bp">|</span> Except.ok x <span class="bp">=&gt;</span> pure x
      <span class="bp">|</span> Except.error e <span class="bp">=&gt;</span> pure e) <span class="bp">=</span>
  ExceptCpsT.runCatch
    (<span class="k">let</span> y := init<span class="bp">;</span>
    StateT.run&#39;
      (<span class="k">do</span>
        forM (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
            <span class="k">let</span> y <span class="bp">←</span> get
            <span class="k">let</span> y <span class="bp">←</span> StateT.lift (ExceptCpsT.lift (f y x))
            <span class="k">let</span> _ <span class="bp">←</span> get
            set y
        <span class="k">let</span> y <span class="bp">←</span> get
        StateT.lift (throw y))
      y)</div></blockquote></div></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk148" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk148"><span class="alectryon-token">simp_all<span class="bp">!</span></span><span class="alectryon-token"> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>StateT.run'_eq</var><b>: </b><span>∀ {m : Type ?u.1097137 → Type ?u.1097136} {σ α : Type ?u.1097137} [inst : Monad m] (x : StateT σ m α) (s : σ),
  StateT.run' x s = (fun a =&gt; a.fst) &lt;$&gt; StateT.run x s</span></span></div></blockquote></div></small></div><span class="k">StateT.run&#39;_eq</span></span><span class="alectryon-token">]</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span></pre>
<p>For one more example, consider <code>ex3</code> from <code>For.lean</code>.</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="c">/-</span><span class="cm"></span>
<span class="cm">for xs in xss do&#39; {</span>
<span class="cm">  for x in xs do&#39; {</span>
<span class="cm">    let b ← p x;</span>
<span class="cm">    if b then {</span>
<span class="cm">      return some x</span>
<span class="cm">    }</span>
<span class="cm">  }</span>
<span class="cm">};</span>
<span class="cm">pure none</span>
<span class="cm">-/</span>

</span><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ex3'</var><b>: </b><span>{m : Type → Type} → {α : Type} → [inst : Monad m] → (α → m Bool) → List (List α) → m (Option α)</span></span></div></blockquote></div></small></div><span class="nv">ex3&#39;</span></span><span class="alectryon-token"> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Monad</var><b>: </b><span>(Type → Type) → Type 1</span></span></div></blockquote></div></small></div>Monad</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>Type → Type</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token">] (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>p</var><b>: </b><span>α → m Bool</span></span></div></blockquote></div></small></div><span class="nv">p</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>Type → Type</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Bool</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Bool</span><span class="alectryon-token">) (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>xss</var><b>: </b><span>List (List α)</span></span></div></blockquote></div></small></div><span class="nv">xss</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>List</var><b>: </b><span>Type → Type</span></span></div></blockquote></div></small></div>List</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>List</var><b>: </b><span>Type → Type</span></span></div></blockquote></div></small></div>List</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token">)) : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>Type → Type</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Option</var><b>: </b><span>Type → Type</span></span></div></blockquote></div></small></div>Option</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token">) :=
  </span><span class="alectryon-token"><span class="k">simp</span></span><span class="alectryon-token"> [Do.trans] </span><span class="alectryon-token"><span class="k">in</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Do.trans</var><b>: </b><span>{m : Type → Type} → {α : Type} → [inst : Monad m] → Do m α → m α</span></span></div></blockquote></div></small></div>Do.trans</span><span class="alectryon-token"> (
      </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt.bind</var><b>: </b><span>{m : Type → Type} →
  {ω : Type} →
    {Γ Δ : List Type} →
      {b c : Bool} → {α β : Type} → Stmt m ω Γ Δ b c α → Stmt m ω (α :: Γ) Δ b c β → Stmt m ω Γ Δ b c β</span></span></div></blockquote></div></small></div>Stmt.bind</span><span class="alectryon-token">
        (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt.sfor</var><b>: </b><span>{m : Type → Type} →
  {ω : Type} →
    {Γ Δ : List Type} →
      {α : Type} →
        {b c : Bool} → (Assg Γ → Assg Δ → List α) → Stmt m ω (α :: Γ) Δ true true Unit → Stmt m ω Γ Δ b c Unit</span></span></div></blockquote></div></small></div>Stmt.sfor</span><span class="alectryon-token"> (</span><span class="alectryon-token"><span class="k">fun</span></span><span class="alectryon-token"> _ _ <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>xss</var><b>: </b><span>List (List α)</span></span></div></blockquote></div></small></div><span class="nv">xss</span></span><span class="alectryon-token">) <span class="bp">&lt;|</span>
          </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt.sfor</var><b>: </b><span>{m : Type → Type} →
  {ω : Type} →
    {Γ Δ : List Type} →
      {α : Type} →
        {b c : Bool} → (Assg Γ → Assg Δ → List α) → Stmt m ω (α :: Γ) Δ true true Unit → Stmt m ω Γ Δ b c Unit</span></span></div></blockquote></div></small></div>Stmt.sfor</span><span class="alectryon-token"> (</span><span class="alectryon-token"><span class="k">fun</span></span><span class="alectryon-token"> ([</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>xs</var><b>: </b><span>List α</span></span></div></blockquote></div></small></div><span class="nv">xs</span></span><span class="alectryon-token">]) _ <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>xs</var><b>: </b><span>List α</span></span></div></blockquote></div></small></div><span class="nv">xs</span></span><span class="alectryon-token">) <span class="bp">&lt;|</span>
            </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt.bind</var><b>: </b><span>{m : Type → Type} →
  {ω : Type} →
    {Γ Δ : List Type} →
      {b c : Bool} → {α β : Type} → Stmt m ω Γ Δ b c α → Stmt m ω (α :: Γ) Δ b c β → Stmt m ω Γ Δ b c β</span></span></div></blockquote></div></small></div>Stmt.bind</span><span class="alectryon-token">
              (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt.expr</var><b>: </b><span>{m : Type → Type} →
  {ω : Type} → {Γ Δ : List Type} → {α : Type} → {b c : Bool} → (Assg Γ → Assg Δ → m α) → Stmt m ω Γ Δ b c α</span></span></div></blockquote></div></small></div>Stmt.expr</span><span class="alectryon-token"> (</span><span class="alectryon-token"><span class="k">fun</span></span><span class="alectryon-token"> ([</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token">, </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk149" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk149"><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>xs</var><b>: </b><span>List α</span></span></div></blockquote></div></small></div><span class="nv">xs</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Warning: unused <span class="kd">variable</span> <span class="bp">`</span>xs<span class="bp">`</span></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">]) _ <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>p</var><b>: </b><span>α → m Bool</span></span></div></blockquote></div></small></div><span class="nv">p</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token">))
              (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt.ite</var><b>: </b><span>{m : Type → Type} →
  {ω : Type} →
    {Γ Δ : List Type} →
      {b c : Bool} →
        {α : Type} → (Assg Γ → Assg Δ → Bool) → Stmt m ω Γ Δ b c α → Stmt m ω Γ Δ b c α → Stmt m ω Γ Δ b c α</span></span></div></blockquote></div></small></div>Stmt.ite</span><span class="alectryon-token"> (</span><span class="alectryon-token"><span class="k">fun</span></span><span class="alectryon-token"> ([</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token">, </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk14a" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk14a"><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">x</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Warning: unused <span class="kd">variable</span> <span class="bp">`</span>x<span class="bp">`</span></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">, </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk14b" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk14b"><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>xs</var><b>: </b><span>List α</span></span></div></blockquote></div></small></div><span class="nv">xs</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Warning: unused <span class="kd">variable</span> <span class="bp">`</span>xs<span class="bp">`</span></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">]) _ <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token">)
                (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt.ret</var><b>: </b><span>{m : Type → Type} →
  {ω : Type} → {Γ Δ : List Type} → {b c : Bool} → {α : Type} → (Assg Γ → Assg Δ → ω) → Stmt m ω Γ Δ b c α</span></span></div></blockquote></div></small></div>Stmt.ret</span><span class="alectryon-token"> (</span><span class="alectryon-token"><span class="k">fun</span></span><span class="alectryon-token"> ([</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk14c" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk14c"><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div><span class="nv">b</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Warning: unused <span class="kd">variable</span> <span class="bp">`</span>b<span class="bp">`</span></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token">, </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk14d" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk14d"><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>xs</var><b>: </b><span>List α</span></span></div></blockquote></div></small></div><span class="nv">xs</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Warning: unused <span class="kd">variable</span> <span class="bp">`</span>xs<span class="bp">`</span></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">]) _ <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>some</var><b>: </b><span>{α : Type} → α → Option α</span></span></div></blockquote></div></small></div>some</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token">))
                (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt.expr</var><b>: </b><span>{m : Type → Type} →
  {ω : Type} → {Γ Δ : List Type} → {α : Type} → {b c : Bool} → (Assg Γ → Assg Δ → m α) → Stmt m ω Γ Δ b c α</span></span></div></blockquote></div></small></div>Stmt.expr</span><span class="alectryon-token"> (</span><span class="alectryon-token"><span class="k">fun</span></span><span class="alectryon-token"> _ _ <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>pure</var><b>: </b><span>{f : Type → Type} → [self : Pure f] → {α : Type} → α → f α</span></span></div></blockquote></div></small></div>pure</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>()</var><b>: </b><span>Unit</span></span></div></blockquote></div></small></div>()</span><span class="alectryon-token">))))
        (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Stmt.expr</var><b>: </b><span>{m : Type → Type} →
  {ω : Type} → {Γ Δ : List Type} → {α : Type} → {b c : Bool} → (Assg Γ → Assg Δ → m α) → Stmt m ω Γ Δ b c α</span></span></div></blockquote></div></small></div>Stmt.expr</span><span class="alectryon-token"> (</span><span class="alectryon-token"><span class="k">fun</span></span><span class="alectryon-token"> _ _ <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>pure</var><b>: </b><span>{f : Type → Type} → [self : Pure f] → {α : Type} → α → f α</span></span></div></blockquote></div></small></div>pure</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>none</var><b>: </b><span>{α : Type} → Option α</span></span></div></blockquote></div></small></div>none</span><span class="alectryon-token">)))

</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk14e" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk14e"><span class="alectryon-token"><span class="k">#print</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="kd">def</span> ex3.{u_1} : {m : <span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> u_1} <span class="bp">→</span> {α : <span class="kt">Type</span>} <span class="bp">→</span> [inst : Monad m] <span class="bp">→</span> (α <span class="bp">→</span> m Bool) <span class="bp">→</span> List (List α) <span class="bp">→</span> m (Option α) :=
<span class="k">fun</span> {m} {α} [Monad m] p xss <span class="bp">=&gt;</span>
  ExceptCpsT.runCatch <span class="k">do</span>
    forM xss <span class="k">fun</span> xs <span class="bp">=&gt;</span>
        forM xs <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
          <span class="k">let</span> b <span class="bp">←</span> ExceptCpsT.lift (p x)
          <span class="k">if</span> b <span class="bp">=</span> true <span class="k">then</span> throw (some x) <span class="k">else</span> ExceptCpsT.lift (pure ())
    ExceptCpsT.lift (pure none)</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ex3</var><b>: </b><span>{m : Type → Type u_1} → {α : Type} → [inst : Monad m] → (α → m Bool) → List (List α) → m (Option α)</span></span></div></blockquote></div></small></div>ex3</span><span class="alectryon-token">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk14f" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk14f"><span class="alectryon-token"><span class="k">#print</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="kd">def</span> ex3&#39; : {m : <span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span>} <span class="bp">→</span> {α : <span class="kt">Type</span>} <span class="bp">→</span> [inst : Monad m] <span class="bp">→</span> (α <span class="bp">→</span> m Bool) <span class="bp">→</span> List (List α) <span class="bp">→</span> m (Option α) :=
<span class="k">fun</span> {m} {α} [Monad m] p xss <span class="bp">=&gt;</span>
  runCatch <span class="k">do</span>
    runCatch
        (forM xss <span class="k">fun</span> x <span class="bp">=&gt;</span>
          runCatch
            (runCatch
              (forM x <span class="k">fun</span> x <span class="bp">=&gt;</span>
                runCatch <span class="k">do</span>
                  <span class="k">let</span> x_1 <span class="bp">←</span> ExceptT.lift (ExceptT.lift (ExceptT.lift (ExceptT.lift (ExceptT.lift (p x)))))
                  <span class="k">if</span> x_1 <span class="bp">=</span> true <span class="k">then</span> ExceptT.lift (ExceptT.lift (ExceptT.lift (ExceptT.lift (throw (some x)))))
                    <span class="k">else</span> ExceptT.lift (ExceptT.lift (ExceptT.lift (ExceptT.lift (ExceptT.lift (pure ()))))))))
    ExceptT.lift (pure none)</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ex3'</var><b>: </b><span>{m : Type → Type} → {α : Type} → [inst : Monad m] → (α → m Bool) → List (List α) → m (Option α)</span></span></div></blockquote></div></small></div>ex3&#39;</span><span class="alectryon-token">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk150" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk150"><span class="alectryon-token"><span class="k">#eval</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">some <span class="mi">2</span>
</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ex3'</var><b>: </b><span>{m : Type → Type} → {α : Type} → [inst : Monad m] → (α → m Bool) → List (List α) → m (Option α)</span></span></div></blockquote></div></small></div>ex3&#39;</span><span class="alectryon-token"> (m := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Id</var><b>: </b><span>Type → Type</span></span></div></blockquote></div></small></div>Id</span><span class="alectryon-token">) (</span><span class="alectryon-token"><span class="k">fun</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>n</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">n</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>n</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">n</span></span><span class="alectryon-token"> <span class="bp">%</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>2</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">2</span></span><span class="alectryon-token"> <span class="bp">==</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>0</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">0</span></span><span class="alectryon-token">) [[</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>1</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">1</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>3</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">3</span></span><span class="alectryon-token">], [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>2</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">2</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>4</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">4</span></span><span class="alectryon-token">]]

</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>example</var><b>: </b><span>∀ {m : Type → Type} {α : Type} [inst : Monad m] [inst_1 : LawfulMonad m] (p : α → m Bool) (xss : List (List α)),
  ex3' p xss = ex3 p xss</span></span></div></blockquote></div></small></div><span class="kd">example</span></span><span class="alectryon-token"> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Monad</var><b>: </b><span>(Type → Type) → Type 1</span></span></div></blockquote></div></small></div>Monad</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>Type → Type</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token">] [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>LawfulMonad</var><b>: </b><span>(m : Type ?u.1130706 → Type ?u.1130705) → [inst : Monad m] → Prop</span></span></div></blockquote></div></small></div>LawfulMonad</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>Type → Type</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token">] (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>p</var><b>: </b><span>α → m Bool</span></span></div></blockquote></div></small></div><span class="nv">p</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>Type → Type</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Bool</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Bool</span><span class="alectryon-token">) (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>xss</var><b>: </b><span>List (List α)</span></span></div></blockquote></div></small></div><span class="nv">xss</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>List</var><b>: </b><span>Type → Type</span></span></div></blockquote></div></small></div>List</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>List</var><b>: </b><span>Type → Type</span></span></div></blockquote></div></small></div>List</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token">)) :
    </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ex3'</var><b>: </b><span>{m : Type → Type} → {α : Type} → [inst : Monad m] → (α → m Bool) → List (List α) → m (Option α)</span></span></div></blockquote></div></small></div>ex3&#39;</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>p</var><b>: </b><span>α → m Bool</span></span></div></blockquote></div></small></div><span class="nv">p</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>xss</var><b>: </b><span>List (List α)</span></span></div></blockquote></div></small></div><span class="nv">xss</span></span><span class="alectryon-token"> <span class="bp">=</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ex3</var><b>: </b><span>{m : Type → Type} → {α : Type} → [inst : Monad m] → (α → m Bool) → List (List α) → m (Option α)</span></span></div></blockquote></div></small></div>ex3</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>p</var><b>: </b><span>α → m Bool</span></span></div></blockquote></div></small></div><span class="nv">p</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>xss</var><b>: </b><span>List (List α)</span></span></div></blockquote></div></small></div><span class="nv">xss</span></span><span class="alectryon-token"> := </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk151" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk151"><span class="alectryon-token"><span class="kd">by</span></span><span class="alectryon-token"></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span></span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> m Bool</span></span></span><br><span><var>xss</var><span class="hyp-type"><b>: </b><span>List (List α)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ex3&#39; p xss <span class="bp">=</span> ex3 p xss</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk152" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk152"><span class="alectryon-token"><span class="k">rw</span></span><span class="alectryon-token"> [</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span></span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> m Bool</span></span></span><br><span><var>xss</var><span class="hyp-type"><b>: </b><span>List (List α)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ex3&#39; p xss <span class="bp">=</span> ex3 p xss</div></blockquote></div></div></small></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk153" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk153"><span class="alectryon-token">ex3,</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span></span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> m Bool</span></span></span><br><span><var>xss</var><span class="hyp-type"><b>: </b><span>List (List α)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ex3&#39; p xss <span class="bp">=</span>
  ExceptCpsT.runCatch <span class="k">do</span>
    forM xss <span class="k">fun</span> xs <span class="bp">=&gt;</span>
        forM xs <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
          <span class="k">let</span> b <span class="bp">←</span> ExceptCpsT.lift (p x)
          <span class="k">if</span> b <span class="bp">=</span> true <span class="k">then</span> throw (some x) <span class="k">else</span> ExceptCpsT.lift (pure ())
    ExceptCpsT.lift (pure none)</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk154" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk154"><span class="alectryon-token">ex3&#39;</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span></span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> m Bool</span></span></span><br><span><var>xss</var><span class="hyp-type"><b>: </b><span>List (List α)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(runCatch <span class="k">do</span>
    runCatch
        (forM xss <span class="k">fun</span> x <span class="bp">=&gt;</span>
          runCatch
            (runCatch
              (forM x <span class="k">fun</span> x <span class="bp">=&gt;</span>
                runCatch <span class="k">do</span>
                  <span class="k">let</span> x_1 <span class="bp">←</span> ExceptT.lift (ExceptT.lift (ExceptT.lift (ExceptT.lift (ExceptT.lift (p x)))))
                  <span class="k">if</span> x_1 <span class="bp">=</span> true <span class="k">then</span> ExceptT.lift (ExceptT.lift (ExceptT.lift (ExceptT.lift (throw (some x)))))
                    <span class="k">else</span> ExceptT.lift (ExceptT.lift (ExceptT.lift (ExceptT.lift (ExceptT.lift (pure ()))))))))
    ExceptT.lift (pure none)) <span class="bp">=</span>
  ExceptCpsT.runCatch <span class="k">do</span>
    forM xss <span class="k">fun</span> xs <span class="bp">=&gt;</span>
        forM xs <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
          <span class="k">let</span> b <span class="bp">←</span> ExceptCpsT.lift (p x)
          <span class="k">if</span> b <span class="bp">=</span> true <span class="k">then</span> throw (some x) <span class="k">else</span> ExceptCpsT.lift (pure ())
    ExceptCpsT.lift (pure none)</div></blockquote></div></div></small></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk155" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk155"><span class="alectryon-token">]</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span></span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> m Bool</span></span></span><br><span><var>xss</var><span class="hyp-type"><b>: </b><span>List (List α)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(runCatch <span class="k">do</span>
    runCatch
        (forM xss <span class="k">fun</span> x <span class="bp">=&gt;</span>
          runCatch
            (runCatch
              (forM x <span class="k">fun</span> x <span class="bp">=&gt;</span>
                runCatch <span class="k">do</span>
                  <span class="k">let</span> x_1 <span class="bp">←</span> ExceptT.lift (ExceptT.lift (ExceptT.lift (ExceptT.lift (ExceptT.lift (p x)))))
                  <span class="k">if</span> x_1 <span class="bp">=</span> true <span class="k">then</span> ExceptT.lift (ExceptT.lift (ExceptT.lift (ExceptT.lift (throw (some x)))))
                    <span class="k">else</span> ExceptT.lift (ExceptT.lift (ExceptT.lift (ExceptT.lift (ExceptT.lift (pure ()))))))))
    ExceptT.lift (pure none)) <span class="bp">=</span>
  ExceptCpsT.runCatch <span class="k">do</span>
    forM xss <span class="k">fun</span> xs <span class="bp">=&gt;</span>
        forM xs <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
          <span class="k">let</span> b <span class="bp">←</span> ExceptCpsT.lift (p x)
          <span class="k">if</span> b <span class="bp">=</span> true <span class="k">then</span> throw (some x) <span class="k">else</span> ExceptCpsT.lift (pure ())
    ExceptCpsT.lift (pure none)</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk156" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk156"><span class="alectryon-token"><span class="k">unfold</span></span><span class="alectryon-token"> runCatch</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span></span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> m Bool</span></span></span><br><span><var>xss</var><span class="hyp-type"><b>: </b><span>List (List α)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="k">do</span>
    <span class="k">let</span> x <span class="bp">←</span>
      ExceptT.run <span class="k">do</span>
          <span class="k">do</span>
            <span class="k">let</span> x <span class="bp">←</span>
              ExceptT.run
                  (forM xss <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
                    <span class="k">let</span> x <span class="bp">←</span>
                      ExceptT.run <span class="k">do</span>
                          <span class="k">let</span> x <span class="bp">←</span>
                            ExceptT.run
                                (forM x <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
                                  <span class="k">let</span> x <span class="bp">←</span>
                                    ExceptT.run <span class="k">do</span>
                                        <span class="k">let</span> x_1 <span class="bp">←</span>
                                          ExceptT.lift (ExceptT.lift (ExceptT.lift (ExceptT.lift (ExceptT.lift (p x)))))
                                        <span class="k">if</span> x_1 <span class="bp">=</span> true <span class="k">then</span>
                                            ExceptT.lift (ExceptT.lift (ExceptT.lift (ExceptT.lift (throw (some x)))))
                                          <span class="k">else</span>
                                            ExceptT.lift
                                              (ExceptT.lift (ExceptT.lift (ExceptT.lift (ExceptT.lift (pure ())))))
                                  <span class="k">match</span> x <span class="k">with</span>
                                    <span class="bp">|</span> Except.ok x <span class="bp">=&gt;</span> pure x
                                    <span class="bp">|</span> Except.error e <span class="bp">=&gt;</span> pure e)
                          <span class="k">match</span> x <span class="k">with</span>
                            <span class="bp">|</span> Except.ok x <span class="bp">=&gt;</span> pure x
                            <span class="bp">|</span> Except.error e <span class="bp">=&gt;</span> pure e
                    <span class="k">match</span> x <span class="k">with</span>
                      <span class="bp">|</span> Except.ok x <span class="bp">=&gt;</span> pure x
                      <span class="bp">|</span> Except.error e <span class="bp">=&gt;</span> pure e)
            <span class="k">match</span> x <span class="k">with</span>
              <span class="bp">|</span> Except.ok x <span class="bp">=&gt;</span> pure x
              <span class="bp">|</span> Except.error e <span class="bp">=&gt;</span> pure e
          ExceptT.lift (pure none)
    <span class="k">match</span> x <span class="k">with</span>
      <span class="bp">|</span> Except.ok x <span class="bp">=&gt;</span> pure x
      <span class="bp">|</span> Except.error e <span class="bp">=&gt;</span> pure e) <span class="bp">=</span>
  ExceptCpsT.runCatch <span class="k">do</span>
    forM xss <span class="k">fun</span> xs <span class="bp">=&gt;</span>
        forM xs <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
          <span class="k">let</span> b <span class="bp">←</span> ExceptCpsT.lift (p x)
          <span class="k">if</span> b <span class="bp">=</span> true <span class="k">then</span> throw (some x) <span class="k">else</span> ExceptCpsT.lift (pure ())
    ExceptCpsT.lift (pure none)</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk157" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk157"><span class="alectryon-token"><span class="k">induction</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>xss</var><b>: </b><span>List (List α)</span></span></div></blockquote></div></small></div><span class="nv">xss</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">with</span></span><span class="alectryon-token"></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span></span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> m Bool</span></span></span><br><span><var>xss</var><span class="hyp-type"><b>: </b><span>List (List α)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="k">do</span>
    <span class="k">let</span> x <span class="bp">←</span>
      ExceptT.run <span class="k">do</span>
          <span class="k">do</span>
            <span class="k">let</span> x <span class="bp">←</span>
              ExceptT.run
                  (forM xss <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
                    <span class="k">let</span> x <span class="bp">←</span>
                      ExceptT.run <span class="k">do</span>
                          <span class="k">let</span> x <span class="bp">←</span>
                            ExceptT.run
                                (forM x <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
                                  <span class="k">let</span> x <span class="bp">←</span>
                                    ExceptT.run <span class="k">do</span>
                                        <span class="k">let</span> x_1 <span class="bp">←</span>
                                          ExceptT.lift (ExceptT.lift (ExceptT.lift (ExceptT.lift (ExceptT.lift (p x)))))
                                        <span class="k">if</span> x_1 <span class="bp">=</span> true <span class="k">then</span>
                                            ExceptT.lift (ExceptT.lift (ExceptT.lift (ExceptT.lift (throw (some x)))))
                                          <span class="k">else</span>
                                            ExceptT.lift
                                              (ExceptT.lift (ExceptT.lift (ExceptT.lift (ExceptT.lift (pure ())))))
                                  <span class="k">match</span> x <span class="k">with</span>
                                    <span class="bp">|</span> Except.ok x <span class="bp">=&gt;</span> pure x
                                    <span class="bp">|</span> Except.error e <span class="bp">=&gt;</span> pure e)
                          <span class="k">match</span> x <span class="k">with</span>
                            <span class="bp">|</span> Except.ok x <span class="bp">=&gt;</span> pure x
                            <span class="bp">|</span> Except.error e <span class="bp">=&gt;</span> pure e
                    <span class="k">match</span> x <span class="k">with</span>
                      <span class="bp">|</span> Except.ok x <span class="bp">=&gt;</span> pure x
                      <span class="bp">|</span> Except.error e <span class="bp">=&gt;</span> pure e)
            <span class="k">match</span> x <span class="k">with</span>
              <span class="bp">|</span> Except.ok x <span class="bp">=&gt;</span> pure x
              <span class="bp">|</span> Except.error e <span class="bp">=&gt;</span> pure e
          ExceptT.lift (pure none)
    <span class="k">match</span> x <span class="k">with</span>
      <span class="bp">|</span> Except.ok x <span class="bp">=&gt;</span> pure x
      <span class="bp">|</span> Except.error e <span class="bp">=&gt;</span> pure e) <span class="bp">=</span>
  ExceptCpsT.runCatch <span class="k">do</span>
    forM xss <span class="k">fun</span> xs <span class="bp">=&gt;</span>
        forM xs <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
          <span class="k">let</span> b <span class="bp">←</span> ExceptCpsT.lift (p x)
          <span class="k">if</span> b <span class="bp">=</span> true <span class="k">then</span> throw (some x) <span class="k">else</span> ExceptCpsT.lift (pure ())
    ExceptCpsT.lift (pure none)</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk158" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk158"><span class="alectryon-token"><span class="bp">|</span> nil <span class="bp">=&gt;</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span></span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> m Bool</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">nil</span></span><div class="goal-conclusion">(<span class="k">do</span>
    <span class="k">let</span> x <span class="bp">←</span>
      ExceptT.run <span class="k">do</span>
          <span class="k">do</span>
            <span class="k">let</span> x <span class="bp">←</span>
              ExceptT.run
                  (forM [] <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
                    <span class="k">let</span> x <span class="bp">←</span>
                      ExceptT.run <span class="k">do</span>
                          <span class="k">let</span> x <span class="bp">←</span>
                            ExceptT.run
                                (forM x <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
                                  <span class="k">let</span> x <span class="bp">←</span>
                                    ExceptT.run <span class="k">do</span>
                                        <span class="k">let</span> x_1 <span class="bp">←</span>
                                          ExceptT.lift (ExceptT.lift (ExceptT.lift (ExceptT.lift (ExceptT.lift (p x)))))
                                        <span class="k">if</span> x_1 <span class="bp">=</span> true <span class="k">then</span>
                                            ExceptT.lift (ExceptT.lift (ExceptT.lift (ExceptT.lift (throw (some x)))))
                                          <span class="k">else</span>
                                            ExceptT.lift
                                              (ExceptT.lift (ExceptT.lift (ExceptT.lift (ExceptT.lift (pure ())))))
                                  <span class="k">match</span> x <span class="k">with</span>
                                    <span class="bp">|</span> Except.ok x <span class="bp">=&gt;</span> pure x
                                    <span class="bp">|</span> Except.error e <span class="bp">=&gt;</span> pure e)
                          <span class="k">match</span> x <span class="k">with</span>
                            <span class="bp">|</span> Except.ok x <span class="bp">=&gt;</span> pure x
                            <span class="bp">|</span> Except.error e <span class="bp">=&gt;</span> pure e
                    <span class="k">match</span> x <span class="k">with</span>
                      <span class="bp">|</span> Except.ok x <span class="bp">=&gt;</span> pure x
                      <span class="bp">|</span> Except.error e <span class="bp">=&gt;</span> pure e)
            <span class="k">match</span> x <span class="k">with</span>
              <span class="bp">|</span> Except.ok x <span class="bp">=&gt;</span> pure x
              <span class="bp">|</span> Except.error e <span class="bp">=&gt;</span> pure e
          ExceptT.lift (pure none)
    <span class="k">match</span> x <span class="k">with</span>
      <span class="bp">|</span> Except.ok x <span class="bp">=&gt;</span> pure x
      <span class="bp">|</span> Except.error e <span class="bp">=&gt;</span> pure e) <span class="bp">=</span>
  ExceptCpsT.runCatch <span class="k">do</span>
    forM [] <span class="k">fun</span> xs <span class="bp">=&gt;</span>
        forM xs <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
          <span class="k">let</span> b <span class="bp">←</span> ExceptCpsT.lift (p x)
          <span class="k">if</span> b <span class="bp">=</span> true <span class="k">then</span> throw (some x) <span class="k">else</span> ExceptCpsT.lift (pure ())
    ExceptCpsT.lift (pure none)</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk159" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk159"><span class="alectryon-token">simp<span class="bp">!</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk15a" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk15a"><span class="alectryon-token"><span class="bp">|</span> cons </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>xs</var><b>: </b><span>List α</span></span></div></blockquote></div></small></div><span class="nv">xs</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>xss</var><b>: </b><span>List (List α)</span></span></div></blockquote></div></small></div><span class="nv">xss</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ih</var><b>: </b><span>(do
    let x ←
      ExceptT.run do
          do
            let x ←
              ExceptT.run
                  (forM xss fun x =&gt; do
                    let x ←
                      ExceptT.run do
                          let x ←
                            ExceptT.run
                                (forM x fun x =&gt; do
                                  let x ←
                                    ExceptT.run do
                                        let x_1 ←
                                          ExceptT.lift (ExceptT.lift (ExceptT.lift (ExceptT.lift (ExceptT.lift (p x)))))
                                        if x_1 = true then
                                            ExceptT.lift (ExceptT.lift (ExceptT.lift (ExceptT.lift (throw (some x)))))
                                          else
                                            ExceptT.lift
                                              (ExceptT.lift (ExceptT.lift (ExceptT.lift (ExceptT.lift (pure ())))))
                                  match x with
                                    | Except.ok x =&gt; pure x
                                    | Except.error e =&gt; pure e)
                          match x with
                            | Except.ok x =&gt; pure x
                            | Except.error e =&gt; pure e
                    match x with
                      | Except.ok x =&gt; pure x
                      | Except.error e =&gt; pure e)
            match x with
              | Except.ok x =&gt; pure x
              | Except.error e =&gt; pure e
          ExceptT.lift (pure none)
    match x with
      | Except.ok x =&gt; pure x
      | Except.error e =&gt; pure e) =
  ExceptCpsT.runCatch do
    forM xss fun xs =&gt;
        forM xs fun x =&gt; do
          let b ← ExceptCpsT.lift (p x)
          if b = true then throw (some x) else ExceptCpsT.lift (pure ())
    ExceptCpsT.lift (pure none)</span></span></div></blockquote></div></small></div><span class="nv">ih</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span></span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> m Bool</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>List α</span></span></span><br><span><var>xss</var><span class="hyp-type"><b>: </b><span>List (List α)</span></span></span><br><span><var>ih</var><span class="hyp-type"><b>: </b><span>(<span class="k">do</span>
    <span class="k">let</span> x <span class="bp">←</span>
      ExceptT.run <span class="k">do</span>
          <span class="k">do</span>
            <span class="k">let</span> x <span class="bp">←</span>
              ExceptT.run
                  (forM xss <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
                    <span class="k">let</span> x <span class="bp">←</span>
                      ExceptT.run <span class="k">do</span>
                          <span class="k">let</span> x <span class="bp">←</span>
                            ExceptT.run
                                (forM x <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
                                  <span class="k">let</span> x <span class="bp">←</span>
                                    ExceptT.run <span class="k">do</span>
                                        <span class="k">let</span> x_1 <span class="bp">←</span>
                                          ExceptT.lift (ExceptT.lift (ExceptT.lift (ExceptT.lift (ExceptT.lift (p x)))))
                                        <span class="k">if</span> x_1 <span class="bp">=</span> true <span class="k">then</span>
                                            ExceptT.lift (ExceptT.lift (ExceptT.lift (ExceptT.lift (throw (some x)))))
                                          <span class="k">else</span>
                                            ExceptT.lift
                                              (ExceptT.lift (ExceptT.lift (ExceptT.lift (ExceptT.lift (pure ())))))
                                  <span class="k">match</span> x <span class="k">with</span>
                                    <span class="bp">|</span> Except.ok x <span class="bp">=&gt;</span> pure x
                                    <span class="bp">|</span> Except.error e <span class="bp">=&gt;</span> pure e)
                          <span class="k">match</span> x <span class="k">with</span>
                            <span class="bp">|</span> Except.ok x <span class="bp">=&gt;</span> pure x
                            <span class="bp">|</span> Except.error e <span class="bp">=&gt;</span> pure e
                    <span class="k">match</span> x <span class="k">with</span>
                      <span class="bp">|</span> Except.ok x <span class="bp">=&gt;</span> pure x
                      <span class="bp">|</span> Except.error e <span class="bp">=&gt;</span> pure e)
            <span class="k">match</span> x <span class="k">with</span>
              <span class="bp">|</span> Except.ok x <span class="bp">=&gt;</span> pure x
              <span class="bp">|</span> Except.error e <span class="bp">=&gt;</span> pure e
          ExceptT.lift (pure none)
    <span class="k">match</span> x <span class="k">with</span>
      <span class="bp">|</span> Except.ok x <span class="bp">=&gt;</span> pure x
      <span class="bp">|</span> Except.error e <span class="bp">=&gt;</span> pure e) <span class="bp">=</span>
  ExceptCpsT.runCatch <span class="k">do</span>
    forM xss <span class="k">fun</span> xs <span class="bp">=&gt;</span>
        forM xs <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
          <span class="k">let</span> b <span class="bp">←</span> ExceptCpsT.lift (p x)
          <span class="k">if</span> b <span class="bp">=</span> true <span class="k">then</span> throw (some x) <span class="k">else</span> ExceptCpsT.lift (pure ())
    ExceptCpsT.lift (pure none)</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">cons</span></span><div class="goal-conclusion">(<span class="k">do</span>
    <span class="k">let</span> x <span class="bp">←</span>
      ExceptT.run <span class="k">do</span>
          <span class="k">do</span>
            <span class="k">let</span> x <span class="bp">←</span>
              ExceptT.run
                  (forM (xs :: xss) <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
                    <span class="k">let</span> x <span class="bp">←</span>
                      ExceptT.run <span class="k">do</span>
                          <span class="k">let</span> x <span class="bp">←</span>
                            ExceptT.run
                                (forM x <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
                                  <span class="k">let</span> x <span class="bp">←</span>
                                    ExceptT.run <span class="k">do</span>
                                        <span class="k">let</span> x_1 <span class="bp">←</span>
                                          ExceptT.lift (ExceptT.lift (ExceptT.lift (ExceptT.lift (ExceptT.lift (p x)))))
                                        <span class="k">if</span> x_1 <span class="bp">=</span> true <span class="k">then</span>
                                            ExceptT.lift (ExceptT.lift (ExceptT.lift (ExceptT.lift (throw (some x)))))
                                          <span class="k">else</span>
                                            ExceptT.lift
                                              (ExceptT.lift (ExceptT.lift (ExceptT.lift (ExceptT.lift (pure ())))))
                                  <span class="k">match</span> x <span class="k">with</span>
                                    <span class="bp">|</span> Except.ok x <span class="bp">=&gt;</span> pure x
                                    <span class="bp">|</span> Except.error e <span class="bp">=&gt;</span> pure e)
                          <span class="k">match</span> x <span class="k">with</span>
                            <span class="bp">|</span> Except.ok x <span class="bp">=&gt;</span> pure x
                            <span class="bp">|</span> Except.error e <span class="bp">=&gt;</span> pure e
                    <span class="k">match</span> x <span class="k">with</span>
                      <span class="bp">|</span> Except.ok x <span class="bp">=&gt;</span> pure x
                      <span class="bp">|</span> Except.error e <span class="bp">=&gt;</span> pure e)
            <span class="k">match</span> x <span class="k">with</span>
              <span class="bp">|</span> Except.ok x <span class="bp">=&gt;</span> pure x
              <span class="bp">|</span> Except.error e <span class="bp">=&gt;</span> pure e
          ExceptT.lift (pure none)
    <span class="k">match</span> x <span class="k">with</span>
      <span class="bp">|</span> Except.ok x <span class="bp">=&gt;</span> pure x
      <span class="bp">|</span> Except.error e <span class="bp">=&gt;</span> pure e) <span class="bp">=</span>
  ExceptCpsT.runCatch <span class="k">do</span>
    forM (xs :: xss) <span class="k">fun</span> xs <span class="bp">=&gt;</span>
        forM xs <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
          <span class="k">let</span> b <span class="bp">←</span> ExceptCpsT.lift (p x)
          <span class="k">if</span> b <span class="bp">=</span> true <span class="k">then</span> throw (some x) <span class="k">else</span> ExceptCpsT.lift (pure ())
    ExceptCpsT.lift (pure none)</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
    </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk15b" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk15b"><span class="alectryon-token"><span class="k">simp</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span></span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> m Bool</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>List α</span></span></span><br><span><var>xss</var><span class="hyp-type"><b>: </b><span>List (List α)</span></span></span><br><span><var>ih</var><span class="hyp-type"><b>: </b><span>(<span class="k">do</span>
    <span class="k">let</span> x <span class="bp">←</span>
      ExceptT.run <span class="k">do</span>
          <span class="k">do</span>
            <span class="k">let</span> x <span class="bp">←</span>
              ExceptT.run
                  (forM xss <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
                    <span class="k">let</span> x <span class="bp">←</span>
                      ExceptT.run <span class="k">do</span>
                          <span class="k">let</span> x <span class="bp">←</span>
                            ExceptT.run
                                (forM x <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
                                  <span class="k">let</span> x <span class="bp">←</span>
                                    ExceptT.run <span class="k">do</span>
                                        <span class="k">let</span> x_1 <span class="bp">←</span>
                                          ExceptT.lift (ExceptT.lift (ExceptT.lift (ExceptT.lift (ExceptT.lift (p x)))))
                                        <span class="k">if</span> x_1 <span class="bp">=</span> true <span class="k">then</span>
                                            ExceptT.lift (ExceptT.lift (ExceptT.lift (ExceptT.lift (throw (some x)))))
                                          <span class="k">else</span>
                                            ExceptT.lift
                                              (ExceptT.lift (ExceptT.lift (ExceptT.lift (ExceptT.lift (pure ())))))
                                  <span class="k">match</span> x <span class="k">with</span>
                                    <span class="bp">|</span> Except.ok x <span class="bp">=&gt;</span> pure x
                                    <span class="bp">|</span> Except.error e <span class="bp">=&gt;</span> pure e)
                          <span class="k">match</span> x <span class="k">with</span>
                            <span class="bp">|</span> Except.ok x <span class="bp">=&gt;</span> pure x
                            <span class="bp">|</span> Except.error e <span class="bp">=&gt;</span> pure e
                    <span class="k">match</span> x <span class="k">with</span>
                      <span class="bp">|</span> Except.ok x <span class="bp">=&gt;</span> pure x
                      <span class="bp">|</span> Except.error e <span class="bp">=&gt;</span> pure e)
            <span class="k">match</span> x <span class="k">with</span>
              <span class="bp">|</span> Except.ok x <span class="bp">=&gt;</span> pure x
              <span class="bp">|</span> Except.error e <span class="bp">=&gt;</span> pure e
          ExceptT.lift (pure none)
    <span class="k">match</span> x <span class="k">with</span>
      <span class="bp">|</span> Except.ok x <span class="bp">=&gt;</span> pure x
      <span class="bp">|</span> Except.error e <span class="bp">=&gt;</span> pure e) <span class="bp">=</span>
  ExceptCpsT.runCatch <span class="k">do</span>
    forM xss <span class="k">fun</span> xs <span class="bp">=&gt;</span>
        forM xs <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
          <span class="k">let</span> b <span class="bp">←</span> ExceptCpsT.lift (p x)
          <span class="k">if</span> b <span class="bp">=</span> true <span class="k">then</span> throw (some x) <span class="k">else</span> ExceptCpsT.lift (pure ())
    ExceptCpsT.lift (pure none)</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">cons</span></span><div class="goal-conclusion">(<span class="k">do</span>
    <span class="k">let</span> x <span class="bp">←</span>
      ExceptT.run
          (ExceptT.run
            (ExceptT.run
              (ExceptT.run
                (forM xs <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
                  <span class="k">let</span> x_1 <span class="bp">←</span> ExceptT.lift (ExceptT.lift (ExceptT.lift (ExceptT.lift (p x))))
                  <span class="k">let</span> x <span class="bp">←</span>
                    ExceptT.run
                        (<span class="k">if</span> x_1 <span class="bp">=</span> true <span class="k">then</span> ExceptT.lift (ExceptT.lift (ExceptT.lift (ExceptT.lift (throw (some x)))))
                        <span class="k">else</span> pure ())
                  <span class="k">match</span> x <span class="k">with</span>
                    <span class="bp">|</span> Except.ok x <span class="bp">=&gt;</span> pure x
                    <span class="bp">|</span> Except.error x <span class="bp">=&gt;</span> pure x))))
    <span class="k">let</span> x <span class="bp">←</span>
      <span class="k">match</span> x <span class="k">with</span>
        <span class="bp">|</span> Except.ok x <span class="bp">=&gt;</span> <span class="k">do</span>
          <span class="k">let</span> x <span class="bp">←</span>
            ExceptT.run
                (<span class="k">match</span> x <span class="k">with</span>
                <span class="bp">|</span> Except.ok x <span class="bp">=&gt;</span> <span class="k">do</span>
                  <span class="k">let</span> x <span class="bp">←</span>
                    ExceptT.run
                        (<span class="k">match</span> x <span class="k">with</span>
                        <span class="bp">|</span> Except.ok x <span class="bp">=&gt;</span>
                          ExceptT.run
                            (<span class="k">match</span> x <span class="k">with</span>
                            <span class="bp">|</span> Except.ok x <span class="bp">=&gt;</span> pure x
                            <span class="bp">|</span> Except.error x <span class="bp">=&gt;</span> pure x)
                        <span class="bp">|</span> Except.error e <span class="bp">=&gt;</span> pure (Except.error e))
                  <span class="k">match</span> x <span class="k">with</span>
                    <span class="bp">|</span> Except.ok x <span class="bp">=&gt;</span> <span class="k">do</span>
                      <span class="k">let</span> x <span class="bp">←</span>
                        ExceptT.run
                            (<span class="k">match</span> x <span class="k">with</span>
                            <span class="bp">|</span> Except.ok x <span class="bp">=&gt;</span> pure x
                            <span class="bp">|</span> Except.error x <span class="bp">=&gt;</span> pure x)
                      <span class="k">match</span> x <span class="k">with</span>
                        <span class="bp">|</span> Except.ok x <span class="bp">=&gt;</span>
                          ExceptT.run
                            (forM xss <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
                              <span class="k">let</span> x <span class="bp">←</span>
                                ExceptT.run
                                    (ExceptT.run
                                      (forM x <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
                                        <span class="k">let</span> x_1 <span class="bp">←</span> ExceptT.lift (ExceptT.lift (ExceptT.lift (ExceptT.lift (p x))))
                                        <span class="k">let</span> x <span class="bp">←</span>
                                          ExceptT.run
                                              (<span class="k">if</span> x_1 <span class="bp">=</span> true <span class="k">then</span>
                                                ExceptT.lift
                                                  (ExceptT.lift (ExceptT.lift (ExceptT.lift (throw (some x)))))
                                              <span class="k">else</span> pure ())
                                        <span class="k">match</span> x <span class="k">with</span>
                                          <span class="bp">|</span> Except.ok x <span class="bp">=&gt;</span> pure x
                                          <span class="bp">|</span> Except.error x <span class="bp">=&gt;</span> pure x))
                              <span class="k">let</span> x <span class="bp">←</span>
                                <span class="k">match</span> x <span class="k">with</span>
                                  <span class="bp">|</span> Except.ok x <span class="bp">=&gt;</span>
                                    ExceptT.run
                                      (<span class="k">match</span> x <span class="k">with</span>
                                      <span class="bp">|</span> Except.ok x <span class="bp">=&gt;</span> pure x
                                      <span class="bp">|</span> Except.error x <span class="bp">=&gt;</span> pure x)
                                  <span class="bp">|</span> Except.error e <span class="bp">=&gt;</span> pure (Except.error e)
                              <span class="k">match</span> x <span class="k">with</span>
                                <span class="bp">|</span> Except.ok x <span class="bp">=&gt;</span> pure x
                                <span class="bp">|</span> Except.error x <span class="bp">=&gt;</span> pure x)
                        <span class="bp">|</span> Except.error e <span class="bp">=&gt;</span> pure (Except.error e)
                    <span class="bp">|</span> Except.error e <span class="bp">=&gt;</span> pure (Except.error e)
                <span class="bp">|</span> Except.error e <span class="bp">=&gt;</span> pure (Except.error e))
          <span class="k">match</span> x <span class="k">with</span>
            <span class="bp">|</span> Except.ok x <span class="bp">=&gt;</span> <span class="k">do</span>
              <span class="k">let</span> x <span class="bp">←</span>
                ExceptT.run
                    (<span class="k">match</span> x <span class="k">with</span>
                    <span class="bp">|</span> Except.ok x <span class="bp">=&gt;</span> pure x
                    <span class="bp">|</span> Except.error x <span class="bp">=&gt;</span> pure x)
              <span class="k">match</span> x <span class="k">with</span>
                <span class="bp">|</span> Except.ok x <span class="bp">=&gt;</span> pure (Except.ok none)
                <span class="bp">|</span> Except.error e <span class="bp">=&gt;</span> pure (Except.error e)
            <span class="bp">|</span> Except.error e <span class="bp">=&gt;</span> pure (Except.error e)
        <span class="bp">|</span> Except.error e <span class="bp">=&gt;</span> pure (Except.error e)
    <span class="k">match</span> x <span class="k">with</span>
      <span class="bp">|</span> Except.ok x <span class="bp">=&gt;</span> pure x
      <span class="bp">|</span> Except.error x <span class="bp">=&gt;</span> pure x) <span class="bp">=</span>
  ExceptCpsT.runCatch <span class="k">do</span>
    forM xs <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
        <span class="k">let</span> b <span class="bp">←</span> ExceptCpsT.lift (p x)
        <span class="k">if</span> b <span class="bp">=</span> true <span class="k">then</span> throw (some x) <span class="k">else</span> ExceptCpsT.lift (pure ())
    forM xss <span class="k">fun</span> xs <span class="bp">=&gt;</span>
        forM xs <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
          <span class="k">let</span> b <span class="bp">←</span> ExceptCpsT.lift (p x)
          <span class="k">if</span> b <span class="bp">=</span> true <span class="k">then</span> throw (some x) <span class="k">else</span> ExceptCpsT.lift (pure ())
    ExceptCpsT.lift (pure none)</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
    </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk15c" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk15c"><span class="alectryon-token"><span class="k">induction</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>xs</var><b>: </b><span>List α</span></span></div></blockquote></div></small></div><span class="nv">xs</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span></span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> m Bool</span></span></span><br><span><var>xss</var><span class="hyp-type"><b>: </b><span>List (List α)</span></span></span><br><span><var>ih</var><span class="hyp-type"><b>: </b><span>(<span class="k">do</span>
    <span class="k">let</span> x <span class="bp">←</span>
      ExceptT.run <span class="k">do</span>
          <span class="k">do</span>
            <span class="k">let</span> x <span class="bp">←</span>
              ExceptT.run
                  (forM xss <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
                    <span class="k">let</span> x <span class="bp">←</span>
                      ExceptT.run <span class="k">do</span>
                          <span class="k">let</span> x <span class="bp">←</span>
                            ExceptT.run
                                (forM x <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
                                  <span class="k">let</span> x <span class="bp">←</span>
                                    ExceptT.run <span class="k">do</span>
                                        <span class="k">let</span> x_1 <span class="bp">←</span>
                                          ExceptT.lift (ExceptT.lift (ExceptT.lift (ExceptT.lift (ExceptT.lift (p x)))))
                                        <span class="k">if</span> x_1 <span class="bp">=</span> true <span class="k">then</span>
                                            ExceptT.lift (ExceptT.lift (ExceptT.lift (ExceptT.lift (throw (some x)))))
                                          <span class="k">else</span>
                                            ExceptT.lift
                                              (ExceptT.lift (ExceptT.lift (ExceptT.lift (ExceptT.lift (pure ())))))
                                  <span class="k">match</span> x <span class="k">with</span>
                                    <span class="bp">|</span> Except.ok x <span class="bp">=&gt;</span> pure x
                                    <span class="bp">|</span> Except.error e <span class="bp">=&gt;</span> pure e)
                          <span class="k">match</span> x <span class="k">with</span>
                            <span class="bp">|</span> Except.ok x <span class="bp">=&gt;</span> pure x
                            <span class="bp">|</span> Except.error e <span class="bp">=&gt;</span> pure e
                    <span class="k">match</span> x <span class="k">with</span>
                      <span class="bp">|</span> Except.ok x <span class="bp">=&gt;</span> pure x
                      <span class="bp">|</span> Except.error e <span class="bp">=&gt;</span> pure e)
            <span class="k">match</span> x <span class="k">with</span>
              <span class="bp">|</span> Except.ok x <span class="bp">=&gt;</span> pure x
              <span class="bp">|</span> Except.error e <span class="bp">=&gt;</span> pure e
          ExceptT.lift (pure none)
    <span class="k">match</span> x <span class="k">with</span>
      <span class="bp">|</span> Except.ok x <span class="bp">=&gt;</span> pure x
      <span class="bp">|</span> Except.error e <span class="bp">=&gt;</span> pure e) <span class="bp">=</span>
  ExceptCpsT.runCatch <span class="k">do</span>
    forM xss <span class="k">fun</span> xs <span class="bp">=&gt;</span>
        forM xs <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
          <span class="k">let</span> b <span class="bp">←</span> ExceptCpsT.lift (p x)
          <span class="k">if</span> b <span class="bp">=</span> true <span class="k">then</span> throw (some x) <span class="k">else</span> ExceptCpsT.lift (pure ())
    ExceptCpsT.lift (pure none)</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">cons.nil</span></span><div class="goal-conclusion">(<span class="k">do</span>
    <span class="k">let</span> x <span class="bp">←</span>
      ExceptT.run
          (ExceptT.run
            (ExceptT.run
              (ExceptT.run
                (forM [] <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
                  <span class="k">let</span> x_1 <span class="bp">←</span> ExceptT.lift (ExceptT.lift (ExceptT.lift (ExceptT.lift (p x))))
                  <span class="k">let</span> x <span class="bp">←</span>
                    ExceptT.run
                        (<span class="k">if</span> x_1 <span class="bp">=</span> true <span class="k">then</span> ExceptT.lift (ExceptT.lift (ExceptT.lift (ExceptT.lift (throw (some x)))))
                        <span class="k">else</span> pure ())
                  <span class="k">match</span> x <span class="k">with</span>
                    <span class="bp">|</span> Except.ok x <span class="bp">=&gt;</span> pure x
                    <span class="bp">|</span> Except.error x <span class="bp">=&gt;</span> pure x))))
    <span class="k">let</span> x <span class="bp">←</span>
      <span class="k">match</span> x <span class="k">with</span>
        <span class="bp">|</span> Except.ok x <span class="bp">=&gt;</span> <span class="k">do</span>
          <span class="k">let</span> x <span class="bp">←</span>
            ExceptT.run
                (<span class="k">match</span> x <span class="k">with</span>
                <span class="bp">|</span> Except.ok x <span class="bp">=&gt;</span> <span class="k">do</span>
                  <span class="k">let</span> x <span class="bp">←</span>
                    ExceptT.run
                        (<span class="k">match</span> x <span class="k">with</span>
                        <span class="bp">|</span> Except.ok x <span class="bp">=&gt;</span>
                          ExceptT.run
                            (<span class="k">match</span> x <span class="k">with</span>
                            <span class="bp">|</span> Except.ok x <span class="bp">=&gt;</span> pure x
                            <span class="bp">|</span> Except.error x <span class="bp">=&gt;</span> pure x)
                        <span class="bp">|</span> Except.error e <span class="bp">=&gt;</span> pure (Except.error e))
                  <span class="k">match</span> x <span class="k">with</span>
                    <span class="bp">|</span> Except.ok x <span class="bp">=&gt;</span> <span class="k">do</span>
                      <span class="k">let</span> x <span class="bp">←</span>
                        ExceptT.run
                            (<span class="k">match</span> x <span class="k">with</span>
                            <span class="bp">|</span> Except.ok x <span class="bp">=&gt;</span> pure x
                            <span class="bp">|</span> Except.error x <span class="bp">=&gt;</span> pure x)
                      <span class="k">match</span> x <span class="k">with</span>
                        <span class="bp">|</span> Except.ok x <span class="bp">=&gt;</span>
                          ExceptT.run
                            (forM xss <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
                              <span class="k">let</span> x <span class="bp">←</span>
                                ExceptT.run
                                    (ExceptT.run
                                      (forM x <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
                                        <span class="k">let</span> x_1 <span class="bp">←</span> ExceptT.lift (ExceptT.lift (ExceptT.lift (ExceptT.lift (p x))))
                                        <span class="k">let</span> x <span class="bp">←</span>
                                          ExceptT.run
                                              (<span class="k">if</span> x_1 <span class="bp">=</span> true <span class="k">then</span>
                                                ExceptT.lift
                                                  (ExceptT.lift (ExceptT.lift (ExceptT.lift (throw (some x)))))
                                              <span class="k">else</span> pure ())
                                        <span class="k">match</span> x <span class="k">with</span>
                                          <span class="bp">|</span> Except.ok x <span class="bp">=&gt;</span> pure x
                                          <span class="bp">|</span> Except.error x <span class="bp">=&gt;</span> pure x))
                              <span class="k">let</span> x <span class="bp">←</span>
                                <span class="k">match</span> x <span class="k">with</span>
                                  <span class="bp">|</span> Except.ok x <span class="bp">=&gt;</span>
                                    ExceptT.run
                                      (<span class="k">match</span> x <span class="k">with</span>
                                      <span class="bp">|</span> Except.ok x <span class="bp">=&gt;</span> pure x
                                      <span class="bp">|</span> Except.error x <span class="bp">=&gt;</span> pure x)
                                  <span class="bp">|</span> Except.error e <span class="bp">=&gt;</span> pure (Except.error e)
                              <span class="k">match</span> x <span class="k">with</span>
                                <span class="bp">|</span> Except.ok x <span class="bp">=&gt;</span> pure x
                                <span class="bp">|</span> Except.error x <span class="bp">=&gt;</span> pure x)
                        <span class="bp">|</span> Except.error e <span class="bp">=&gt;</span> pure (Except.error e)
                    <span class="bp">|</span> Except.error e <span class="bp">=&gt;</span> pure (Except.error e)
                <span class="bp">|</span> Except.error e <span class="bp">=&gt;</span> pure (Except.error e))
          <span class="k">match</span> x <span class="k">with</span>
            <span class="bp">|</span> Except.ok x <span class="bp">=&gt;</span> <span class="k">do</span>
              <span class="k">let</span> x <span class="bp">←</span>
                ExceptT.run
                    (<span class="k">match</span> x <span class="k">with</span>
                    <span class="bp">|</span> Except.ok x <span class="bp">=&gt;</span> pure x
                    <span class="bp">|</span> Except.error x <span class="bp">=&gt;</span> pure x)
              <span class="k">match</span> x <span class="k">with</span>
                <span class="bp">|</span> Except.ok x <span class="bp">=&gt;</span> pure (Except.ok none)
                <span class="bp">|</span> Except.error e <span class="bp">=&gt;</span> pure (Except.error e)
            <span class="bp">|</span> Except.error e <span class="bp">=&gt;</span> pure (Except.error e)
        <span class="bp">|</span> Except.error e <span class="bp">=&gt;</span> pure (Except.error e)
    <span class="k">match</span> x <span class="k">with</span>
      <span class="bp">|</span> Except.ok x <span class="bp">=&gt;</span> pure x
      <span class="bp">|</span> Except.error x <span class="bp">=&gt;</span> pure x) <span class="bp">=</span>
  ExceptCpsT.runCatch <span class="k">do</span>
    forM [] <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
        <span class="k">let</span> b <span class="bp">←</span> ExceptCpsT.lift (p x)
        <span class="k">if</span> b <span class="bp">=</span> true <span class="k">then</span> throw (some x) <span class="k">else</span> ExceptCpsT.lift (pure ())
    forM xss <span class="k">fun</span> xs <span class="bp">=&gt;</span>
        forM xs <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
          <span class="k">let</span> b <span class="bp">←</span> ExceptCpsT.lift (p x)
          <span class="k">if</span> b <span class="bp">=</span> true <span class="k">then</span> throw (some x) <span class="k">else</span> ExceptCpsT.lift (pure ())
    ExceptCpsT.lift (pure none)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Formal-lean-chk15d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span></span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> m Bool</span></span></span><br><span><var>xss</var><span class="hyp-type"><b>: </b><span>List (List α)</span></span></span><br><span><var>ih</var><span class="hyp-type"><b>: </b><span>(<span class="k">do</span>
    <span class="k">let</span> x <span class="bp">←</span>
      ExceptT.run <span class="k">do</span>
          <span class="k">do</span>
            <span class="k">let</span> x <span class="bp">←</span>
              ExceptT.run
                  (forM xss <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
                    <span class="k">let</span> x <span class="bp">←</span>
                      ExceptT.run <span class="k">do</span>
                          <span class="k">let</span> x <span class="bp">←</span>
                            ExceptT.run
                                (forM x <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
                                  <span class="k">let</span> x <span class="bp">←</span>
                                    ExceptT.run <span class="k">do</span>
                                        <span class="k">let</span> x_1 <span class="bp">←</span>
                                          ExceptT.lift (ExceptT.lift (ExceptT.lift (ExceptT.lift (ExceptT.lift (p x)))))
                                        <span class="k">if</span> x_1 <span class="bp">=</span> true <span class="k">then</span>
                                            ExceptT.lift (ExceptT.lift (ExceptT.lift (ExceptT.lift (throw (some x)))))
                                          <span class="k">else</span>
                                            ExceptT.lift
                                              (ExceptT.lift (ExceptT.lift (ExceptT.lift (ExceptT.lift (pure ())))))
                                  <span class="k">match</span> x <span class="k">with</span>
                                    <span class="bp">|</span> Except.ok x <span class="bp">=&gt;</span> pure x
                                    <span class="bp">|</span> Except.error e <span class="bp">=&gt;</span> pure e)
                          <span class="k">match</span> x <span class="k">with</span>
                            <span class="bp">|</span> Except.ok x <span class="bp">=&gt;</span> pure x
                            <span class="bp">|</span> Except.error e <span class="bp">=&gt;</span> pure e
                    <span class="k">match</span> x <span class="k">with</span>
                      <span class="bp">|</span> Except.ok x <span class="bp">=&gt;</span> pure x
                      <span class="bp">|</span> Except.error e <span class="bp">=&gt;</span> pure e)
            <span class="k">match</span> x <span class="k">with</span>
              <span class="bp">|</span> Except.ok x <span class="bp">=&gt;</span> pure x
              <span class="bp">|</span> Except.error e <span class="bp">=&gt;</span> pure e
          ExceptT.lift (pure none)
    <span class="k">match</span> x <span class="k">with</span>
      <span class="bp">|</span> Except.ok x <span class="bp">=&gt;</span> pure x
      <span class="bp">|</span> Except.error e <span class="bp">=&gt;</span> pure e) <span class="bp">=</span>
  ExceptCpsT.runCatch <span class="k">do</span>
    forM xss <span class="k">fun</span> xs <span class="bp">=&gt;</span>
        forM xs <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
          <span class="k">let</span> b <span class="bp">←</span> ExceptCpsT.lift (p x)
          <span class="k">if</span> b <span class="bp">=</span> true <span class="k">then</span> throw (some x) <span class="k">else</span> ExceptCpsT.lift (pure ())
    ExceptCpsT.lift (pure none)</span></span></span><br><span><var>head✝</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br><span><var>tail✝</var><span class="hyp-type"><b>: </b><span>List α</span></span></span><br></div><label class="goal-separator" for="Formal-lean-chk15d"><hr><span class="goal-name">cons.cons</span></label><div class="goal-conclusion">(<span class="k">do</span>
    <span class="k">let</span> x <span class="bp">←</span>
      ExceptT.run
          (ExceptT.run
            (ExceptT.run
              (ExceptT.run
                (forM (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
                  <span class="k">let</span> x_1 <span class="bp">←</span> ExceptT.lift (ExceptT.lift (ExceptT.lift (ExceptT.lift (p x))))
                  <span class="k">let</span> x <span class="bp">←</span>
                    ExceptT.run
                        (<span class="k">if</span> x_1 <span class="bp">=</span> true <span class="k">then</span> ExceptT.lift (ExceptT.lift (ExceptT.lift (ExceptT.lift (throw (some x)))))
                        <span class="k">else</span> pure ())
                  <span class="k">match</span> x <span class="k">with</span>
                    <span class="bp">|</span> Except.ok x <span class="bp">=&gt;</span> pure x
                    <span class="bp">|</span> Except.error x <span class="bp">=&gt;</span> pure x))))
    <span class="k">let</span> x <span class="bp">←</span>
      <span class="k">match</span> x <span class="k">with</span>
        <span class="bp">|</span> Except.ok x <span class="bp">=&gt;</span> <span class="k">do</span>
          <span class="k">let</span> x <span class="bp">←</span>
            ExceptT.run
                (<span class="k">match</span> x <span class="k">with</span>
                <span class="bp">|</span> Except.ok x <span class="bp">=&gt;</span> <span class="k">do</span>
                  <span class="k">let</span> x <span class="bp">←</span>
                    ExceptT.run
                        (<span class="k">match</span> x <span class="k">with</span>
                        <span class="bp">|</span> Except.ok x <span class="bp">=&gt;</span>
                          ExceptT.run
                            (<span class="k">match</span> x <span class="k">with</span>
                            <span class="bp">|</span> Except.ok x <span class="bp">=&gt;</span> pure x
                            <span class="bp">|</span> Except.error x <span class="bp">=&gt;</span> pure x)
                        <span class="bp">|</span> Except.error e <span class="bp">=&gt;</span> pure (Except.error e))
                  <span class="k">match</span> x <span class="k">with</span>
                    <span class="bp">|</span> Except.ok x <span class="bp">=&gt;</span> <span class="k">do</span>
                      <span class="k">let</span> x <span class="bp">←</span>
                        ExceptT.run
                            (<span class="k">match</span> x <span class="k">with</span>
                            <span class="bp">|</span> Except.ok x <span class="bp">=&gt;</span> pure x
                            <span class="bp">|</span> Except.error x <span class="bp">=&gt;</span> pure x)
                      <span class="k">match</span> x <span class="k">with</span>
                        <span class="bp">|</span> Except.ok x <span class="bp">=&gt;</span>
                          ExceptT.run
                            (forM xss <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
                              <span class="k">let</span> x <span class="bp">←</span>
                                ExceptT.run
                                    (ExceptT.run
                                      (forM x <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
                                        <span class="k">let</span> x_1 <span class="bp">←</span> ExceptT.lift (ExceptT.lift (ExceptT.lift (ExceptT.lift (p x))))
                                        <span class="k">let</span> x <span class="bp">←</span>
                                          ExceptT.run
                                              (<span class="k">if</span> x_1 <span class="bp">=</span> true <span class="k">then</span>
                                                ExceptT.lift
                                                  (ExceptT.lift (ExceptT.lift (ExceptT.lift (throw (some x)))))
                                              <span class="k">else</span> pure ())
                                        <span class="k">match</span> x <span class="k">with</span>
                                          <span class="bp">|</span> Except.ok x <span class="bp">=&gt;</span> pure x
                                          <span class="bp">|</span> Except.error x <span class="bp">=&gt;</span> pure x))
                              <span class="k">let</span> x <span class="bp">←</span>
                                <span class="k">match</span> x <span class="k">with</span>
                                  <span class="bp">|</span> Except.ok x <span class="bp">=&gt;</span>
                                    ExceptT.run
                                      (<span class="k">match</span> x <span class="k">with</span>
                                      <span class="bp">|</span> Except.ok x <span class="bp">=&gt;</span> pure x
                                      <span class="bp">|</span> Except.error x <span class="bp">=&gt;</span> pure x)
                                  <span class="bp">|</span> Except.error e <span class="bp">=&gt;</span> pure (Except.error e)
                              <span class="k">match</span> x <span class="k">with</span>
                                <span class="bp">|</span> Except.ok x <span class="bp">=&gt;</span> pure x
                                <span class="bp">|</span> Except.error x <span class="bp">=&gt;</span> pure x)
                        <span class="bp">|</span> Except.error e <span class="bp">=&gt;</span> pure (Except.error e)
                    <span class="bp">|</span> Except.error e <span class="bp">=&gt;</span> pure (Except.error e)
                <span class="bp">|</span> Except.error e <span class="bp">=&gt;</span> pure (Except.error e))
          <span class="k">match</span> x <span class="k">with</span>
            <span class="bp">|</span> Except.ok x <span class="bp">=&gt;</span> <span class="k">do</span>
              <span class="k">let</span> x <span class="bp">←</span>
                ExceptT.run
                    (<span class="k">match</span> x <span class="k">with</span>
                    <span class="bp">|</span> Except.ok x <span class="bp">=&gt;</span> pure x
                    <span class="bp">|</span> Except.error x <span class="bp">=&gt;</span> pure x)
              <span class="k">match</span> x <span class="k">with</span>
                <span class="bp">|</span> Except.ok x <span class="bp">=&gt;</span> pure (Except.ok none)
                <span class="bp">|</span> Except.error e <span class="bp">=&gt;</span> pure (Except.error e)
            <span class="bp">|</span> Except.error e <span class="bp">=&gt;</span> pure (Except.error e)
        <span class="bp">|</span> Except.error e <span class="bp">=&gt;</span> pure (Except.error e)
    <span class="k">match</span> x <span class="k">with</span>
      <span class="bp">|</span> Except.ok x <span class="bp">=&gt;</span> pure x
      <span class="bp">|</span> Except.error x <span class="bp">=&gt;</span> pure x) <span class="bp">=</span>
  ExceptCpsT.runCatch <span class="k">do</span>
    forM (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
        <span class="k">let</span> b <span class="bp">←</span> ExceptCpsT.lift (p x)
        <span class="k">if</span> b <span class="bp">=</span> true <span class="k">then</span> throw (some x) <span class="k">else</span> ExceptCpsT.lift (pure ())
    forM xss <span class="k">fun</span> xs <span class="bp">=&gt;</span>
        forM xs <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
          <span class="k">let</span> b <span class="bp">←</span> ExceptCpsT.lift (p x)
          <span class="k">if</span> b <span class="bp">=</span> true <span class="k">then</span> throw (some x) <span class="k">else</span> ExceptCpsT.lift (pure ())
    ExceptCpsT.lift (pure none)</div></blockquote></div></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk15e" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk15e"><span class="alectryon-token"><span class="k">&lt;;&gt;</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span></span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> m Bool</span></span></span><br><span><var>xss</var><span class="hyp-type"><b>: </b><span>List (List α)</span></span></span><br><span><var>ih</var><span class="hyp-type"><b>: </b><span>(<span class="k">do</span>
    <span class="k">let</span> x <span class="bp">←</span>
      ExceptT.run <span class="k">do</span>
          <span class="k">do</span>
            <span class="k">let</span> x <span class="bp">←</span>
              ExceptT.run
                  (forM xss <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
                    <span class="k">let</span> x <span class="bp">←</span>
                      ExceptT.run <span class="k">do</span>
                          <span class="k">let</span> x <span class="bp">←</span>
                            ExceptT.run
                                (forM x <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
                                  <span class="k">let</span> x <span class="bp">←</span>
                                    ExceptT.run <span class="k">do</span>
                                        <span class="k">let</span> x_1 <span class="bp">←</span>
                                          ExceptT.lift (ExceptT.lift (ExceptT.lift (ExceptT.lift (ExceptT.lift (p x)))))
                                        <span class="k">if</span> x_1 <span class="bp">=</span> true <span class="k">then</span>
                                            ExceptT.lift (ExceptT.lift (ExceptT.lift (ExceptT.lift (throw (some x)))))
                                          <span class="k">else</span>
                                            ExceptT.lift
                                              (ExceptT.lift (ExceptT.lift (ExceptT.lift (ExceptT.lift (pure ())))))
                                  <span class="k">match</span> x <span class="k">with</span>
                                    <span class="bp">|</span> Except.ok x <span class="bp">=&gt;</span> pure x
                                    <span class="bp">|</span> Except.error e <span class="bp">=&gt;</span> pure e)
                          <span class="k">match</span> x <span class="k">with</span>
                            <span class="bp">|</span> Except.ok x <span class="bp">=&gt;</span> pure x
                            <span class="bp">|</span> Except.error e <span class="bp">=&gt;</span> pure e
                    <span class="k">match</span> x <span class="k">with</span>
                      <span class="bp">|</span> Except.ok x <span class="bp">=&gt;</span> pure x
                      <span class="bp">|</span> Except.error e <span class="bp">=&gt;</span> pure e)
            <span class="k">match</span> x <span class="k">with</span>
              <span class="bp">|</span> Except.ok x <span class="bp">=&gt;</span> pure x
              <span class="bp">|</span> Except.error e <span class="bp">=&gt;</span> pure e
          ExceptT.lift (pure none)
    <span class="k">match</span> x <span class="k">with</span>
      <span class="bp">|</span> Except.ok x <span class="bp">=&gt;</span> pure x
      <span class="bp">|</span> Except.error e <span class="bp">=&gt;</span> pure e) <span class="bp">=</span>
  ExceptCpsT.runCatch <span class="k">do</span>
    forM xss <span class="k">fun</span> xs <span class="bp">=&gt;</span>
        forM xs <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
          <span class="k">let</span> b <span class="bp">←</span> ExceptCpsT.lift (p x)
          <span class="k">if</span> b <span class="bp">=</span> true <span class="k">then</span> throw (some x) <span class="k">else</span> ExceptCpsT.lift (pure ())
    ExceptCpsT.lift (pure none)</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">cons.nil</span></span><div class="goal-conclusion">(<span class="k">do</span>
    <span class="k">let</span> x <span class="bp">←</span>
      ExceptT.run
          (ExceptT.run
            (ExceptT.run
              (ExceptT.run
                (forM [] <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
                  <span class="k">let</span> x_1 <span class="bp">←</span> ExceptT.lift (ExceptT.lift (ExceptT.lift (ExceptT.lift (p x))))
                  <span class="k">let</span> x <span class="bp">←</span>
                    ExceptT.run
                        (<span class="k">if</span> x_1 <span class="bp">=</span> true <span class="k">then</span> ExceptT.lift (ExceptT.lift (ExceptT.lift (ExceptT.lift (throw (some x)))))
                        <span class="k">else</span> pure ())
                  <span class="k">match</span> x <span class="k">with</span>
                    <span class="bp">|</span> Except.ok x <span class="bp">=&gt;</span> pure x
                    <span class="bp">|</span> Except.error x <span class="bp">=&gt;</span> pure x))))
    <span class="k">let</span> x <span class="bp">←</span>
      <span class="k">match</span> x <span class="k">with</span>
        <span class="bp">|</span> Except.ok x <span class="bp">=&gt;</span> <span class="k">do</span>
          <span class="k">let</span> x <span class="bp">←</span>
            ExceptT.run
                (<span class="k">match</span> x <span class="k">with</span>
                <span class="bp">|</span> Except.ok x <span class="bp">=&gt;</span> <span class="k">do</span>
                  <span class="k">let</span> x <span class="bp">←</span>
                    ExceptT.run
                        (<span class="k">match</span> x <span class="k">with</span>
                        <span class="bp">|</span> Except.ok x <span class="bp">=&gt;</span>
                          ExceptT.run
                            (<span class="k">match</span> x <span class="k">with</span>
                            <span class="bp">|</span> Except.ok x <span class="bp">=&gt;</span> pure x
                            <span class="bp">|</span> Except.error x <span class="bp">=&gt;</span> pure x)
                        <span class="bp">|</span> Except.error e <span class="bp">=&gt;</span> pure (Except.error e))
                  <span class="k">match</span> x <span class="k">with</span>
                    <span class="bp">|</span> Except.ok x <span class="bp">=&gt;</span> <span class="k">do</span>
                      <span class="k">let</span> x <span class="bp">←</span>
                        ExceptT.run
                            (<span class="k">match</span> x <span class="k">with</span>
                            <span class="bp">|</span> Except.ok x <span class="bp">=&gt;</span> pure x
                            <span class="bp">|</span> Except.error x <span class="bp">=&gt;</span> pure x)
                      <span class="k">match</span> x <span class="k">with</span>
                        <span class="bp">|</span> Except.ok x <span class="bp">=&gt;</span>
                          ExceptT.run
                            (forM xss <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
                              <span class="k">let</span> x <span class="bp">←</span>
                                ExceptT.run
                                    (ExceptT.run
                                      (forM x <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
                                        <span class="k">let</span> x_1 <span class="bp">←</span> ExceptT.lift (ExceptT.lift (ExceptT.lift (ExceptT.lift (p x))))
                                        <span class="k">let</span> x <span class="bp">←</span>
                                          ExceptT.run
                                              (<span class="k">if</span> x_1 <span class="bp">=</span> true <span class="k">then</span>
                                                ExceptT.lift
                                                  (ExceptT.lift (ExceptT.lift (ExceptT.lift (throw (some x)))))
                                              <span class="k">else</span> pure ())
                                        <span class="k">match</span> x <span class="k">with</span>
                                          <span class="bp">|</span> Except.ok x <span class="bp">=&gt;</span> pure x
                                          <span class="bp">|</span> Except.error x <span class="bp">=&gt;</span> pure x))
                              <span class="k">let</span> x <span class="bp">←</span>
                                <span class="k">match</span> x <span class="k">with</span>
                                  <span class="bp">|</span> Except.ok x <span class="bp">=&gt;</span>
                                    ExceptT.run
                                      (<span class="k">match</span> x <span class="k">with</span>
                                      <span class="bp">|</span> Except.ok x <span class="bp">=&gt;</span> pure x
                                      <span class="bp">|</span> Except.error x <span class="bp">=&gt;</span> pure x)
                                  <span class="bp">|</span> Except.error e <span class="bp">=&gt;</span> pure (Except.error e)
                              <span class="k">match</span> x <span class="k">with</span>
                                <span class="bp">|</span> Except.ok x <span class="bp">=&gt;</span> pure x
                                <span class="bp">|</span> Except.error x <span class="bp">=&gt;</span> pure x)
                        <span class="bp">|</span> Except.error e <span class="bp">=&gt;</span> pure (Except.error e)
                    <span class="bp">|</span> Except.error e <span class="bp">=&gt;</span> pure (Except.error e)
                <span class="bp">|</span> Except.error e <span class="bp">=&gt;</span> pure (Except.error e))
          <span class="k">match</span> x <span class="k">with</span>
            <span class="bp">|</span> Except.ok x <span class="bp">=&gt;</span> <span class="k">do</span>
              <span class="k">let</span> x <span class="bp">←</span>
                ExceptT.run
                    (<span class="k">match</span> x <span class="k">with</span>
                    <span class="bp">|</span> Except.ok x <span class="bp">=&gt;</span> pure x
                    <span class="bp">|</span> Except.error x <span class="bp">=&gt;</span> pure x)
              <span class="k">match</span> x <span class="k">with</span>
                <span class="bp">|</span> Except.ok x <span class="bp">=&gt;</span> pure (Except.ok none)
                <span class="bp">|</span> Except.error e <span class="bp">=&gt;</span> pure (Except.error e)
            <span class="bp">|</span> Except.error e <span class="bp">=&gt;</span> pure (Except.error e)
        <span class="bp">|</span> Except.error e <span class="bp">=&gt;</span> pure (Except.error e)
    <span class="k">match</span> x <span class="k">with</span>
      <span class="bp">|</span> Except.ok x <span class="bp">=&gt;</span> pure x
      <span class="bp">|</span> Except.error x <span class="bp">=&gt;</span> pure x) <span class="bp">=</span>
  ExceptCpsT.runCatch <span class="k">do</span>
    forM [] <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
        <span class="k">let</span> b <span class="bp">←</span> ExceptCpsT.lift (p x)
        <span class="k">if</span> b <span class="bp">=</span> true <span class="k">then</span> throw (some x) <span class="k">else</span> ExceptCpsT.lift (pure ())
    forM xss <span class="k">fun</span> xs <span class="bp">=&gt;</span>
        forM xs <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
          <span class="k">let</span> b <span class="bp">←</span> ExceptCpsT.lift (p x)
          <span class="k">if</span> b <span class="bp">=</span> true <span class="k">then</span> throw (some x) <span class="k">else</span> ExceptCpsT.lift (pure ())
    ExceptCpsT.lift (pure none)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Formal-lean-chk15f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span></span></span></span><br><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>α <span class="bp">→</span> m Bool</span></span></span><br><span><var>xss</var><span class="hyp-type"><b>: </b><span>List (List α)</span></span></span><br><span><var>ih</var><span class="hyp-type"><b>: </b><span>(<span class="k">do</span>
    <span class="k">let</span> x <span class="bp">←</span>
      ExceptT.run <span class="k">do</span>
          <span class="k">do</span>
            <span class="k">let</span> x <span class="bp">←</span>
              ExceptT.run
                  (forM xss <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
                    <span class="k">let</span> x <span class="bp">←</span>
                      ExceptT.run <span class="k">do</span>
                          <span class="k">let</span> x <span class="bp">←</span>
                            ExceptT.run
                                (forM x <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
                                  <span class="k">let</span> x <span class="bp">←</span>
                                    ExceptT.run <span class="k">do</span>
                                        <span class="k">let</span> x_1 <span class="bp">←</span>
                                          ExceptT.lift (ExceptT.lift (ExceptT.lift (ExceptT.lift (ExceptT.lift (p x)))))
                                        <span class="k">if</span> x_1 <span class="bp">=</span> true <span class="k">then</span>
                                            ExceptT.lift (ExceptT.lift (ExceptT.lift (ExceptT.lift (throw (some x)))))
                                          <span class="k">else</span>
                                            ExceptT.lift
                                              (ExceptT.lift (ExceptT.lift (ExceptT.lift (ExceptT.lift (pure ())))))
                                  <span class="k">match</span> x <span class="k">with</span>
                                    <span class="bp">|</span> Except.ok x <span class="bp">=&gt;</span> pure x
                                    <span class="bp">|</span> Except.error e <span class="bp">=&gt;</span> pure e)
                          <span class="k">match</span> x <span class="k">with</span>
                            <span class="bp">|</span> Except.ok x <span class="bp">=&gt;</span> pure x
                            <span class="bp">|</span> Except.error e <span class="bp">=&gt;</span> pure e
                    <span class="k">match</span> x <span class="k">with</span>
                      <span class="bp">|</span> Except.ok x <span class="bp">=&gt;</span> pure x
                      <span class="bp">|</span> Except.error e <span class="bp">=&gt;</span> pure e)
            <span class="k">match</span> x <span class="k">with</span>
              <span class="bp">|</span> Except.ok x <span class="bp">=&gt;</span> pure x
              <span class="bp">|</span> Except.error e <span class="bp">=&gt;</span> pure e
          ExceptT.lift (pure none)
    <span class="k">match</span> x <span class="k">with</span>
      <span class="bp">|</span> Except.ok x <span class="bp">=&gt;</span> pure x
      <span class="bp">|</span> Except.error e <span class="bp">=&gt;</span> pure e) <span class="bp">=</span>
  ExceptCpsT.runCatch <span class="k">do</span>
    forM xss <span class="k">fun</span> xs <span class="bp">=&gt;</span>
        forM xs <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
          <span class="k">let</span> b <span class="bp">←</span> ExceptCpsT.lift (p x)
          <span class="k">if</span> b <span class="bp">=</span> true <span class="k">then</span> throw (some x) <span class="k">else</span> ExceptCpsT.lift (pure ())
    ExceptCpsT.lift (pure none)</span></span></span><br><span><var>head✝</var><span class="hyp-type"><b>: </b><span>α</span></span></span><br><span><var>tail✝</var><span class="hyp-type"><b>: </b><span>List α</span></span></span><br></div><label class="goal-separator" for="Formal-lean-chk15f"><hr><span class="goal-name">cons.cons</span></label><div class="goal-conclusion">(<span class="k">do</span>
    <span class="k">let</span> x <span class="bp">←</span>
      ExceptT.run
          (ExceptT.run
            (ExceptT.run
              (ExceptT.run
                (forM (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
                  <span class="k">let</span> x_1 <span class="bp">←</span> ExceptT.lift (ExceptT.lift (ExceptT.lift (ExceptT.lift (p x))))
                  <span class="k">let</span> x <span class="bp">←</span>
                    ExceptT.run
                        (<span class="k">if</span> x_1 <span class="bp">=</span> true <span class="k">then</span> ExceptT.lift (ExceptT.lift (ExceptT.lift (ExceptT.lift (throw (some x)))))
                        <span class="k">else</span> pure ())
                  <span class="k">match</span> x <span class="k">with</span>
                    <span class="bp">|</span> Except.ok x <span class="bp">=&gt;</span> pure x
                    <span class="bp">|</span> Except.error x <span class="bp">=&gt;</span> pure x))))
    <span class="k">let</span> x <span class="bp">←</span>
      <span class="k">match</span> x <span class="k">with</span>
        <span class="bp">|</span> Except.ok x <span class="bp">=&gt;</span> <span class="k">do</span>
          <span class="k">let</span> x <span class="bp">←</span>
            ExceptT.run
                (<span class="k">match</span> x <span class="k">with</span>
                <span class="bp">|</span> Except.ok x <span class="bp">=&gt;</span> <span class="k">do</span>
                  <span class="k">let</span> x <span class="bp">←</span>
                    ExceptT.run
                        (<span class="k">match</span> x <span class="k">with</span>
                        <span class="bp">|</span> Except.ok x <span class="bp">=&gt;</span>
                          ExceptT.run
                            (<span class="k">match</span> x <span class="k">with</span>
                            <span class="bp">|</span> Except.ok x <span class="bp">=&gt;</span> pure x
                            <span class="bp">|</span> Except.error x <span class="bp">=&gt;</span> pure x)
                        <span class="bp">|</span> Except.error e <span class="bp">=&gt;</span> pure (Except.error e))
                  <span class="k">match</span> x <span class="k">with</span>
                    <span class="bp">|</span> Except.ok x <span class="bp">=&gt;</span> <span class="k">do</span>
                      <span class="k">let</span> x <span class="bp">←</span>
                        ExceptT.run
                            (<span class="k">match</span> x <span class="k">with</span>
                            <span class="bp">|</span> Except.ok x <span class="bp">=&gt;</span> pure x
                            <span class="bp">|</span> Except.error x <span class="bp">=&gt;</span> pure x)
                      <span class="k">match</span> x <span class="k">with</span>
                        <span class="bp">|</span> Except.ok x <span class="bp">=&gt;</span>
                          ExceptT.run
                            (forM xss <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
                              <span class="k">let</span> x <span class="bp">←</span>
                                ExceptT.run
                                    (ExceptT.run
                                      (forM x <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
                                        <span class="k">let</span> x_1 <span class="bp">←</span> ExceptT.lift (ExceptT.lift (ExceptT.lift (ExceptT.lift (p x))))
                                        <span class="k">let</span> x <span class="bp">←</span>
                                          ExceptT.run
                                              (<span class="k">if</span> x_1 <span class="bp">=</span> true <span class="k">then</span>
                                                ExceptT.lift
                                                  (ExceptT.lift (ExceptT.lift (ExceptT.lift (throw (some x)))))
                                              <span class="k">else</span> pure ())
                                        <span class="k">match</span> x <span class="k">with</span>
                                          <span class="bp">|</span> Except.ok x <span class="bp">=&gt;</span> pure x
                                          <span class="bp">|</span> Except.error x <span class="bp">=&gt;</span> pure x))
                              <span class="k">let</span> x <span class="bp">←</span>
                                <span class="k">match</span> x <span class="k">with</span>
                                  <span class="bp">|</span> Except.ok x <span class="bp">=&gt;</span>
                                    ExceptT.run
                                      (<span class="k">match</span> x <span class="k">with</span>
                                      <span class="bp">|</span> Except.ok x <span class="bp">=&gt;</span> pure x
                                      <span class="bp">|</span> Except.error x <span class="bp">=&gt;</span> pure x)
                                  <span class="bp">|</span> Except.error e <span class="bp">=&gt;</span> pure (Except.error e)
                              <span class="k">match</span> x <span class="k">with</span>
                                <span class="bp">|</span> Except.ok x <span class="bp">=&gt;</span> pure x
                                <span class="bp">|</span> Except.error x <span class="bp">=&gt;</span> pure x)
                        <span class="bp">|</span> Except.error e <span class="bp">=&gt;</span> pure (Except.error e)
                    <span class="bp">|</span> Except.error e <span class="bp">=&gt;</span> pure (Except.error e)
                <span class="bp">|</span> Except.error e <span class="bp">=&gt;</span> pure (Except.error e))
          <span class="k">match</span> x <span class="k">with</span>
            <span class="bp">|</span> Except.ok x <span class="bp">=&gt;</span> <span class="k">do</span>
              <span class="k">let</span> x <span class="bp">←</span>
                ExceptT.run
                    (<span class="k">match</span> x <span class="k">with</span>
                    <span class="bp">|</span> Except.ok x <span class="bp">=&gt;</span> pure x
                    <span class="bp">|</span> Except.error x <span class="bp">=&gt;</span> pure x)
              <span class="k">match</span> x <span class="k">with</span>
                <span class="bp">|</span> Except.ok x <span class="bp">=&gt;</span> pure (Except.ok none)
                <span class="bp">|</span> Except.error e <span class="bp">=&gt;</span> pure (Except.error e)
            <span class="bp">|</span> Except.error e <span class="bp">=&gt;</span> pure (Except.error e)
        <span class="bp">|</span> Except.error e <span class="bp">=&gt;</span> pure (Except.error e)
    <span class="k">match</span> x <span class="k">with</span>
      <span class="bp">|</span> Except.ok x <span class="bp">=&gt;</span> pure x
      <span class="bp">|</span> Except.error x <span class="bp">=&gt;</span> pure x) <span class="bp">=</span>
  ExceptCpsT.runCatch <span class="k">do</span>
    forM (head<span class="bp">✝</span> :: tail<span class="bp">✝</span>) <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
        <span class="k">let</span> b <span class="bp">←</span> ExceptCpsT.lift (p x)
        <span class="k">if</span> b <span class="bp">=</span> true <span class="k">then</span> throw (some x) <span class="k">else</span> ExceptCpsT.lift (pure ())
    forM xss <span class="k">fun</span> xs <span class="bp">=&gt;</span>
        forM xs <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="k">do</span>
          <span class="k">let</span> b <span class="bp">←</span> ExceptCpsT.lift (p x)
          <span class="k">if</span> b <span class="bp">=</span> true <span class="k">then</span> throw (some x) <span class="k">else</span> ExceptCpsT.lift (pure ())
    ExceptCpsT.lift (pure none)</div></blockquote></div></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formal-lean-chk160" style="display: none" type="checkbox"><label class="alectryon-input" for="Formal-lean-chk160"><span class="alectryon-token"><span class="k">aesop</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><span class="k">add</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">safe</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">apply</span></span><span class="alectryon-token"> byCases_Bool_bind)</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span></pre>
<p>While it would be possible to override our <code>do'</code> notation such that its named syntax
is first translated to nameless <code>Stmt</code> constructors and then applied to <code>simp [Do.trans] in</code>,
for demonstration purposes we decided to encode these examples manually. In practice, the
macro implementation remains more desirable as mentioned in the paper.</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --></pre>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="alectryon.js"></script>
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
